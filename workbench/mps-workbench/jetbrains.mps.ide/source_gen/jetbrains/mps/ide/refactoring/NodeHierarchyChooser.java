package jetbrains.mps.ide.refactoring;

/*Generated by MPS */

import com.intellij.ui.components.JBScrollPane;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.ide.ThreadUtils;
import javax.swing.tree.TreePath;
import jetbrains.mps.ide.hierarchy.AbstractHierarchyTree;
import jetbrains.mps.refactoring.framework.ConceptAncestorsProvider;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class NodeHierarchyChooser extends JBScrollPane {
  private NodeHierarchyChooser.MyHierarchyTree myTree;

  public NodeHierarchyChooser(MPSProject mpsProject, final SNode node) {
    // XXX no need to extend ScrollPane, shall aggregate instead 
    this.myTree = new NodeHierarchyChooser.MyHierarchyTree(mpsProject.getRepository());
    mpsProject.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        NodeHierarchyChooser.this.myTree.setHierarchyNode(SNodeOperations.getNodeAncestor(node, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"), false, false));
      }
    });
    this.setViewportView(this.myTree);
    ThreadUtils.runInUIThreadNoWait(new Runnable() {
      public void run() {
        NodeHierarchyChooser.this.myTree.rebuildNow();
      }
    });
  }

  public Object getSelectedObject() {
    TreePath path = myTree.getSelectionPath();
    if (path == null) {
      return null;
    }
    return myTree.getSelectionPath().getLastPathComponent();
  }

  public static class MyHierarchyTree extends AbstractHierarchyTree {
    private ConceptAncestorsProvider ancestorsProvider;
    public MyHierarchyTree(SRepository repo) {
      super(repo);
    }
    @Override
    protected Set<SNode> getDescendants(SNode node, Set<SNode> visited) {
      this.ancestorsProvider = new ConceptAncestorsProvider();
      Set<SNode> descendants = this.ancestorsProvider.getDescendants(node);
      return SetSequence.fromSetWithValues(new HashSet<SNode>(), SetSequence.fromSet(descendants).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return !(SNodeOperations.getModel(it).isReadOnly());
        }
      }));
    }
    @Override
    protected SNode getParent(SNode node) {
      return null;
    }
    @Override
    protected Set<SNode> getParents(SNode node, Set<SNode> visited) {
      return new HashSet<SNode>();
    }
    @Override
    protected String noNodeString() {
      return "no node";
    }
  }
}
