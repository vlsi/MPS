package jetbrains.mps.ide.actions;

/*Generated by MPS */

import jetbrains.mps.workbench.action.BaseAction;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import javax.swing.Icon;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import org.jetbrains.annotations.NotNull;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import org.jetbrains.mps.openapi.module.SModule;
import org.apache.log4j.Level;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.util.IterableUtil;

public class CalcSNodeStatistic_Action extends BaseAction {
  private static final Logger LOG = LogManager.getLogger(CalcSNodeStatistic_Action.class);
  private static final Icon ICON = null;

  public CalcSNodeStatistic_Action() {
    super("Calc properties/refs/children statistic for SNodes", "", ICON);
    this.setIsAlwaysVisible(false);
    this.setExecuteOutsideCommand(true);
  }
  @Override
  public boolean isDumbAware() {
    return true;
  }
  @Override
  protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {
    if (!(super.collectActionData(event, _params))) {
      return false;
    }
    {
      MPSProject p = event.getData(MPSCommonDataKeys.MPS_PROJECT);
      MapSequence.fromMap(_params).put("mpsProject", p);
      if (p == null) {
        return false;
      }
    }
    return true;
  }
  @Override
  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {
    final Map<Integer, Integer> propertiesStatistic = MapSequence.fromMap(new HashMap<Integer, Integer>());
    final Map<Integer, Integer> childrenStatistic = MapSequence.fromMap(new HashMap<Integer, Integer>());
    final Map<Integer, Integer> refsStatistic = MapSequence.fromMap(new HashMap<Integer, Integer>());
    final Wrappers._int zeros = new Wrappers._int(0);
    ProgressManager.getInstance().run(new Task.Modal(((MPSProject) MapSequence.fromMap(_params).get("mpsProject")).getProject(), "Calculate statistic", true) {
      @Override
      public void run(@NotNull ProgressIndicator indicator) {
        final ProgressMonitorAdapter progress = new ProgressMonitorAdapter(indicator);
        ((MPSProject) MapSequence.fromMap(_params).get("mpsProject")).getModelAccess().runReadAction(new Runnable() {
          public void run() {
            Iterable<? extends SModule> modules = ((MPSProject) MapSequence.fromMap(_params).get("mpsProject")).getModulesWithGenerators();
            if (LOG.isEnabledFor(Level.WARN)) {
              LOG.warn("Modules: " + Sequence.fromIterable(modules).count());
            }
            Iterable<SModel> models = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {
              public Iterable<SModel> translate(SModule it) {
                return it.getModels();
              }
            });
            if (LOG.isEnabledFor(Level.WARN)) {
              LOG.warn("Models: " + Sequence.fromIterable(models).count());
            }

            progress.start("Traversing models...", Sequence.fromIterable(models).count());
            for (SModel m : Sequence.fromIterable(models)) {
              progress.step(m.getModelName());
              for (SNode node : Sequence.fromIterable(SNodeUtil.getDescendants(m))) {
                int propertiesCount = IterableUtil.asCollection(node.getProperties()).size();
                MapSequence.fromMap(propertiesStatistic).put(propertiesCount, (MapSequence.fromMap(propertiesStatistic).containsKey(propertiesCount) ? MapSequence.fromMap(propertiesStatistic).get(propertiesCount) + 1 : 1));

                int refsCount = IterableUtil.asCollection(node.getReferences()).size();
                MapSequence.fromMap(refsStatistic).put(refsCount, (MapSequence.fromMap(refsStatistic).containsKey(refsCount) ? MapSequence.fromMap(refsStatistic).get(refsCount) + 1 : 1));

                int childrenCount = IterableUtil.asCollection(node.getChildren()).size();
                MapSequence.fromMap(childrenStatistic).put(childrenCount, (MapSequence.fromMap(childrenStatistic).containsKey(childrenCount) ? MapSequence.fromMap(childrenStatistic).get(childrenCount) + 1 : 1));

                if (propertiesCount + refsCount + childrenCount == 0) {
                  zeros.value++;
                }
              }
              progress.advance(1);
            }
            progress.done();
          }
        });
      }
    });

    if (LOG.isEnabledFor(Level.WARN)) {
      LOG.warn("Property size statistic: " + propertiesStatistic);
    }
    if (LOG.isEnabledFor(Level.WARN)) {
      LOG.warn("Refs size statistic: " + refsStatistic);
    }
    if (LOG.isEnabledFor(Level.WARN)) {
      LOG.warn("Children size statistic: " + childrenStatistic);
    }
    if (LOG.isEnabledFor(Level.WARN)) {
      LOG.warn("Zeros statistic: " + zeros.value);
    }
  }
}
