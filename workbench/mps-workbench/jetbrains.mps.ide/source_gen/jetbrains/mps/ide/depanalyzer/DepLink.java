package jetbrains.mps.ide.depanalyzer;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.ide.depanalyzer.DependencyUtil.Dependency;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;

public final class DepLink {
  public DependencyUtil.Role role;
  public SModule module;
  public DependencyUtil.LinkType linktype;
  private final List<DepLink> myChildren;
  private final List<DepLink> myReferences;
  private DepLink myReusedDepLink;
  /*package*/ DepLink myParent;
  public DepLink(SModule module, DependencyUtil.Role role, DependencyUtil.LinkType linktype) {
    this.module = module;
    this.role = role;
    this.linktype = linktype;
    myChildren = ListSequence.fromList(new ArrayList<DepLink>());
    myReferences = ListSequence.fromList(new ArrayList<DepLink>());
  }
  public List<DepLink> children() {
    return myChildren;
  }
  public DepLink parent() {
    return myParent;
  }
  public void setReused(DepLink reusedDepLink) {
    myReusedDepLink = reusedDepLink;
    ListSequence.fromList(reusedDepLink.myReferences).addElement(this);
  }
  public DepLink getReused() {
    return myReusedDepLink;
  }
  public List<DepLink> reusedFrom() {
    return myReferences;
  }
  @Override
  public boolean equals(Object object) {
    if (object instanceof DepLink) {
      DepLink link = (DepLink) object;
      return link.module.equals(module) && link.linktype == linktype && link.role == role;
    }
    return false;
  }
  public Dependency getRoleModuleKey() {
    return new Dependency(this.module, this.role);
  }
  @Override
  public int hashCode() {
    return module.hashCode() + linktype.hashCode();
  }
  @Override
  public String toString() {
    return String.format("[%s %s %s]", role, module.getModuleName(), linktype);
  }
  /**
   * Flatten list of all children, recursively
   */
  public List<DepLink> allDependencies() {
    List<DepLink> rv = ListSequence.fromList(new LinkedList<DepLink>());
    Queue<DepLink> q = QueueSequence.fromQueue(new LinkedList<DepLink>());
    QueueSequence.fromQueue(q).addLastElement(this);
    while (QueueSequence.fromQueue(q).isNotEmpty()) {
      DepLink l = QueueSequence.fromQueue(q).removeFirstElement();
      QueueSequence.fromQueue(q).addSequence(ListSequence.fromList(l.children()));
      ListSequence.fromList(rv).addSequence(ListSequence.fromList(l.children()));
    }
    return rv;
  }
}
