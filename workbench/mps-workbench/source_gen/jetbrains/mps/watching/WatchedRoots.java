package jetbrains.mps.watching;

/*Generated by MPS */

import com.intellij.openapi.components.ApplicationComponent;
import java.util.Map;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.LocalFileSystem;
import java.util.HashMap;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.util.FileUtil;

/**
 * Component that lets you add watch requests.
 * It also lets you maintain big umbrella watched paths, like a while project dir.
 * This saves us a lot of other watch request creation, if they are under project dir, which is often the case.
 * The thing is our module structure is opaque (arbitrary model roots, data sources, etc, all of them
 * adding fs listeners on some dirs/files), unlike idea's where there is a known structure: modules, source roots.
 */
public class WatchedRoots implements ApplicationComponent {
  private final Map<Project, LocalFileSystem.WatchRequest> myProjectRequests = new HashMap<Project, LocalFileSystem.WatchRequest>();
  private final Map<String, LocalFileSystem.WatchRequest> myOtherRequests = new HashMap<String, LocalFileSystem.WatchRequest>();
  private final Map<String, Integer> myRequestedPaths = new HashMap<String, Integer>();
  private final LocalFileSystem myLocalFileSystem;


  public WatchedRoots(LocalFileSystem lfs) {
    myLocalFileSystem = lfs;
  }



  public void initComponent() {
  }



  public void disposeComponent() {
  }

  @NonNls
  @NotNull
  public String getComponentName() {
    return "Watched Roots";
  }



  public synchronized void addProjectWatch(Project project) {
    LocalFileSystem.WatchRequest request = myLocalFileSystem.addRootToWatch(project.getBasePath(), true);
    if (request == null) {
      return;
    }
    myProjectRequests.put(project, request);
  }

  public synchronized void removeProjectWatch(Project project) {
    LocalFileSystem.WatchRequest request = myProjectRequests.get(project);
    myProjectRequests.remove(project);

    if (request != null) {
      myLocalFileSystem.removeWatchedRoot(request);
    }

    // handle the case when something from project A added fs listener (=> a watch) under a dir of project B 

    List<String> pathsToWatch = ListSequence.fromList(new ArrayList<String>());
    for (String path : myRequestedPaths.keySet()) {
      if (!(myOtherRequests.containsKey(path))) {
        ListSequence.fromList(pathsToWatch).addElement(path);
      }
    }
    Set<LocalFileSystem.WatchRequest> requests = myLocalFileSystem.addRootsToWatch(pathsToWatch, true);
    for (LocalFileSystem.WatchRequest req : SetSequence.fromSet(requests)) {
      myOtherRequests.put(req.getRootPath(), req);
    }
  }

  public synchronized void addWatchRequest(String path) {
    Integer count = myRequestedPaths.get(path);
    if (count == null) {
      count = 1;
    } else {
      count = count + 1;
    }
    myRequestedPaths.put(path, count);

    boolean alreadyCovered = false;

    for (LocalFileSystem.WatchRequest watch : CollectionSequence.fromCollection(myProjectRequests.values())) {
      String watchPath = watch.getRootPath();
      if (FileUtil.isSubPath(watchPath, path)) {
        alreadyCovered = true;
        break;
      }
    }
    if (!(alreadyCovered)) {
      LocalFileSystem.WatchRequest request = myLocalFileSystem.addRootToWatch(path, true);
      if (request != null) {
        myOtherRequests.put(path, request);
      }
    }
  }

  public synchronized void removeWatchRequest(String path) {
    Integer count = myRequestedPaths.get(path);
    if (count == null) {
      return;
    }
    assert count > 0;
    count = count - 1;
    if (count > 0) {
      myRequestedPaths.put(path, count);
    } else {
      myRequestedPaths.remove(path);
      myLocalFileSystem.removeWatchedRoot(myOtherRequests.get(path));
      myOtherRequests.remove(path);
    }
  }


}
