package jetbrains.mps.ide.newSolutionDialog;

/*Generated by MPS */

import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.project.MPSProject;
import java.io.IOException;
import java.io.File;
import jetbrains.mps.extapi.model.EditableSModel;
import jetbrains.mps.smodel.SModelInternal;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.project.MPSExtentions;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.DevKit;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.ModelAccess;
import com.intellij.openapi.application.ApplicationManager;
import javax.lang.model.SourceVersion;
import jetbrains.mps.ide.NewModuleCheckUtil;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.smodel.MPSModuleOwner;
import jetbrains.mps.project.structure.modules.LanguageDescriptor;
import jetbrains.mps.library.LanguageDesign_DevKit;
import jetbrains.mps.project.persistence.LanguageDescriptorPersistence;
import jetbrains.mps.util.MacrosFactory;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.library.ModulesMiner;
import com.intellij.openapi.vfs.VfsUtil;
import jetbrains.mps.project.structure.modules.GeneratorDescriptor;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.persistence.DefaultModelRoot;
import jetbrains.mps.project.ModuleId;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.project.SModuleOperations;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.project.structure.modules.SolutionDescriptor;
import jetbrains.mps.project.persistence.SolutionDescriptorPersistence;
import jetbrains.mps.project.structure.modules.DevkitDescriptor;
import jetbrains.mps.project.persistence.DevkitDescriptorPersistence;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.vfs.FileSystem;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.persistence.ModelRoot;

public class NewModuleUtil {
  public static Solution createRuntimeSolution(Language language, String languageRootPath, MPSProject project) throws IOException {
    String basePath = languageRootPath + File.separator + "runtime";
    String namespace = language.getModuleName() + ".runtime";

    Solution runtime = NewModuleUtil.createSolution(namespace, basePath, project);
    EditableSModel runtimeModel = createModel(runtime, namespace);

    runtimeModel.save();
    return runtime;
  }

  public static Solution createSandboxSolution(Language language, String languageRootPath, MPSProject project) throws IOException {
    String basePath = languageRootPath + File.separator + "sandbox";
    String namespace = language.getModuleName() + ".sandbox";

    Solution sandbox = NewModuleUtil.createSolution(namespace, basePath, project);
    SModelInternal sandboxModel = (SModelInternal) createModel(sandbox, namespace);
    sandbox.addUsedLanguage(language.getModuleReference());
    sandboxModel.addLanguage(language.getModuleReference());
    for (SModuleReference extendedLanguage : language.getExtendedLanguageRefs()) {
      sandbox.addUsedLanguage(extendedLanguage);
      sandboxModel.addLanguage(extendedLanguage);
    }

    sandbox.save();
    ((EditableSModel) sandboxModel).save();
    return sandbox;
  }



  public static Solution createSolution(String namespace, String rootPath, MPSProject project) {
    return NewModuleUtil.createModule(MPSExtentions.DOT_SOLUTION, namespace, rootPath, project, new _FunctionTypes._return_P3_E0<Solution, String, IFile, MPSProject>() {
      public Solution invoke(String s, IFile f, MPSProject p) {
        return createNewSolution(s, f, p);
      }
    });
  }

  public static Language createLanguage(String namespace, String rootPath, MPSProject project) {
    return NewModuleUtil.createModule(MPSExtentions.DOT_LANGUAGE, namespace, rootPath, project, new _FunctionTypes._return_P3_E0<Language, String, IFile, MPSProject>() {
      public Language invoke(String s, IFile f, MPSProject p) {
        return createNewLanguage(s, f, true, true, p);
      }
    });
  }

  public static DevKit createDevKit(String namespace, String rootPath, MPSProject project) {
    return NewModuleUtil.createModule(MPSExtentions.DOT_DEVKIT, namespace, rootPath, project, new _FunctionTypes._return_P3_E0<DevKit, String, IFile, MPSProject>() {
      public DevKit invoke(String s, IFile f, MPSProject p) {
        return createNewDevkit(s, f, p);
      }
    });
  }



  public static void runModuleCreation(Project p, final _FunctionTypes._void_P0_E0 r) {
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        ApplicationManager.getApplication().assertWriteAccessAllowed();
        r.invoke();
      }
    });
  }

  public static String check(String extension, String namespace, String rootPath) {
    if (MPSExtentions.DOT_LANGUAGE.equals(extension) && !(SourceVersion.isName(namespace))) {
      return "Language namespace should be valid Java package";
    }
    if (rootPath.length() == 0) {
      return "Path should be specified";
    }
    String message = NewModuleCheckUtil.checkModuleDirectory(new File(rootPath), extension, "Module");
    if (message != null) {
      return message;
    }
    if (namespace.length() == 0) {
      return "Namespace should be specified";
    }
    if (MPSModuleRepository.getInstance().getModuleByFqName(namespace) != null) {
      return "Module namespace already exists";
    }
    if (NameUtil.shortNameFromLongName(namespace).length() == 0) {
      return "Enter valid namespace";
    }
    IFile moduleDir = getModuleFile(namespace, rootPath, extension).getParent();
    if (moduleDir.getDescendant(Language.LANGUAGE_MODELS).exists() || moduleDir.getDescendant(Solution.SOLUTION_MODELS).exists()) {
      return "Module already exists in this folder";
    }

    return null;
  }



  @Deprecated
  public static Language createNewLanguage(String namespace, IFile descriptorFile, boolean importLangDevDevkit, boolean createMainAspectModels, MPSModuleOwner moduleOwner) {
    assert !(descriptorFile.exists());
    LanguageDescriptor descriptor = createNewLanguageDescriptor(namespace, descriptorFile);

    if (importLangDevDevkit) {
      SModuleReference devkitRef = LanguageDesign_DevKit.MODULE_REFERENCE;
      descriptor.getUsedDevkits().add(devkitRef);
    }

    LanguageDescriptorPersistence.saveLanguageDescriptor(descriptorFile, descriptor, MacrosFactory.forModuleFile(descriptorFile));
    Language language = (Language) ModuleRepositoryFacade.createModule(ModulesMiner.getInstance().loadModuleHandle(descriptorFile), moduleOwner);

    if (createMainAspectModels) {
      try {
        createMainLanguageAspects(language);
      } catch (IOException e) {
        // todo: ??? 
        throw new RuntimeException(e);
      }
    }

    String templateModelsDir = descriptorFile.getParent().getPath() + File.separator + "generator" + File.separator + "template";
    try {
      VfsUtil.createDirectories(templateModelsDir);
    } catch (IOException ioException) {
    }


    final GeneratorDescriptor generatorDescriptor = new GeneratorDescriptor();
    generatorDescriptor.setGeneratorUID(Generator.generateGeneratorUID(language));
    generatorDescriptor.setNamespace(null);
    DefaultModelRoot templateModelsRoot = new DefaultModelRoot();
    templateModelsRoot.setContentRoot(descriptorFile.getParent().getPath());
    templateModelsRoot.addFile(DefaultModelRoot.SOURCE_ROOTS, templateModelsDir);
    generatorDescriptor.getModelRootDescriptors().add(templateModelsRoot.toDescriptor());
    generatorDescriptor.getUsedDevkits().add(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("fbc25dd2-5da4-483a-8b19-70928e1b62d7")).getModuleReference());
    generatorDescriptor.getUsedLanguages().add(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("b401a680-8325-4110-8fd3-84331ff25bef")).getModuleReference());
    generatorDescriptor.getUsedLanguages().add(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("d7706f63-9be2-479c-a3da-ae92af1e64d5")).getModuleReference());
    descriptor.getGenerators().add(generatorDescriptor);
    language.setLanguageDescriptor(descriptor, false);
    language.save();

    final Generator newGenerator = (Generator) MPSModuleRepository.getInstance().getModuleById(generatorDescriptor.getId());

    boolean alreadyOwnsTemplateModel = false;
    for (SModel modelDescriptor : newGenerator.getOwnModelDescriptors()) {
      if (SModelStereotype.isGeneratorModel(modelDescriptor)) {
        alreadyOwnsTemplateModel = true;
        break;
      }
    }
    if (!(alreadyOwnsTemplateModel)) {
      EditableSModel templateModel = SModuleOperations.createModelWithAdjustments(language.getModuleName() + ".generator.template" + "." + "main@" + SModelStereotype.GENERATOR, newGenerator.getModelRoots().iterator().next());
      SNode mappingConfiguration = SModelOperations.createNewNode(templateModel, null, "jetbrains.mps.lang.generator.structure.MappingConfiguration");
      SPropertyOperations.set(mappingConfiguration, "name", "main");
      SModelOperations.addRootNode(templateModel, mappingConfiguration);
      templateModel.save();
    }

    return language;
  }

  @Deprecated
  public static Solution createNewSolution(String namespace, IFile descriptorFile, MPSModuleOwner moduleOwner) {
    assert !(descriptorFile.exists());
    SolutionDescriptor descriptor = createNewSolutionDescriptor(namespace, descriptorFile);
    SolutionDescriptorPersistence.saveSolutionDescriptor(descriptorFile, descriptor, MacrosFactory.forModuleFile(descriptorFile));
    return (Solution) ModuleRepositoryFacade.createModule(ModulesMiner.getInstance().loadModuleHandle(descriptorFile), moduleOwner);
  }

  @Deprecated
  public static DevKit createNewDevkit(String namespace, IFile descriptorFile, MPSModuleOwner moduleOwner) {
    assert !(descriptorFile.exists());
    DevkitDescriptor descriptor = createNewDevkitDescriptor(namespace);
    DevkitDescriptorPersistence.saveDevKitDescriptor(descriptorFile, descriptor);
    return (DevKit) ModuleRepositoryFacade.createModule(ModulesMiner.getInstance().loadModuleHandle(descriptorFile), moduleOwner);
  }



  public static void createMainLanguageAspects(Language language) throws IOException {
    assert language.getModelRoots().iterator().hasNext();
    LanguageAspect.STRUCTURE.createNew(language).save();
    LanguageAspect.EDITOR.createNew(language).save();
    LanguageAspect.CONSTRAINTS.createNew(language).save();
    LanguageAspect.BEHAVIOR.createNew(language).save();
    LanguageAspect.TYPESYSTEM.createNew(language).save();
  }



  @Deprecated
  public static Language createNewLanguage(String namespace, IFile descriptorFile, MPSModuleOwner moduleOwner) {
    return createNewLanguage(namespace, descriptorFile, false, false, moduleOwner);
  }



  private static <T extends AbstractModule> T createModule(String extension, String namespace, String rootPath, MPSProject project, _FunctionTypes._return_P3_E0<? extends T, ? super String, ? super IFile, ? super MPSProject> creator) {
    IFile descriptorFile = NewModuleUtil.getModuleFile(namespace, rootPath, extension);
    T module = creator.invoke(namespace, descriptorFile, project);
    project.addModule(module.getModuleReference());
    module.save();
    return module;
  }

  private static IFile getModuleFile(String namespace, String rootPath, String extension) {
    String path = rootPath + File.separator + namespace + extension;
    return FileSystem.getInstance().getFileByPath(path);
  }

  private static SolutionDescriptor createNewSolutionDescriptor(String namespace, IFile descriptorFile) {
    SolutionDescriptor descriptor = new SolutionDescriptor();
    descriptor.setNamespace(namespace);
    descriptor.setId(ModuleId.regular());
    final IFile modelsDir = descriptorFile.getParent().getDescendant(Solution.SOLUTION_MODELS);
    if (modelsDir.exists() && modelsDir.getChildren().size() != 0) {
      throw new IllegalStateException("Trying to create a solution in an existing solution's directory: " + descriptorFile.getParent());
    } else {
      if (ModelAccess.instance().isInEDT()) {
        modelsDir.mkdirs();
      } else {
        ModelAccess.instance().writeFilesInEDT(new Runnable() {
          @Override
          public void run() {
            modelsDir.mkdirs();
          }
        });
      }
    }

    //  default descriptorModel roots 
    DefaultModelRoot modelRoot = new DefaultModelRoot();
    modelRoot.setContentRoot(modelsDir.getParent().getPath());
    modelRoot.addFile(DefaultModelRoot.SOURCE_ROOTS, modelsDir.getPath());
    descriptor.getModelRootDescriptors().add(modelRoot.toDescriptor());
    return descriptor;
  }

  private static LanguageDescriptor createNewLanguageDescriptor(String languageNamespace, IFile descriptorFile) {
    LanguageDescriptor languageDescriptor = new LanguageDescriptor();
    languageDescriptor.setNamespace(languageNamespace);
    languageDescriptor.setId(ModuleId.regular());
    IFile languageModels = descriptorFile.getParent().getDescendant(Language.LANGUAGE_MODELS);
    if (languageModels.exists()) {
      throw new IllegalStateException("Trying to create a language in an existing language's directory");
    }
    //  default descriptorModel roots 
    DefaultModelRoot modelRoot = new DefaultModelRoot();
    modelRoot.setContentRoot(languageModels.getParent().getPath());
    modelRoot.addFile(DefaultModelRoot.SOURCE_ROOTS, languageModels.getPath());
    languageDescriptor.getModelRootDescriptors().add(modelRoot.toDescriptor());
    return languageDescriptor;
  }

  private static DevkitDescriptor createNewDevkitDescriptor(String namespace) {
    DevkitDescriptor d = new DevkitDescriptor();
    d.setNamespace(namespace);
    d.setId(ModuleId.regular());
    return d;
  }

  private static EditableSModel createModel(SModule module, String modelName) {
    for (ModelRoot root : module.getModelRoots()) {
      if (root.canCreateModels() && root.canCreateModel(modelName)) {
        EditableSModel model = (EditableSModel) root.createModel(modelName);
        // todo: ??? 
        // this is strict model loading. without it save() not working - isLoaded() returns false in save method 
        // model.getSModel() 
        model.save();
        return model;

      }
    }
    throw new IllegalStateException("can't create model with " + modelName + " in module " + module.getModuleName());
  }
}
