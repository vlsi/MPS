package jetbrains.mps.ide.findusages.caches;

/*Generated by MPS */

import com.intellij.openapi.components.ApplicationComponent;
import jetbrains.mps.logging.Logger;
import com.intellij.psi.impl.cache.impl.id.IdTableBuilding;
import jetbrains.mps.ide.projectPane.fileSystem.MPSWorkbenchFileTypeFactory;
import org.jetbrains.annotations.NotNull;
import com.intellij.psi.impl.cache.impl.id.FileTypeIdIndexer;
import java.util.Map;
import com.intellij.psi.impl.cache.impl.id.IdIndexEntry;
import com.intellij.util.indexing.FileContent;
import java.util.Collections;
import org.objectweb.asm.ClassReader;
import jetbrains.mps.baseLanguage.javastub.asm.ASMClass;
import jetbrains.mps.reloading.AbstractClassPathItem;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.stubs.javastub.classpath.ClassifierKind;

public class StubModelsIndexer implements ApplicationComponent {
  private static Logger LOG = Logger.getLogger(StubModelsIndexer.class);

  public StubModelsIndexer() {
  }

  public void initComponent() {
    IdTableBuilding.registerIdIndexer(MPSWorkbenchFileTypeFactory.CLASS_FILE_TYPE, new StubModelsIndexer.MyFileTypeIdIndexer());
  }

  public void disposeComponent() {
  }

  @NotNull
  public String getComponentName() {
    return StubModelsIndexer.class.getSimpleName();
  }

  private static class MyFileTypeIdIndexer extends FileTypeIdIndexer {
    private MyFileTypeIdIndexer() {
    }

    @NotNull
    public Map<IdIndexEntry, Integer> map(FileContent inputData) {
      byte[] bytes = inputData.getContent();
      if (bytes == null || bytes.length == 0) {
        return Collections.emptyMap();
      }

      ClassReader reader;
      try {
        reader = new ClassReader(bytes);
      } catch (Throwable t) {
        LOG.error("bytes length: " + bytes.length, t);
        return Collections.emptyMap();
      }
      ASMClass ac = new ASMClass(reader);
      String fqName = ac.getFqName();
      if (AbstractClassPathItem.isAnonymous(NameUtil.namespaceFromLongName(fqName))) {
        return Collections.emptyMap();
      }

      ClassifierCacher updater = new ClassifierCacher();
      updater.updateClassifier(ClassifierKind.getClassifierKind(reader), ac);
      return updater.getResult();
    }
  }
}
