package jetbrains.mps.ide.hierarchy;

/*Generated by MPS */

import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.IOperationContext;
import java.util.HashSet;
import java.awt.Color;
import jetbrains.mps.smodel.ModelAccess;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import jetbrains.mps.ide.messages.Icons;
import jetbrains.mps.ide.ui.TreeTextUtil;

public class ChildHierarchyTreeNode extends HierarchyTreeNode {
  private boolean myInitialized = false;
  private Set<SNode> myVisited;

  public ChildHierarchyTreeNode(SNode declaration, IOperationContext operationContext, AbstractHierarchyTree tree, Set<SNode> visited) {
    super(declaration, operationContext, tree);
    myVisited = new HashSet<SNode>(visited);
    setColor(new Color(64, 0, 144));
    setText(calculateText());
  }

  @Override
  public boolean isInitialized() {
    return myInitialized;
  }

  @Override
  protected void doInit() {
    ModelAccess.instance().runReadAction(new Runnable() {
      @Override
      public void run() {
        try {
          SNode node = (SNode) getUserObject();
          List<SNode> descendants = new ArrayList<SNode>(myHierarchyTree.getAbstractChildren(node, myVisited));
          Collections.sort(descendants, new Comparator<SNode>() {
            @Override
            public int compare(SNode o1, SNode o2) {
              return ("" + o1.getPresentation()).compareTo(o2.getPresentation());
            }
          });
          Set<SNode> visited = new HashSet<SNode>(myVisited);
          visited.add(node);
          for (SNode descendant : descendants) {
            ChildHierarchyTreeNode childHierarchyTreeNode = new ChildHierarchyTreeNode(descendant, getOperationContext(), myHierarchyTree, visited);
            add(childHierarchyTreeNode);
          }
        } catch (CircularHierarchyException ex) {
          SNode errorNode = (SNode) ex.getRepeatedObject();
          final String message = ex.getMessage();
          HierarchyTreeNode errorTreeNode = new HierarchyTreeNode(errorNode, getOperationContext(), myHierarchyTree) {
            @Override
            protected void doUpdatePresentation() {
              super.doUpdatePresentation();
              setIcon(Icons.ERROR_ICON);
              setColor(Color.RED);
            }

            @Override
            protected String calculateAdditionalText() {
              return message;
            }
          };
          add(errorTreeNode);
        }
        myInitialized = true;
      }
    });
  }

  @Override
  public boolean isLeaf() {
    if (!(isInitialized())) {
      return false;
    }
    return getChildCount() == 0;
  }

  @Override
  protected void doUpdate() {
    this.removeAllChildren();
    myInitialized = false;
  }

  public String calculateText() {
    String name = super.toString();
    AbstractHierarchyView hierarchyView = myHierarchyTree.getHierarchyView();
    if (hierarchyView != null) {
      if (this == hierarchyView.myTreeNode) {
        name = TreeTextUtil.toHtml(name);
      }
    }
    return name;
  }
}
