package jetbrains.mps.ide.hierarchy;

/*Generated by MPS */

import jetbrains.mps.ide.ui.MPSTree;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.findUsages.FindUsagesManager;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.ide.ui.MPSTreeNode;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.util.Computable;
import java.util.Set;
import jetbrains.mps.util.CollectionUtil;
import jetbrains.mps.util.Condition;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.ArrayList;
import java.util.HashSet;
import jetbrains.mps.ide.ui.TreeTextUtil;
import jetbrains.mps.ide.ui.TextTreeNode;
import jetbrains.mps.smodel.SModelStereotype;

public abstract class AbstractHierarchyTree extends MPSTree {
  protected IOperationContext myOperationContext;
  protected FindUsagesManager myUsagesManager;
  protected AbstractHierarchyView myHierarchyView;
  protected SNode myHierarchyNode;
  protected String myConceptFqName;
  protected boolean myIsParentHierarchy;
  protected boolean myOnlyInOneModel;
  protected boolean myShowGeneratorModels;

  public AbstractHierarchyTree(AbstractHierarchyView hierarchyView, String aConceptFqName, boolean isParentHierarchy) {
    myHierarchyView = hierarchyView;
    myConceptFqName = aConceptFqName;
    myIsParentHierarchy = isParentHierarchy;
  }

  @Nullable
  public AbstractHierarchyView getHierarchyView() {
    return myHierarchyView;
  }

  public boolean overridesNodeIdentifierCalculation() {
    return false;
  }

  public String calculateNodeIdentifier(HierarchyTreeNode node) {
    throw new UnsupportedOperationException();
  }

  public boolean isParentHierarchy() {
    return myIsParentHierarchy;
  }

  /*package*/ void setParentHierarchy(boolean isParentHierarchy) {
    myIsParentHierarchy = isParentHierarchy;
  }

  public boolean isOnlyInOneModel() {
    return myOnlyInOneModel;
  }

  /*package*/ void setIsOnlyInOneModel(boolean isOnlyInOneModel) {
    boolean oldOnlyInOneModel = myOnlyInOneModel;
    myOnlyInOneModel = isOnlyInOneModel;
    if (oldOnlyInOneModel != myOnlyInOneModel) {
      rebuildNow();
    }
  }

  public boolean isShowGeneratorModels() {
    return myShowGeneratorModels;
  }

  public void setShowGeneratorModels(boolean showGeneratorModels) {
    boolean oldShowGeneratorModels = myShowGeneratorModels;
    myShowGeneratorModels = showGeneratorModels;
    if (oldShowGeneratorModels != myShowGeneratorModels) {
      rebuildNow();
    }
  }

  public void setOperationContext(IOperationContext operationContext) {
    if (operationContext != null) {
      myOperationContext = operationContext;
      myUsagesManager = FindUsagesManager.getInstance();
    }
  }

  @Override
  protected MPSTreeNode rebuild() {
    if (myHierarchyNode == null) {
      return new AbstractHierarchyTree.RootTextTreeNode(noNodeString());
    }
    return ModelAccess.instance().runReadAction(new Computable<MPSTreeNode>() {
      @Override
      public MPSTreeNode compute() {
        return rebuildParentHierarchy();
      }
    });
  }

  protected abstract String noNodeString();

  protected abstract SNode getParent(SNode node);

  protected abstract Set<SNode> getParents(SNode node, Set<SNode> visited) throws CircularHierarchyException;

  protected abstract Set<SNode> getDescendants(SNode node, Set<SNode> visited) throws CircularHierarchyException;

  protected Set<SNode> getAbstractChildren(final SNode node, Set<SNode> visited) throws CircularHierarchyException {
    Set<SNode> result;
    if (myIsParentHierarchy) {
      result = getParents(node, visited);
    } else {
      result = getDescendants(node, visited);
    }
    if (myOnlyInOneModel) {
      result = CollectionUtil.filter(result, new Condition<SNode>() {
        @Override
        public boolean met(SNode n) {
          if (n == null) {
            return false;
          }
          return SNodeOperations.getModel(n) == SNodeOperations.getModel(node);
        }
      });
    }
    if (!(myShowGeneratorModels)) {
      result = CollectionUtil.filter(result, new Condition<SNode>() {
        @Override
        public boolean met(SNode n) {
          if (n == null) {
            return false;
          }
          return !(isInGeneratorModel(n));
        }
      });
    }
    return result;
  }

  protected SNode getAbstractParent(SNode node) {
    if (myIsParentHierarchy) {
      return null;
    }
    SNode result = getParent(node);
    if (result == null) {
      return null;
    }
    if (!(myShowGeneratorModels)) {
      while (isInGeneratorModel(result)) {
        result = getParent(result);
        if (result == null) {
          return null;
        }
      }
    }
    if (myOnlyInOneModel && (SNodeOperations.getModel(result) != SNodeOperations.getModel(node))) {
      return null;
    }
    return result;
  }

  protected MPSTreeNode rebuildParentHierarchy() {
    ArrayList<SNode> parentHierarchy = new ArrayList<SNode>();
    SNode parentDeclaration = myHierarchyNode;
    while (parentDeclaration != null) {
      parentHierarchy.add(parentDeclaration);
      parentDeclaration = getAbstractParent(parentDeclaration);
    }
    HierarchyTreeNode parentTreeNode = null;
    HierarchyTreeNode hierarchyTreeNode = null;
    HierarchyTreeNode rootNode = null;
    Set<SNode> visited = new HashSet<SNode>();
    for (int i = parentHierarchy.size() - 1; i >= 0; i--) {
      hierarchyTreeNode = (i > 0 ?
        (new HierarchyTreeNode(parentHierarchy.get(i), myOperationContext, this)) :
        new ChildHierarchyTreeNode(parentHierarchy.get(i), myOperationContext, this, visited)
      );
      if (i == parentHierarchy.size() - 1) {
        rootNode = hierarchyTreeNode;
      }
      visited.add(parentHierarchy.get(i));
      if (parentTreeNode != null) {
        parentTreeNode.add(hierarchyTreeNode);
      }
      parentTreeNode = hierarchyTreeNode;
    }
    String text = "Hierarchy";
    if (myHierarchyView != null) {
      myHierarchyView.myTreeNode = hierarchyTreeNode;
      assert myHierarchyView.myTreeNode != null;
      text = "<html>Hierarchy for <font color=\"#400090\"><b>" + TreeTextUtil.toHtml(myHierarchyView.myTreeNode.calculateNodeIdentifier()) + "</b></font>";
    }
    TextTreeNode textRootNode = new AbstractHierarchyTree.RootTextTreeNode(text);
    textRootNode.add(rootNode);
    return textRootNode;
  }

  public boolean doubleClick(HierarchyTreeNode hierarchyTreeNode) {
    return false;
  }

  private boolean isInGeneratorModel(SNode n) {
    return SNodeOperations.getModel(n) != null && SModelStereotype.isGeneratorModel(SNodeOperations.getModel(n));
  }

  protected class RootTextTreeNode extends TextTreeNode {
    public RootTextTreeNode(String s) {
      super(s);
      if (myHierarchyView != null) {
        setIcon(myHierarchyView.getIcon());
      }
    }
  }
}
