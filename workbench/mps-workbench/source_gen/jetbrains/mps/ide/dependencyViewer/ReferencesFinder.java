package jetbrains.mps.ide.dependencyViewer;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.List;
import org.jetbrains.mps.openapi.model.SReference;
import java.util.HashMap;
import jetbrains.mps.ide.findusages.model.SearchResults;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.progress.ProgressMonitor;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.smodel.ModelAccess;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;

/*package*/ class ReferencesFinder {
  private Map<SModel, List<SReference>> myModelsRefsCache = new HashMap<SModel, List<SReference>>();

  /*package*/ ReferencesFinder() {
  }

  /*package*/ SearchResults getTargetSearchResults(List<SNode> nodes, DependencyViewerScope scope, ProgressMonitor monitor) {
    SearchResults results = new SearchResults();
    Set<SNode> targets = new HashSet<SNode>();
    try {
      monitor.start("computing references' targets", ListSequence.fromList(nodes).count());
      for (SNode node : nodes) {
        for (SReference ref : SNodeOperations.getReferences(((SNode) node))) {
          SNode target = jetbrains.mps.util.SNodeOperations.getTargetNodeSilently(ref);
          if (target == null || scope.contains(target)) {
            continue;
          }
          if (targets.add(target)) {
            results.getSearchResults().add(new SearchResult(target, "target"));
          }
        }
        monitor.advance(1);
        if (monitor.isCanceled()) {
          return results;
        }
      }
    } finally {
      monitor.done();
    }
    return results;
  }

  /*package*/ SearchResults getUsedLanguagesSearchResults(List<SNode> nodes, DependencyViewerScope scope, ProgressMonitor monitor) {
    SearchResults results = new SearchResults();
    Set<SNode> concepts = new HashSet<SNode>();
    try {
      monitor.start("computing used languages", ListSequence.fromList(nodes).count());
      for (SNode node : nodes) {
        SNode concept = SModelUtil.findConceptDeclaration(node.getConcept().getConceptId(), GlobalScope.getInstance());
        if (concepts.add(concept)) {
          results.getSearchResults().add(new SearchResult(concept, "concept"));
        }
        monitor.advance(1);
        if (monitor.isCanceled()) {
          return results;
        }
      }
    } finally {
      monitor.done();
    }
    return results;
  }

  /*package*/ SearchResults getUsagesSearchResults(List<SNode> references, final DependencyViewerScope sourceScope, final DependencyViewerScope targetScope, ProgressMonitor monitor) {
    final SearchResults<SNode> results = new SearchResults<SNode>();
    try {
      monitor.start("filtering references", ListSequence.fromList(references).count());
      for (final SNode node : ListSequence.fromList(references)) {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            for (SReference ref : SNodeOperations.getReferences(((SNode) node))) {
              SNode targetNode = jetbrains.mps.util.SNodeOperations.getTargetNodeSilently(ref);
              if (targetNode == null || !(targetScope.contains(targetNode)) || sourceScope.contains(targetNode)) {
                continue;
              }
              results.getSearchResults().add(new SearchResult(node, "references"));
              break;
            }
          }
        });
        if (monitor.isCanceled()) {
          return results;
        }
        monitor.advance(1);
      }
    } finally {
      monitor.done();
    }
    return results;
  }

  /*package*/ SearchResults getLanguageUsagesSearchResults(List<SNode> nodes, DependencyViewerScope sourceScope, final DependencyViewerScope targetScope, ProgressMonitor monitor) {
    final SearchResults<SNode> results = new SearchResults<SNode>();
    try {
      monitor.start("filtering nodes", ListSequence.fromList(nodes).count());
      for (final SNode node : ListSequence.fromList(nodes)) {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            SNode concept = SModelUtil.findConceptDeclaration(node.getConcept().getConceptId(), GlobalScope.getInstance());
            if (concept != null && targetScope.contains(concept)) {
              results.getSearchResults().add(new SearchResult(node, "language"));
            }
          }
        });
        if (monitor.isCanceled()) {
          return results;
        }
        monitor.advance(1);
      }
    } finally {
      monitor.done();
    }
    return results;
  }

  /*package*/ List<SNode> getNodes(DependencyViewerScope scope, ProgressMonitor monitor) {
    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());
    try {
      Iterable<SModel> models = CollectionSequence.fromCollection(scope.getModules()).translate(new ITranslator2<SModule, SModel>() {
        public Iterable<SModel> translate(SModule it) {
          return it.getModels();
        }
      }).concat(CollectionSequence.fromCollection(scope.getModels()));
      List<SNode> roots = Sequence.fromIterable(models).translate(new ITranslator2<SModel, SNode>() {
        public Iterable<SNode> translate(SModel it) {
          return (Iterable<SNode>) (Iterable) it.getRootNodes();
        }
      }).concat(CollectionSequence.fromCollection(scope.getRoots())).toListSequence();
      monitor.start("searching references in " + scope.getPresentation(), ListSequence.fromList(roots).count());
      for (SNode root : ListSequence.fromList(roots)) {
        ListSequence.fromList(result).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(((SNode) root), null, true, new String[]{})));
        if (monitor.isCanceled()) {
          return result;
        }
        monitor.advance(1);
      }
    } finally {
      monitor.done();
    }
    return result;
  }
}
