package jetbrains.mps.ide.editor.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.findusages.view.FindUtils;
import com.intellij.openapi.project.Project;
import com.intellij.ui.awt.RelativePoint;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import java.util.List;
import jetbrains.mps.project.GlobalScope;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.ide.editor.util.renderer.DefaultMethodRenderer;

public class GoToHelper {
  public GoToHelper() {
  }

  /**
   * TODO this class shoud be removed when find usages language will be rewritten to ClassLike instance
   */
  public static boolean hasApplicableFinder(SNode node, String finderClassName) {
    return FindUtils.getFinderByClassName(finderClassName).isApplicable(node);
  }
  public static void executeFinders(final SNode node, Project project, final String finderClassName, RelativePoint relativePoint) {
    final Wrappers._T<String> caption = new Wrappers._T<String>();
    final jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(project);

    mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
      public void run() {
        if (SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept"))) {
          caption.value = SPropertyOperations.getString(SNodeOperations.cast(node, MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept")), MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"));
        } else {
          caption.value = BehaviorReflection.invokeVirtual(String.class, node, "virtual_getPresentation_1213877396640", new Object[]{});
        }
        assert hasApplicableFinder(node, finderClassName);
      }
    });

    final Set<SNodeReference> nodes = SetSequence.fromSet(new HashSet<SNodeReference>());
    ProgressManager.getInstance().run(new Task.Modal(project, "Searching...", true) {
      @Override
      public void run(@NotNull final ProgressIndicator p) {
        mpsProject.getRepository().getModelAccess().runReadAction(new Runnable() {
          public void run() {
            List<SNode> list = FindUtils.executeFinder(finderClassName, node, GlobalScope.getInstance(), new ProgressMonitorAdapter(p));
            SetSequence.fromSet(nodes).addSequence(ListSequence.fromList(list).select(new ISelector<SNode, SNodePointer>() {
              public SNodePointer select(SNode it) {
                return new SNodePointer(it);
              }
            }));
          }
        });
      }
    });

    String title = "Choose overriding method of " + caption.value + "() to navigate to";
    GoToContextMenuUtil.showMenu(mpsProject, title, SetSequence.fromSet(nodes).toListSequence(), new DefaultMethodRenderer(), relativePoint);
  }
}
