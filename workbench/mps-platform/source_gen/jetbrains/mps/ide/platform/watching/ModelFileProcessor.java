package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.smodel.descriptor.source.FileBasedModelDataSource;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.project.IModule;
import jetbrains.mps.project.structure.modules.ModuleReference;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.descriptor.source.ReloadableSources;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.project.SModelRoot;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Map;
import java.util.Collection;
import jetbrains.mps.smodel.descriptor.source.changes.ModelFileWatcher;
import java.io.File;
import jetbrains.mps.ide.vfs.VirtualFileUtils;
import com.intellij.openapi.util.io.FileUtil;
import jetbrains.mps.internal.collections.runtime.ISelector;

/*package*/ class ModelFileProcessor extends EventProcessor {
  private final Set<FileBasedModelDataSource> myInvalidatedSources = SetSequence.fromSet(new HashSet<FileBasedModelDataSource>());
  private final Set<IModule> myModulesWithChangedModelSets = SetSequence.fromSet(new HashSet<IModule>());

  public ModelFileProcessor() {
  }

  public void validateModules(Iterable<IModule> modules) {
    // todo validate modules from ReloadableSources even if we haven't invalidated them by our own 
    Set<ModuleReference> toValidate = toModuleRefs(modules);
    for (Iterator<FileBasedModelDataSource> i = SetSequence.fromSet(myInvalidatedSources).iterator(); i.hasNext();) {
      if (SetSequence.fromSet(toValidate).contains(i.next().getOrigin())) {
        i.remove();
      }
    }
    SetSequence.fromSet(myModulesWithChangedModelSets).removeSequence(Sequence.fromIterable(modules));
  }

  protected boolean isEmpty() {
    return !(ReloadableSources.getInstance().needsReloading()) && SetSequence.fromSet(myInvalidatedSources).isEmpty() && SetSequence.fromSet(myModulesWithChangedModelSets).isEmpty();
  }

  public void update(ProgressIndicator indicator) {
    indicator.setText("Reloading updated models... Please wait.");
    for (IModule module : SetSequence.fromSet(myModulesWithChangedModelSets)) {
      indicator.setText2("reloading all models in module " + module.getModuleFqName());
      module.reloadFromDisk(false);
    }
    for (FileBasedModelDataSource source : SetSequence.fromSet(myInvalidatedSources)) {
      source.invalidate();
    }
    ReloadableSources.getInstance().reload(new ProgressMonitorAdapter(indicator));
  }

  protected boolean accepts(VirtualFile file) {
    return ListSequence.fromList(findSourceIntersection(file)).isNotEmpty() || ListSequence.fromList(findModelRootIntersection(file)).isNotEmpty();
  }

  @Override
  protected void processDelete(VirtualFile file) {
    invalidateModelsAndRoots(file);
  }

  @Override
  protected void processCreate(VirtualFile file) {
    invalidateModelsAndRoots(file);
  }

  private void invalidateModelsAndRoots(VirtualFile file) {
    List<FileBasedModelDataSource> sources = findSourceIntersection(file);
    SetSequence.fromSet(myInvalidatedSources).addSequence(ListSequence.fromList(sources));

    List<IModule> modules = findModelRootIntersection(file);
    SetSequence.fromSet(myModulesWithChangedModelSets).addSequence(ListSequence.fromList(modules));
  }

  protected void processContentChanged(VirtualFile file) {
    SetSequence.fromSet(myInvalidatedSources).addSequence(ListSequence.fromList(findSourceIntersection(file)));
  }

  private List<IModule> findModelRootIntersection(VirtualFile file) {
    List<IModule> res = ListSequence.fromList(new ArrayList<IModule>());
    for (IModule module : ListSequence.fromList(MPSModuleRepository.getInstance().getAllModules())) {
      for (SModelRoot smr : CollectionSequence.fromCollection(module.getSModelRoots())) {
        if (!(intersects(file, file.getFileSystem().findFileByPath(smr.getPath())))) {
          continue;
        }
        ListSequence.fromList(res).addElement(module);
        break;
      }
    }
    return res;
  }

  private List<FileBasedModelDataSource> findSourceIntersection(VirtualFile file) {
    List<FileBasedModelDataSource> res = ListSequence.fromList(new ArrayList<FileBasedModelDataSource>());
    Map<FileBasedModelDataSource, Collection<String>> s2f = ModelFileWatcher.getInstance().getSources2Files();
    for (Map.Entry<FileBasedModelDataSource, Collection<String>> entry : SetSequence.fromSet(s2f.entrySet())) {
      for (String path : CollectionSequence.fromCollection(entry.getValue())) {
        if (!(intersects(file, file.getFileSystem().findFileByPath(path)))) {
          continue;
        }
        ListSequence.fromList(res).addElement(entry.getKey());
        break;
      }
    }
    return res;
  }

  private boolean intersects(VirtualFile vf1, VirtualFile vf2) {
    if (vf1 == null || vf2 == null) {
      return false;
    }

    File f1 = VirtualFileUtils.toFile(vf1);
    File f2 = VirtualFileUtils.toFile(vf2);
    if (f1 == null || f2 == null) {
      return false;
    }

    return FileUtil.isAncestor(f1, f2, false) || FileUtil.isAncestor(f2, f1, false);
  }

  private Set<ModuleReference> toModuleRefs(Iterable<IModule> modules) {
    return SetSequence.fromSetWithValues(new HashSet<ModuleReference>(), Sequence.fromIterable(modules).select(new ISelector<IModule, ModuleReference>() {
      public ModuleReference select(IModule it) {
        return it.getModuleReference();
      }
    }).toListSequence());
  }
}
