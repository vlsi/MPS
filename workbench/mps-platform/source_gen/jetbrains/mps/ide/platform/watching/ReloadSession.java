package jetbrains.mps.ide.platform.watching;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.concurrent.atomic.AtomicInteger;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.util.SubProgressKind;

public class ReloadSession {
  private List<ReloadListener> myListeners = ListSequence.fromList(new ArrayList<ReloadListener>());
  private boolean myReloaded = false;
  private Map<Class, ReloadParticipant> myParticipants = MapSequence.fromMap(new HashMap<Class, ReloadParticipant>());
  private boolean myEmpty = true;
  private AtomicInteger myEmployCount = new AtomicInteger(0);

  public ReloadSession(Iterable<ReloadListener> listeners) {
    ListSequence.fromList(myListeners).addSequence(Sequence.fromIterable(listeners));
  }

  /*package*/ boolean isBeingEmployed() {
    return myEmployCount.get() > 0;
  }

  /*package*/ void incEmployCount() {
    int count = myEmployCount.incrementAndGet();
    assert count >= 0;
  }

  /*package*/ void decEmployCount() {
    int count = myEmployCount.decrementAndGet();
    assert count >= 0;
  }

  /*package*/ boolean isEmpty() {
    return myEmpty;
  }

  /*package*/ boolean wantsToShowProgress() {
    // if at least one participant wants to show, we say that all reload session wants 
    return Sequence.fromIterable(getParticipants()).any(new IWhereFilter<ReloadParticipant>() {
      public boolean accept(ReloadParticipant it) {
        return it.wantsToShowProgress();
      }
    });
  }

  /*package*/ void updateStatus() {
    myEmpty = Sequence.fromIterable(getParticipants()).all(new IWhereFilter<ReloadParticipant>() {
      public boolean accept(ReloadParticipant it) {
        return it.isEmpty();
      }
    });
  }

  protected static Logger LOG = LogManager.getLogger(ReloadSession.class);
  /*package*/ void doReload(final ProgressMonitor monitor) {
    assert !(myReloaded) : "Contract: do not call doReload twice on one reload session";
    myReloaded = true;

    final Iterable<ReloadParticipant> participants = getParticipants();
    monitor.start("Reloading Files", Sequence.fromIterable(participants).count());
    long beginTime = System.nanoTime();
    try {
      if (LOG.isDebugEnabled()) {
        LOG.debug("File system reload started");
      }
      fireReloadStarted();
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          for (ReloadParticipant rp : participants) {
            rp.update(monitor.subTask(1, SubProgressKind.REPLACING));
          }
        }
      });
    } finally {
      if (LOG.isInfoEnabled()) {
        LOG.info(String.format("File system reload finished in %.3f s", (System.nanoTime() - beginTime) / 1000000000.));
      }
      monitor.done();
      fireReloadFinished();
    }
  }

  /*package*/ void clear() {
    ListSequence.fromList(myListeners).clear();
    MapSequence.fromMap(myParticipants).clear();
  }

  /*package*/ <T extends ReloadParticipant> T getParticipant(Class<T> participantClass) {
    ReloadParticipant p = MapSequence.fromMap(myParticipants).get(participantClass);
    if (p == null) {
      try {
        p = participantClass.newInstance();
        MapSequence.fromMap(myParticipants).put(participantClass, p);
      } catch (IllegalAccessException ignored) {
      } catch (InstantiationException ignored) {
      }
    }
    return (T) p;
  }

  private Iterable<ReloadParticipant> getParticipants() {
    return MapSequence.fromMap(myParticipants).values();
  }

  private void fireReloadStarted() {
    for (ReloadListener rl : myListeners) {
      rl.reloadStarted();
    }
  }

  private void fireReloadFinished() {
    for (ReloadListener rl : myListeners) {
      rl.reloadFinished();
    }
  }
}
