package jetbrains.mps.ide.platform.refactoring;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.refactoring.framework.RefactoringContext;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.refactoring.framework.IRefactoring;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.refactoring.framework.ILoggableRefactoring;
import com.intellij.openapi.project.Project;
import jetbrains.mps.ide.project.ProjectHelper;
import javax.swing.SwingUtilities;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.project.ProjectOperationContext;
import javax.swing.JOptionPane;
import jetbrains.mps.ide.actions.MPSCommonDataKeys;
import com.intellij.ide.DataManager;
import jetbrains.mps.refactoring.StructureModificationProcessor;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.ArrayList;
import jetbrains.mps.findUsages.UsagesList;
import java.util.Set;
import jetbrains.mps.smodel.SModelRepository;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SModelReference;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.util.SNodeOperations;
import jetbrains.mps.extapi.model.EditableSModel;
import jetbrains.mps.refactoring.framework.RefactoringNodeMembersAccessModifier;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.make.IMakeService;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.resources.ModelsToResources;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;

public class RefactoringFacade {
  protected Logger myLog = Logger.getLogger(this.getClass());

  public RefactoringFacade() {
  }

  public void executeSimple(final RefactoringContext context) {
    ThreadUtils.assertEDT();
    final IRefactoring refactoring = context.getRefactoring();
    List<SModel> modelsToGenerate = getModelsToGenerate(refactoring, context);
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        try {
          refactoring.refactor(context);
          if (refactoring instanceof ILoggableRefactoring) {
            if (!(context.isLocal())) {
              writeIntoLog(context);
            }
            updateModels(context);
          }
        } catch (Throwable t) {
          myLog.error("An exception occured while trying to execute refactoring " + refactoring.getUserFriendlyName() + ". Models could have been corrupted.", t);
        }
      }
    });
    if (context.getDoesGenerateModels()) {
      generateModels(modelsToGenerate, context);
    } else {
      //  mark "generation required" 
    }
    try {
      refactoring.doWhenDone(context);
    } catch (Throwable t) {
      myLog.error("An error occurred in doWhenDone(), refactoring: " + refactoring.getUserFriendlyName(), t);
    }
  }

  private void doExecuteWithDialog(final RefactoringContext refactoringContext) {
    final IRefactoring refactoring = refactoringContext.getRefactoring();
    final Project ideaProject = ProjectHelper.toIdeaProject(refactoringContext.getCurrentOperationContext().getProject());
    final List<SModel> modelsToGenerate = getModelsToGenerate(refactoring, refactoringContext);
    SwingUtilities.invokeLater(new Runnable() {
      @Override
      public void run() {
        final boolean cancelled = RefactoringAccess.getInstance().showRefactoringDialog(ideaProject, refactoringContext, refactoring, !(modelsToGenerate.isEmpty()));
        if (!(cancelled)) {
          ModelAccess.instance().runWriteInEDT(new Runnable() {
            @Override
            public void run() {
              executeSimple(refactoringContext);
            }
          });
        }

      }
    });
  }

  public void execute(final RefactoringContext refactoringContext) {
    ThreadUtils.assertEDT();
    ModelAccess.assertLegalRead();
    boolean success = refactoringContext.getRefactoring().init(refactoringContext);
    if (success) {
      findUsagesAndRun(refactoringContext);
    }
  }

  private void findUsagesAndRun(final RefactoringContext refactoringContext) {
    SwingUtilities.invokeLater(new Runnable() {
      @Override
      public void run() {
        ProgressManager.getInstance().run(new Task.Modal(ProjectHelper.toIdeaProject(refactoringContext.getCurrentOperationContext().getProject()), "Finding usages...", false) {
          @Override
          public void run(@NotNull ProgressIndicator indicator) {
            indicator.setIndeterminate(true);
            SearchResults usages = findUsagesSimple(refactoringContext);
            showConfirmDialogAndExecuteInUI(usages, refactoringContext);
          }
        });

      }
    });

  }

  private SearchResults findUsagesSimple(final RefactoringContext refactoringContext) {
    final Wrappers._T<SearchResults> result = new Wrappers._T<SearchResults>(null);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        try {
          jetbrains.mps.project.Project project = refactoringContext.getSelectedProject();
          refactoringContext.setCurrentOperationContext(new ProjectOperationContext(project));
          IRefactoring refactoring = refactoringContext.getRefactoring();
          result.value = refactoring.getAffectedNodes(refactoringContext);
          if (result.value == null) {
            result.value = new SearchResults();
          }
        } catch (Throwable t) {
          myLog.error(t);
        }
      }
    });
    return result.value;
  }

  private void showConfirmDialogAndExecuteInUI(SearchResults result, final RefactoringContext refactoringContext) {
    if (result == null) {
      SwingUtilities.invokeLater(new Runnable() {
        @Override
        public void run() {
          int promptResult = JOptionPane.showConfirmDialog(MPSCommonDataKeys.FRAME.getData(DataManager.getInstance().getDataContext()), "An exception occurred during searching affected nodes. Do you want to continue anyway?", "Exception", JOptionPane.YES_NO_OPTION);
          if (promptResult == JOptionPane.YES_OPTION) {
            executeInUI(new SearchResults(), refactoringContext);
          }
        }
      });
    } else {
      executeInUI(result, refactoringContext);
    }
  }

  private void executeInUI(final SearchResults usages, final RefactoringContext refactoringContext) {
    ModelAccess.instance().runReadInEDT(new Runnable() {
      @Override
      public void run() {
        refactoringContext.setUsages(usages);
        if (!(usages.getSearchResults().isEmpty())) {
          showRefactoring(refactoringContext, usages);
        } else {
          doExecuteWithDialog(refactoringContext);
        }
      }
    });
  }

  private void showRefactoring(final RefactoringContext refactoringContext, final SearchResults searchResults) {
    RefactoringViewAction okAction = new RefactoringViewAction() {
      @Override
      public void performAction(final RefactoringViewItem refactoringViewItem) {
        ModelAccess.instance().runWriteInEDT(new Runnable() {
          @Override
          public void run() {
            executeSimple(refactoringContext);
            refactoringViewItem.close();
          }
        });
      }
    };
    List<SModel> modelsToGenerate = getModelsToGenerate(refactoringContext.getRefactoring(), refactoringContext);
    RefactoringAccess.getInstance().showRefactoringView(refactoringContext, okAction, searchResults, !(modelsToGenerate.isEmpty()), refactoringContext.getRefactoring().getUserFriendlyName());
  }

  public void writeIntoLog(RefactoringContext context) {
    assert !(context.isLocal());
    assert context.getRefactoring() instanceof ILoggableRefactoring;
    StructureModificationProcessor.addToLog(context.getStructureModification());
  }

  public void updateLoadedModels(final RefactoringContext context) {
    SetSequence.fromSet(loadedModelsForUpdate(context)).visitAll(new IVisitor<SModel>() {
      public void visit(SModel it) {
        updateModel(it.getSModel(), context);
      }
    });
  }

  @NotNull
  private List<SModel> getModelsToGenerate(final IRefactoring refactoring, final RefactoringContext context) {
    List<SModel> result = new ArrayList<SModel>();
    try {
      result = refactoring.getModelsToGenerate(context);
    } catch (Throwable t) {
      myLog.error("An error occured while trying to collect models to generate from refactoring " + refactoring.getUserFriendlyName() + ". No models will be generated", t);
    }

    return result;
  }

  private void updateModels(RefactoringContext context) {
    assert context.getRefactoring() instanceof ILoggableRefactoring;
    if (!(context.isLocal())) {
      updateLoadedModels(context);
    } else {
      UsagesList usages = context.getUsages();
      if (usages != null) {
        for (SModel anotherModel : usages.getAffectedModels()) {
          updateModel(anotherModel, context);
        }
      }
    }
  }

  private Set<SModel> loadedModelsForUpdate(RefactoringContext context) {
    final SModelRepository modelRepository = SModelRepository.getInstance();
    Map<SModelReference, Integer> dependencies = context.getStructureModification().getDependencies();
    Set<SModel> result = SetSequence.fromSet(new HashSet<SModel>());
    //  the dependencies should be added manually: they should be loaded after refactoring but have no ImportElement for themselves 
    SetSequence.fromSet(result).addSequence(SetSequence.fromSet(MapSequence.fromMap(dependencies).keySet()).select(new ISelector<SModelReference, SModel>() {
      public SModel select(SModelReference it) {
        return modelRepository.getModelDescriptor(it);
      }
    }));

    for (SModel descr : modelRepository.getModelDescriptors()) {
      if (!(SModelStereotype.isUserModel(descr)) || !(descr.isLoaded())) {
        continue;
      }
      //  we suppose that all models were saved before refactoring started => ImportElements are up to date 
      for (jetbrains.mps.smodel.SModel.ImportElement elem : ListSequence.fromList(SModelOperations.getAllImportElements(descr.getSModel()))) {
        if (MapSequence.fromMap(dependencies).containsKey(elem.getModelReference())) {
          SetSequence.fromSet(result).addElement(descr);
          break;
        }
      }
    }
    return result;
  }

  private void updateModel(SModel model, RefactoringContext context) {
    IRefactoring refactoring = context.getRefactoring();
    try {
      ((ILoggableRefactoring) refactoring).updateModel(model, context);
    } catch (Throwable t) {
      myLog.error("An exception was thrown by refactoring " + refactoring.getUserFriendlyName() + " while updating model " + SNodeOperations.getModelLongName(model) + ". Models could have been corrupted.", t);
    }
    if (!(context.isLocal())) {
      Map<SModelReference, Integer> dependencies = context.getStructureModification().getDependencies();
      for (SModelReference modelRef : dependencies.keySet()) {
        ((jetbrains.mps.smodel.SModel) model).updateImportedModelUsedVersion(modelRef, dependencies.get(modelRef) + 1);
      }
    }
    if (model instanceof EditableSModel) {
      ((EditableSModel) model).setChanged(true);
    }
  }

  private void generateModels(@NotNull final List<SModel> sourceModels, @NotNull final RefactoringContext context) {
    if (sourceModels.isEmpty()) {
      return;
    }
    final RefactoringNodeMembersAccessModifier modifier = new RefactoringNodeMembersAccessModifier();
    final List<SModel> descriptors = new ArrayList<SModel>();
    SModelRepository.getInstance().saveAll();
    //  save all before launching make 
    context.setUpMembersAccessModifier(modifier);
    modifier.addModelsToModify(sourceModels);
    SNode.setNodeMemberAccessModifier(modifier);
    for (SModel model : sourceModels) {
      if (!(SNodeOperations.isModelDisposed(model))) {
        descriptors.add(model.getModelDescriptor());
      }
    }

    final IOperationContext operationContext = new ProjectOperationContext(context.getSelectedProject());
    new Thread() {
      @Override
      public void run() {
        try {
          MakeSession sess = new MakeSession(operationContext);
          if (IMakeService.INSTANCE.get().openNewSession(sess)) {
            Future<IResult> result = IMakeService.INSTANCE.get().make(sess, new ModelsToResources(operationContext, descriptors).resources(false));
            result.get();
            //  wait for end of make to remove member access modifier 
          }
        } catch (InterruptedException e) {
        } catch (CancellationException ignore) {
        } catch (ExecutionException e) {
          e.printStackTrace();
        } finally {
          onGenerationFinished();
        }
      }
    }.start();
    //     GeneratorUIFacade.getInstance().generateModels(operationContext, descriptors, GeneratorUIFacade.getInstance().getDefaultGenerationHandler(), true, false); 
  }

  private void onGenerationFinished() {
    SNode.setNodeMemberAccessModifier(null);
  }
}
