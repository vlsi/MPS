package jetbrains.mps.workbench.findusages;

/*Generated by MPS */

import com.intellij.openapi.components.ApplicationComponent;
import com.intellij.psi.impl.cache.impl.id.IdTableBuilding;
import org.jetbrains.annotations.NotNull;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import com.intellij.psi.impl.cache.impl.id.FileTypeIdIndexer;
import java.util.Map;
import com.intellij.psi.impl.cache.impl.id.IdIndexEntry;
import com.intellij.util.indexing.FileContent;
import java.util.Collections;
import org.jetbrains.org.objectweb.asm.ClassReader;
import org.apache.log4j.Level;
import jetbrains.mps.baseLanguage.javastub.asm.ASMClass;
import jetbrains.mps.reloading.AbstractClassPathItem;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.stubs.javastub.classpath.ClassifierKind;

public class StubModelsIndexer implements ApplicationComponent {
  public StubModelsIndexer() {
  }
  @Override
  public void initComponent() {
    IdTableBuilding.registerIdIndexer(MPSPlatformFileTypeFactory.CLASS_FILE_TYPE, new StubModelsIndexer.MyFileTypeIdIndexer());
  }
  @Override
  public void disposeComponent() {
  }
  @NotNull
  @Override
  public String getComponentName() {
    return StubModelsIndexer.class.getSimpleName();
  }
  protected static Logger LOG = LogManager.getLogger(StubModelsIndexer.class);
  private static class MyFileTypeIdIndexer extends FileTypeIdIndexer {
    private MyFileTypeIdIndexer() {
    }
    @NotNull
    @Override
    public Map<IdIndexEntry, Integer> map(FileContent inputData) {
      byte[] bytes = inputData.getContent();
      if (bytes == null || bytes.length == 0) {
        return Collections.emptyMap();
      }

      ClassReader reader;
      try {
        reader = new ClassReader(bytes);
      } catch (Throwable t) {
        if (LOG.isEnabledFor(Level.WARN)) {
          LOG.warn(inputData.getFileName() + " can't be parsed by ASM and will not be indexed. This can be caused by corrupted classfile or a classfile with a version not yet parsable by bundled ASM library");
        }
        return Collections.emptyMap();
      }
      ASMClass ac = new ASMClass(reader, false);
      String fqName = ac.getFqName();
      if (AbstractClassPathItem.isAnonymous(NameUtil.namespaceFromLongName(fqName))) {
        return Collections.emptyMap();
      }

      ClassifierCacher updater = new ClassifierCacher();
      updater.updateClassifier(ClassifierKind.getClassifierKind(reader), ac);
      return updater.getResult();
    }
  }
}
