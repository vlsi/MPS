package jetbrains.mps.migration.test.tests;

/*Generated by MPS */

import junit.framework.TestCase;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.adapter.ids.MetaIdFactory;
import jetbrains.mps.lang.migration.runtime.base.MigrationScript;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Collections;
import junit.framework.Assert;
import jetbrains.mps.migration.component.util.MigrationComponent;
import jetbrains.mps.ide.migration.LanguageScriptApplied;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.project.structure.modules.ModuleDescriptor;
import java.util.Set;
import java.util.Map;
import jetbrains.mps.project.structure.modules.ModuleReference;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;
import org.jetbrains.mps.openapi.module.SDependency;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.module.SDependencyImpl;
import org.jetbrains.mps.openapi.module.SDependencyScope;
import jetbrains.mps.lang.migration.runtime.base.MigrationScriptBase;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.migration.runtime.base.DataCollector;

public class Migrations_Test extends TestCase {
  public void test_isAvailable() throws Exception {

    SLanguage langA = MetaAdapterFactory.getLanguage(MetaIdFactory.langId(239, 0), "langA");
    SLanguage langB = MetaAdapterFactory.getLanguage(MetaIdFactory.langId(239, 1), "langB");


    final MigrationScript scriptA0 = new Migrations_Test.MockMigrationScript(langA, 0);

    final MigrationScript scriptB0 = new Migrations_Test.MockMigrationScript(langB, 0) {
      public Iterable<MigrationScriptReference> executeAfter() {
        return Sequence.<MigrationScriptReference>singleton(scriptA0.getDescriptor());
      }
    };

    final MigrationScript scriptA1 = new Migrations_Test.MockMigrationScript(langA, 1) {
      public Iterable<MigrationScriptReference> requiresData() {
        return Sequence.<MigrationScriptReference>singleton(scriptB0.getDescriptor());
      }
    };

    SModule singleModule = new Migrations_Test.MockModule("singleModule", MapSequence.<SLanguage, Integer>fromMapAndKeysArray(new HashMap<SLanguage, Integer>(), langA, langB).withValues(0, 0), Sequence.fromIterable(Collections.<SModule>emptyList()));



    Assert.assertTrue(MigrationComponent.areDepsSatisfied(new LanguageScriptApplied(scriptA0, singleModule)));
    Assert.assertFalse(MigrationComponent.areDepsSatisfied(new LanguageScriptApplied(scriptB0, singleModule)));


    List<SModule> dep1 = ListSequence.fromList(new ArrayList<SModule>());
    List<SModule> dep2 = ListSequence.fromList(new ArrayList<SModule>());
    SModule cyclicModule1 = new Migrations_Test.MockModule("cyclicModule1", MapSequence.<SLanguage, Integer>fromMapAndKeysArray(new HashMap<SLanguage, Integer>(), langA, langB).withValues(1, 0), dep1);
    SModule cyclicModule2 = new Migrations_Test.MockModule("cyclicModule2", MapSequence.<SLanguage, Integer>fromMapAndKeysArray(new HashMap<SLanguage, Integer>(), langA, langB).withValues(1, 0), dep2);
    ListSequence.fromList(dep1).addElement(cyclicModule2);
    ListSequence.fromList(dep2).addElement(cyclicModule1);

    Assert.assertTrue(MigrationComponent.areDepsSatisfied(new LanguageScriptApplied(scriptB0, cyclicModule1)));
    Assert.assertTrue(MigrationComponent.areDepsSatisfied(new LanguageScriptApplied(scriptB0, cyclicModule2)));
    Assert.assertFalse(MigrationComponent.areDepsSatisfied(new LanguageScriptApplied(scriptA1, cyclicModule1)));
    Assert.assertFalse(MigrationComponent.areDepsSatisfied(new LanguageScriptApplied(scriptA1, cyclicModule2)));

  }
  /*package*/ static class MockModule extends AbstractModule {
    private ModuleDescriptor myModuleDescriptor;
    private Set<SLanguage> myUsedLanguages;
    private Iterable<SModule> myDependencies;
    public MockModule(String name, Map<SLanguage, Integer> usedLanguages, Iterable<SModule> dependencies) {
      setModuleReference(new ModuleReference(name, ModuleId.foreign(name)));
      myModuleDescriptor = new ModuleDescriptor();
      myUsedLanguages = MapSequence.fromMap(usedLanguages).keySet();
      myDependencies = dependencies;
      MapSequence.fromMap(usedLanguages).visitAll(new IVisitor<IMapping<SLanguage, Integer>>() {
        public void visit(IMapping<SLanguage, Integer> it) {
          myModuleDescriptor.getLanguageVersions().put(it.key(), it.value());
        }
      });
    }
    public ModuleDescriptor getModuleDescriptor() {
      return myModuleDescriptor;
    }
    public Set<SLanguage> getAllUsedLanguages() {
      return myUsedLanguages;
    }
    public Iterable<SDependency> getDeclaredDependencies() {
      return Sequence.fromIterable(myDependencies).select(new ISelector<SModule, SDependency>() {
        public SDependency select(final SModule it) {
          return (SDependency) new SDependencyImpl(it, SDependencyScope.DEFAULT, false);
        }
      });
    }
  }

  /*package*/ static class MockMigrationScript extends MigrationScriptBase {
    private MigrationScriptReference myReference;
    public MockMigrationScript(SLanguage lang, int version) {
      myReference = new MigrationScriptReference(lang, version);
    }
    public MigrationScriptReference getDescriptor() {
      return myReference;
    }
    public SNode execute(SModule moduleToMigrate, DataCollector dataCollector) {
      return null;
    }
    public String getCaption() {
      return "'script " + myReference.getFromVersion() + " in language " + myReference.getLanguage() + "'";
    }
  }
}
