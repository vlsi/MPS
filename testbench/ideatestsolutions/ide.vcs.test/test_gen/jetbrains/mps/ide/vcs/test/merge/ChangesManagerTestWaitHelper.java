package jetbrains.mps.ide.vcs.test.merge;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import jetbrains.mps.ide.platform.watching.ReloadManager;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vcs.FileStatus;
import com.intellij.openapi.vcs.FileStatusManager;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import com.intellij.openapi.vcs.FileStatusListener;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.openapi.vcs.changes.VcsDirtyScopeManager;
import com.intellij.openapi.vcs.changes.ChangeListManagerImpl;
import jetbrains.mps.vcs.changesmanager.CurrentDifferenceRegistry;
import jetbrains.mps.ide.platform.watching.ReloadListener;

public class ChangesManagerTestWaitHelper {
  private boolean myWaitCompleted = true;
  private final Object myWaitLock = new Object();

  private Project myProject;

  private Runnable myAfterReloadTask;
  private ChangesManagerTestWaitHelper.MyReloadListener myReloadListener = new ChangesManagerTestWaitHelper.MyReloadListener();

  public ChangesManagerTestWaitHelper(Project p) {
    myProject = p;
    ReloadManager.getInstance().addReloadListener(this.myReloadListener);
  }

  public void dispose() {
    ReloadManager.getInstance().removeReloadListener(myReloadListener);
  }

  public void waitForFileStatusChange(@NotNull final VirtualFile file, @NotNull final FileStatus expectedFileStatus) {
    final FileStatusManager fsm = FileStatusManager.getInstance(myProject);
    waitForSomething(new Runnable() {
      public void run() {
        final Wrappers._T<FileStatusListener> listener = new Wrappers._T<FileStatusListener>();
        final _FunctionTypes._void_P0_E0 stopIfNeeded = new _FunctionTypes._void_P0_E0() {
          public void invoke() {
            if (expectedFileStatus == fsm.getStatus(file)) {
              fsm.removeFileStatusListener(listener.value);
              // Wait until changes manager is notified about changed file status 
              try {
                Thread.sleep(100);
              } catch (InterruptedException e) {
                e.printStackTrace();
              }
              waitCompleted();
            }
          }
        };
        listener.value = new FileStatusListener() {
          @Override
          public void fileStatusesChanged() {
            stopIfNeeded.invoke();
          }
          @Override
          public void fileStatusChanged(@NotNull VirtualFile f) {
            stopIfNeeded.invoke();
          }
        };
        fsm.addFileStatusListener(listener.value);
        VcsDirtyScopeManager.getInstance(myProject).fileDirty(file);
        ChangeListManagerImpl.getInstanceImpl(myProject).scheduleUpdate();
        stopIfNeeded.invoke();
      }
    });
  }

  public void waitForChangesManager() {
    waitForSomething(new Runnable() {
      public void run() {
        CurrentDifferenceRegistry.getInstance(myProject).getCommandQueue().addTask(new Runnable() {
          public void run() {
            waitCompleted();
          }
        });
      }
    });
  }

  public void waitForReloadFinished() {
    waitForSomething(new Runnable() {
      public void run() {
        synchronized (ChangesManagerTestWaitHelper.this) {
          myAfterReloadTask = new Runnable() {
            public void run() {
              synchronized (ChangesManagerTestWaitHelper.this) {
                myAfterReloadTask = null;
              }
              waitCompleted();
            }
          };
        }
      }
    });
  }

  private void waitForSomething(Runnable waitScheduling) {
    synchronized (myWaitLock) {
      assert myWaitCompleted;
      myWaitCompleted = false;
      waitScheduling.run();
      while (!(myWaitCompleted)) {
        try {
          myWaitLock.wait();
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }

  private void waitCompleted() {
    synchronized (myWaitLock) {
      assert !(myWaitCompleted);
      myWaitCompleted = true;
      myWaitLock.notify();
    }
  }

  private class MyReloadListener implements ReloadListener {
    public MyReloadListener() {
    }
    @Override
    public void reloadStarted() {
    }
    @Override
    public void reloadFinished() {
      synchronized (this) {
        check_6valm7_a0a0a2w(myAfterReloadTask);
      }
    }
  }
  private static void check_6valm7_a0a0a2w(Runnable checkedDotOperand) {
    if (null != checkedDotOperand) {
      checkedDotOperand.run();
    }

  }
}
