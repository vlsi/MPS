package jetbrains.mps.testRead.SNodeReadTest;

/*Generated by MPS */

import jetbrains.mps.smodel.NodeReadAccessInEditorListener;
import java.util.Map;
import java.util.HashMap;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.util.Pair;

public class StatCountNodeReadAccessInEditorListener extends NodeReadAccessInEditorListener {
  private static Map<String, Integer> ourStatistics = new HashMap<String, Integer>();

  private SNode mySNode;
  private int myReadCounter = 0;
  private List<String> myCallerMethods = new ArrayList<String>();

  public StatCountNodeReadAccessInEditorListener(SNode sNode) {
    super();
    mySNode = sNode;
  }

  @Override
  public void nodeUnclassifiedReadAccess(SNode node) {
    super.nodeUnclassifiedReadAccess(node);
    updateStatistic(node);
  }

  private void updateStatistic(SNode node) {
    if (node == mySNode) {
      myReadCounter++;
      Throwable throwable = new Throwable();
      StackTraceElement[] traceElements = throwable.getStackTrace();
      int i = 0;
      for (; i < traceElements.length; i++) {
        if (traceElements[i].getClassName().equals("jetbrains.mps.smodel.SNode") && traceElements[i].getMethodName().startsWith("fire")) {
          i++;
          break;
        }
      }
      String methodName = traceElements[(i < traceElements.length ?
        i :
        0
      )].getMethodName();
      myCallerMethods.add(methodName);
      ourStatistics.put(methodName, (ourStatistics.containsKey(methodName) ?
        ourStatistics.get(methodName) + 1 :
        1
      ));
    }
  }

  public Pair<Integer, List<String>> getResults() {
    return new Pair(myReadCounter, ((ArrayList) myCallerMethods).clone());
  }

  public void resetResults() {
    myReadCounter = 0;
    myCallerMethods.clear();
  }

  public static Map<String, Integer> getStatistics() {
    return ourStatistics;
  }

  public static void resetStatistics() {
    ourStatistics.clear();
  }
}
