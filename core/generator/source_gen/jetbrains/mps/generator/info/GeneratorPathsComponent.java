package jetbrains.mps.generator.info;

/*Generated by MPS */

import jetbrains.mps.components.CoreComponent;
import java.util.List;
import jetbrains.mps.vfs.IFile;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.generator.impl.dependencies.GenerationDependenciesCache;
import jetbrains.mps.generator.impl.dependencies.GenerationDependencies;
import jetbrains.mps.generator.impl.dependencies.GenerationRootDependencies;
import jetbrains.mps.internal.collections.runtime.ITranslator2;

public class GeneratorPathsComponent implements CoreComponent {
  private static GeneratorPathsComponent INSTANCE;
  private static final List<IFile> EMPTY_LIST = Collections.emptyList();

  private List<ForeignPathsProvider> myForeignPathsProviders = ListSequence.fromList((ListSequence.fromList(new ArrayList<ForeignPathsProvider>()))).asSynchronized();

  public GeneratorPathsComponent() {
  }

  public void init() {
    if (INSTANCE != null) {
      throw new IllegalStateException("double initialization");
    }
    INSTANCE = this;
  }

  public void dispose() {
    INSTANCE = null;
  }

  public boolean isForeign(final IFile path) {
    return ListSequence.fromList(myForeignPathsProviders).any(new IWhereFilter<ForeignPathsProvider>() {
      public boolean accept(ForeignPathsProvider fpp) {
        return fpp.belongsToForeignPath(path) != null;
      }
    });
  }

  public List<IFile> getGeneratedChildren(final IFile path, IFile cachesDir) {
    GeneratorPathsComponent.MyGeneratedCacheInfo gci = lookupCacheInfo(cachesDir);
    return (gci != null ?
      Sequence.fromIterable(gci.listGenerated()).select(new ISelector<String, IFile>() {
        public IFile select(String it) {
          return path.getDescendant(it);
        }
      }).toListSequence() :
      EMPTY_LIST
    );
  }

  private GeneratorPathsComponent.MyGeneratedCacheInfo lookupCacheInfo(IFile cachesOutputDir) {
    IFile redir = GenerationDependenciesCache.getInstance().findCachesPathRedirect(cachesOutputDir);
    IFile cachesDir = (redir != null ?
      redir :
      cachesOutputDir
    );
    IFile generatedCache = cachesDir.getDescendant("generated");

    GenerationDependencies gd = GenerationDependenciesCache.getInstance().lookup(generatedCache);
    return (gd != null ?
      new GeneratorPathsComponent.MyGeneratedCacheInfo(gd) :
      null
    );
  }

  public void registerForeignPathsProvider(ForeignPathsProvider provider) {
    ListSequence.fromList(myForeignPathsProviders).addElement(provider);
  }

  public void unregisterForeignPathsProvider(ForeignPathsProvider provider) {
    ListSequence.fromList(myForeignPathsProviders).removeElement(provider);
  }

  public static GeneratorPathsComponent getInstance() {
    return INSTANCE;
  }

  public class MyGeneratedCacheInfo {
    private GenerationDependencies myDependencies;

    public MyGeneratedCacheInfo(GenerationDependencies gd) {
      this.myDependencies = gd;
    }

    public Iterable<String> listGenerated() {
      Iterable<GenerationRootDependencies> rootDependencies = myDependencies.getRootDependencies();
      return Sequence.fromIterable(rootDependencies).translate(new ITranslator2<GenerationRootDependencies, String>() {
        public Iterable<String> translate(GenerationRootDependencies it) {
          return it.getFiles();
        }
      });
    }
  }
}
