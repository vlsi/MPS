package jetbrains.mps.generator.traceInfo;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.traceInfo.DebugInfo;
import jetbrains.mps.traceInfo.UnitPositionInfo;
import jetbrains.mps.traceInfo.TraceablePositionInfo;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.annotations.NonNls;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.traceInfo.DebugInfoRoot;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.Map;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.util.annotation.ToRemove;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.traceInfo.PositionInfo;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.traceInfo.ScopePositionInfo;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelFqName;
import java.util.ArrayList;

public class TraceInfoUtil {
  public TraceInfoUtil() {
  }

  @Nullable
  public static String getUnitName(final String file, final int position, SModel descriptor) {
    DebugInfo info = TraceInfoCache.getInstance().get(descriptor);
    if (info == null) {
      return null;
    }
    UnitPositionInfo unitInfoForPosition = getUnitInfoForPosition(info, position, file);
    return check_4iwlxm_a3a1(unitInfoForPosition);
  }

  @Nullable
  public static String getUnitName(TraceablePositionInfo position, SModel descriptor) {
    DebugInfo info = TraceInfoCache.getInstance().get(descriptor);
    if (info == null) {
      return null;
    }
    UnitPositionInfo unitInfoForPosition = getUnitInfoForPosition(info, position);
    return check_4iwlxm_a3a2(unitInfoForPosition);
  }

  @Nullable
  public static SNode getUnitNode(@NonNls String className, final String file, final int position) {
    return findInTraceInfo(className, new _FunctionTypes._return_P2_E0<SNode, DebugInfo, SModel>() {
      public SNode invoke(DebugInfo info, SModel descriptor) {
        Tuples._2<UnitPositionInfo, DebugInfoRoot> unitInfo = TraceInfoUtil.getRootInfoAndUnitInfoForPosition(info, position, file);
        if (unitInfo == null) {
          return null;
        }
        return unitInfo._1().findNode(unitInfo._0());
      }
    });
  }

  private static UnitPositionInfo getUnitInfoForPosition(DebugInfo info, final int position, final String file) {
    List<UnitPositionInfo> resultList = info.getUnitInfoForPosition(file, position);
    if (ListSequence.fromList(resultList).isEmpty()) {
      return null;
    }
    return ListSequence.fromList(resultList).sort(new ISelector<UnitPositionInfo, Integer>() {
      public Integer select(UnitPositionInfo it) {
        return it.getStartLine();
      }
    }, false).first();
  }

  private static UnitPositionInfo getUnitInfoForPosition(DebugInfo info, @NotNull final TraceablePositionInfo position) {
    List<UnitPositionInfo> resultList = info.getUnitInfoForPosition(position.getFileName(), position.getStartLine());
    if (ListSequence.fromList(resultList).isEmpty()) {
      return null;
    }
    return ListSequence.fromList(resultList).where(new IWhereFilter<UnitPositionInfo>() {
      public boolean accept(UnitPositionInfo it) {
        return it.contains(position);
      }
    }).sort(new ISelector<UnitPositionInfo, Integer>() {
      public Integer select(UnitPositionInfo it) {
        return it.getStartLine();
      }
    }, false).first();
  }

  private static Tuples._2<UnitPositionInfo, DebugInfoRoot> getRootInfoAndUnitInfoForPosition(DebugInfo info, final int position, final String file) {
    Map<DebugInfoRoot, List<UnitPositionInfo>> resultList = info.getRootToInfoForPosition(file, position, new _FunctionTypes._return_P1_E0<Set<UnitPositionInfo>, DebugInfoRoot>() {
      public Set<UnitPositionInfo> invoke(DebugInfoRoot root) {
        return root.getUnitPositions();
      }
    });
    for (IMapping<DebugInfoRoot, List<UnitPositionInfo>> mapping : MapSequence.fromMap(resultList)) {
      return MultiTuple.<UnitPositionInfo,DebugInfoRoot>from(ListSequence.fromList(mapping.value()).sort(new ISelector<UnitPositionInfo, Integer>() {
        public Integer select(UnitPositionInfo it) {
          return it.getStartLine();
        }
      }, false).first(), mapping.key());
    }
    return null;
  }

  /**
   * Use TraceDown.unitNames(node)
   */
  @Deprecated
  @ToRemove(version = 3.0)
  @Nullable
  public static String getUnitName(SNode node) {
    return check_4iwlxm_a0a7(TraceDown.unitNames((SNode) node));
  }

  @Nullable
  public static SNode getNode(@NonNls String className, final String file, final int position) {
    return check_4iwlxm_a0a8(getAllTraceableNodes(className, file, position));
  }

  /**
   * Java-specific method for finding the most suitable node from position in java code.
   * 
   * @param unitName name of a java class
   * @param fileName name of a source file
   * @param lineNumber line number
   * @return node
   */
  @Nullable
  public static SNode getJavaNode(@NonNls String unitName, final String fileName, final int lineNumber) {
    return findInTraceInfo(unitName, new _FunctionTypes._return_P2_E0<SNode, DebugInfo, SModel>() {
      public SNode invoke(DebugInfo info, SModel modelDescriptor) {
        Map<DebugInfoRoot, List<TraceablePositionInfo>> resultList = info.getRootToInfoForPosition(fileName, lineNumber, new _FunctionTypes._return_P1_E0<Set<TraceablePositionInfo>, DebugInfoRoot>() {
          public Set<TraceablePositionInfo> invoke(DebugInfoRoot root) {
            return root.getPositions();
          }
        });
        if (resultList == null || MapSequence.fromMap(resultList).isEmpty()) {
          return null;
        }
        // todo impossible to read 
        for (DebugInfoRoot root : SetSequence.fromSet(MapSequence.fromMap(resultList).keySet())) {
          Iterable<TraceablePositionInfo> sorted = ListSequence.fromList(MapSequence.fromMap(resultList).get(root)).sort(new ISelector<TraceablePositionInfo, TraceablePositionInfo>() {
            public TraceablePositionInfo select(TraceablePositionInfo it) {
              return it;
            }
          }, true);
          final TraceablePositionInfo firstPositionInfo = Sequence.fromIterable(sorted).first();
          PositionInfo result = firstPositionInfo;
          // here we do some magic to fix the following bug: 
          // each node in base language owns a '\n' symbol in a previous line 
          // in the following code we will never get 'for' node quering line 1: 
          // 1.  for (...) { 
          // 2.    some statement 
          // 3.  } 
          // since 'some statement' takes lines 1-2 instead of just line 2 
          if (Sequence.fromIterable(sorted).count() > 1 && firstPositionInfo.getStartLine() == lineNumber && firstPositionInfo.getLineDistance() > 0) {
            result = ListSequence.fromList(Sequence.fromIterable(sorted).toListSequence()).getElement(1);
          }
          // here we have another example of how not to write code 
          // this is a hack fixing MPS-8644 
          // the problem is with the BlockStatement which sometimes generates to nothing, but is still present in .debug 
          // so in the code like this: 
          // 1. { 
          // 2. statement 
          // 3. } 
          // block statement occupy the same place as "statement" because this code generates into: 
          // 1. statement 
          // the solution is simple: 
          // among all node with same position we select the deepest 
          if (Sequence.fromIterable(sorted).count() > 1) {
            Iterable<TraceablePositionInfo> sameSpacePositions = Sequence.fromIterable(sorted).where(new IWhereFilter<TraceablePositionInfo>() {
              public boolean accept(TraceablePositionInfo it) {
                return firstPositionInfo.isOccupyTheSameSpace(it);
              }
            });
            if (Sequence.fromIterable(sameSpacePositions).count() > 1) {
              SNode currentNode = root.findNode(firstPositionInfo);
              boolean finished = false;
              while (!(finished)) {
                finished = true;
                for (TraceablePositionInfo otherPos : Sequence.fromIterable(sameSpacePositions)) {
                  SNode otherNode = root.findNode(otherPos);
                  if ((otherNode != null) && ListSequence.fromList(SNodeOperations.getAncestors(otherNode, null, false)).contains(currentNode)) {
                    currentNode = otherNode;
                    finished = false;
                    break;
                  }
                }
              }
              return currentNode;
            }
          }
          return root.findNode(result);
        }
        return null;
      }
    });
  }

  @Nullable
  public static SNode getVar(@NonNls String className, final String file, final int position, @NonNls final String varName) {
    return findInTraceInfo(className, new _FunctionTypes._return_P2_E0<SNode, DebugInfo, SModel>() {
      public SNode invoke(DebugInfo info, SModel descriptor) {
        Map<DebugInfoRoot, List<ScopePositionInfo>> resultList = info.getRootToInfoForPosition(file, position, new _FunctionTypes._return_P1_E0<Set<ScopePositionInfo>, DebugInfoRoot>() {
          public Set<ScopePositionInfo> invoke(DebugInfoRoot root) {
            return root.getScopePositions();
          }
        });
        if (MapSequence.fromMap(resultList).isEmpty()) {
          return null;
        }
        for (DebugInfoRoot root : SetSequence.fromSet(MapSequence.fromMap(resultList).keySet())) {
          Iterable<ScopePositionInfo> sorted = ListSequence.fromList(MapSequence.fromMap(resultList).get(root)).sort(new ISelector<ScopePositionInfo, ScopePositionInfo>() {
            public ScopePositionInfo select(ScopePositionInfo it) {
              return it;
            }
          }, true);
          for (ScopePositionInfo scopeInfo : sorted) {
            String varInfo = scopeInfo.getVarId(varName);
            if ((varInfo != null && varInfo.length() > 0)) {
              return root.findNode(varInfo);
            }
          }
        }
        return null;
      }
    });
  }

  @Nullable
  public static List<SNode> getAllTraceableNodes(@NotNull String className, final String file, final int position) {
    return TraceInfoUtil.getAllNodes(className, file, position, new _FunctionTypes._return_P1_E0<Set<TraceablePositionInfo>, DebugInfoRoot>() {
      public Set<TraceablePositionInfo> invoke(DebugInfoRoot key) {
        return key.getPositions();
      }
    });
  }

  @Nullable
  public static List<SNode> getAllScopeNodes(@NotNull String className, final String file, final int position) {
    return TraceInfoUtil.getAllNodes(className, file, position, new _FunctionTypes._return_P1_E0<Set<ScopePositionInfo>, DebugInfoRoot>() {
      public Set<ScopePositionInfo> invoke(DebugInfoRoot key) {
        return key.getScopePositions();
      }
    });
  }

  @Nullable
  public static List<SNode> getAllUnitNodes(@NotNull String className, final String file, final int position) {
    return TraceInfoUtil.getAllNodes(className, file, position, new _FunctionTypes._return_P1_E0<Set<UnitPositionInfo>, DebugInfoRoot>() {
      public Set<UnitPositionInfo> invoke(DebugInfoRoot key) {
        return key.getUnitPositions();
      }
    });
  }

  public static String modelFqNameFromUnitName(String unitName) {
    int lastDot = unitName.lastIndexOf(".");
    return ((lastDot == -1 ?
      "" :
      unitName.substring(0, lastDot)
    ));
  }

  @Nullable
  public static <T> T findInTraceInfo(@NonNls String unitName, _FunctionTypes._return_P2_E0<? extends T, ? super DebugInfo, ? super SModel> getter) {
    for (SModel descriptor : Sequence.fromIterable(getCandidateModels(unitName))) {
      final DebugInfo info = TraceInfoCache.getInstance().get(descriptor);
      if (info == null) {
        continue;
      }
      T result = getter.invoke(info, descriptor);
      if (result != null) {
        return result;
      }
    }
    return null;
  }

  public static Iterable<SModel> getCandidateModels(String unitName) {
    final String modelFqName = modelFqNameFromUnitName(unitName);
    return Sequence.fromIterable(Sequence.fromArray(SModelStereotype.values)).where(new IWhereFilter<String>() {
      public boolean accept(String it) {
        return !(SModelStereotype.isStubModelStereotype(it));
      }
    }).select(new ISelector<String, SModel>() {
      public SModel select(String stereotype) {
        return SModelRepository.getInstance().getModelDescriptor(new SModelFqName(modelFqName, stereotype));
      }
    }).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel it) {
        return it != null;
      }
    });
  }

  public static <T extends PositionInfo> List<SNode> getAllNodes(@NonNls String unitName, final String file, final int lineNumber, final _FunctionTypes._return_P1_E0<? extends Set<T>, ? super DebugInfoRoot> positionsGetter) {
    return findInTraceInfo(unitName, new _FunctionTypes._return_P2_E0<List<SNode>, DebugInfo, SModel>() {
      public List<SNode> invoke(DebugInfo debugInfo, SModel descriptor) {
        Map<DebugInfoRoot, List<T>> infoForPosition = debugInfo.getRootToInfoForPosition(file, lineNumber, new _FunctionTypes._return_P1_E0<Set<T>, DebugInfoRoot>() {
          public Set<T> invoke(DebugInfoRoot root) {
            return positionsGetter.invoke(root);
          }
        });
        List<SNode> nodes = ListSequence.fromList(new ArrayList<SNode>());
        if (MapSequence.fromMap(infoForPosition).isEmpty()) {
          return null;
        }
        for (IMapping<DebugInfoRoot, List<T>> rootToInfo : MapSequence.fromMap(infoForPosition)) {
          for (T info : ListSequence.fromList(rootToInfo.value())) {
            SNode node = rootToInfo.key().findNode(info);
            if (node != null) {
              nodes.add(node);
            }
          }
        }
        if (ListSequence.fromList(nodes).isEmpty()) {
          return null;
        }
        return nodes;
      }
    });
  }

  private static String check_4iwlxm_a3a1(UnitPositionInfo checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getUnitName();
    }
    return null;
  }

  private static String check_4iwlxm_a3a2(UnitPositionInfo checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getUnitName();
    }
    return null;
  }

  private static String check_4iwlxm_a0a7(Iterable<String> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return Sequence.fromIterable(checkedDotOperand).first();
    }
    return null;
  }

  private static SNode check_4iwlxm_a0a8(List<SNode> checkedDotOperand) {
    if (null != checkedDotOperand) {
      return ListSequence.fromList(checkedDotOperand).first();
    }
    return null;
  }
}
