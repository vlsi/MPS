package jetbrains.mps.build.ant;

/*Generated by MPS */

import org.apache.log4j.Logger;
import java.util.List;
import java.util.ArrayList;
import org.apache.tools.ant.ProjectComponent;
import jetbrains.mps.project.Project;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.reloading.ClassLoaderManager;
import jetbrains.mps.make.ModuleMaker;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.progress.EmptyProgressMonitor;
import org.apache.commons.lang.StringUtils;
import org.apache.tools.ant.BuildException;
import java.util.Set;
import java.io.File;
import jetbrains.mps.project.MPSExtentions;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.smodel.Generator;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.generator.GenerationFacade;
import java.util.Collection;
import jetbrains.mps.project.IModule;
import jetbrains.mps.project.io.DescriptorIOFacade;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.util.Computable;
import jetbrains.mps.smodel.ModuleFileTracker;
import java.util.Collections;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.smodel.BaseMPSModuleOwner;
import jetbrains.mps.library.ModulesMiner;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.persistence.def.DescriptorLoadResult;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.descriptor.source.RegularModelDataSource;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.build.ant.util.PathManager;
import java.io.StringWriter;
import java.io.PrintWriter;
import jetbrains.mps.logging.ILoggingHandler;
import jetbrains.mps.logging.LogEntry;
import java.util.LinkedHashSet;

public abstract class MpsWorker {
  private static Logger LOG = Logger.getLogger(MpsWorker.class);

  protected final List<String> myErrors = new ArrayList<String>();
  protected final List<String> myWarnings = new ArrayList<String>();
  protected final WhatToDo myWhatToDo;
  private final MpsWorker.AntLogger myLogger;
  protected Environment myEnvironment = new Environment();

  public MpsWorker(WhatToDo whatToDo) {
    this(whatToDo, new MpsWorker.LogLogger());
  }

  public MpsWorker(WhatToDo whatToDo, ProjectComponent component) {
    this(whatToDo, new MpsWorker.ProjectComponentLogger(component));
  }

  public MpsWorker(WhatToDo whatToDo, ProjectComponent component, Environment environment) {
    this(whatToDo, new MpsWorker.ProjectComponentLogger(component), environment);
  }

  public MpsWorker(WhatToDo whatToDo, MpsWorker.AntLogger logger) {
    this(whatToDo, logger, new Environment());
  }

  public MpsWorker(WhatToDo whatToDo, MpsWorker.AntLogger logger, Environment environment) {
    myWhatToDo = whatToDo;
    myLogger = logger;
    this.myEnvironment = environment;
    // <node> 
    myEnvironment.init(whatToDo.getMacro(), whatToDo.isLoadBootstrapLibraries(), whatToDo.getLibraries(), whatToDo.getLogLevel(), new MpsWorker.MyMessageHandlerAppender());
  }

  public void setEnvironment(Environment environment) {
    this.myEnvironment = environment;
  }

  public void workFromMain() {
    try {
      work();
      System.exit(0);
    } catch (Throwable e) {
      log(e);
      System.exit(1);
    }
  }

  public void work() {
    setupEnvironment();
    final Project project = createDummyProject();
    MpsWorker.ObjectsToProcess go = new MpsWorker.ObjectsToProcess();
    collectModelsToGenerate(go);
    if (go.hasAnythingToGenerate()) {
      reload();
      executeTask(project, go);
    } else {
      error("Could not find anything to generate.");
    }
    disposeProjects(go.getProjects());
    dispose();
    showStatistic();
  }

  protected Project createDummyProject() {
    return myEnvironment.createDummyProject();
  }

  protected void dispose() {
    myEnvironment.dispose();
  }

  protected void disposeProject(final Project p) {
    p.dispose();
  }

  protected void setupEnvironment() {
    myEnvironment.setup();
    make();
  }

  protected void make() {
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        ClassLoaderManager.getInstance().updateClassPath();
        ModuleMaker maker = new ModuleMaker();
        maker.make(MPSModuleRepository.getInstance().getAllModules(), new EmptyProgressMonitor());
      }
    });
    reload();
  }

  protected void reload() {
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
      }
    });
  }

  protected abstract void executeTask(Project project, MpsWorker.ObjectsToProcess go);

  protected abstract void showStatistic();

  protected StringBuffer formatErrorsReport(String taskName) {
    StringBuffer sb = new StringBuffer();
    sb.append(StringUtils.repeat("*", 100));
    sb.append("\n");
    sb.append(myErrors.size());
    sb.append(" errors during " + taskName + ":\n");
    for (String error : myErrors) {
      sb.append(error);
      sb.append("\n");
    }
    sb.append(StringUtils.repeat("*", 100));
    return sb;
  }

  protected void failBuild(String name) {
    if (!(myErrors.isEmpty()) && myWhatToDo.getFailOnError()) {
      throw new BuildException(this.formatErrorsReport(name).toString());
    }
  }

  protected void disposeProjects(Set<Project> projects) {
    ModelAccess.instance().flushEventQueue();
    for (final Project project : projects) {
      disposeProject(project);
    }
  }

  public void collectModelsToGenerate(MpsWorker.ObjectsToProcess go) {
    collectFromProjects(go.getProjects());
    collectFromModuleFiles(go.getModules());
    collectFromModelFiles(go.getModels());
  }

  private void collectFromProjects(Set<Project> projects) {
    for (File projectFile : myWhatToDo.getMPSProjectFiles().keySet()) {
      if (projectFile.getAbsolutePath().endsWith(MPSExtentions.DOT_MPS_PROJECT)) {
        Project project = myEnvironment.loadProject(projectFile);
        info("Loaded project " + project);
        projects.add(project);
      }
    }
  }

  protected void extractModels(Set<SModelDescriptor> modelDescriptors, Project project) {
    List<SModelDescriptor> models = project.getProjectModels();
    for (Language language : project.getProjectModules(Language.class)) {
      models.addAll(language.getOwnModelDescriptors());
      for (Generator gen : language.getGenerators()) {
        models.addAll(gen.getOwnModelDescriptors());
      }
    }
    for (SModelDescriptor modelDescriptor : models) {
      if (includeModel(modelDescriptor)) {
        modelDescriptors.add(modelDescriptor);
      }
    }
  }

  private boolean includeModel(SModelDescriptor modelDescriptor) {
    return SModelStereotype.isUserModel(modelDescriptor) && GenerationFacade.canGenerate(modelDescriptor);
  }

  protected void extractModels(Collection<SModelDescriptor> modelsList, IModule m) {
    List<SModelDescriptor> ownedModels = m.getOwnModelDescriptors();
    for (SModelDescriptor d : ownedModels) {
      if (includeModel(d)) {
        modelsList.add(d);
      }
    }
  }

  protected void collectFromModuleFiles(Set<IModule> modules) {
    for (File moduleFile : myWhatToDo.getModules()) {
      processModuleFile(moduleFile, modules);
    }
  }

  protected void processModuleFile(final File moduleFile, final Set<IModule> modules) {
    if (DescriptorIOFacade.getInstance().fromFileType(FileSystem.getInstance().getFileByPath(moduleFile.getPath())) == null) {
      return;
    }
    List<IModule> tmpmodules;
    IModule moduleByFile = ModelAccess.instance().runReadAction(new Computable<IModule>() {
      public IModule compute() {
        return ModuleFileTracker.getInstance().getModuleByFile(FileSystem.getInstance().getFileByPath(moduleFile.getAbsolutePath()));
      }
    });
    if (moduleByFile != null) {
      tmpmodules = Collections.singletonList(moduleByFile);
    } else {
      tmpmodules = ModelAccess.instance().runWriteAction(new Computable<List<IModule>>() {
        public List<IModule> compute() {
          IFile file = FileSystem.getInstance().getFileByPath(moduleFile.getPath());
          BaseMPSModuleOwner owner = new BaseMPSModuleOwner();
          List<IModule> modules = new ArrayList<IModule>();
          for (ModulesMiner.ModuleHandle moduleHandle : ModulesMiner.getInstance().collectModules(file, false)) {
            IModule module = ModuleRepositoryFacade.createModule(moduleHandle, owner);
            if (module != null) {
              modules.add(module);
            }
          }
          return modules;
        }
      });
    }
    modules.addAll(tmpmodules);
    for (IModule module : tmpmodules) {
      info("Loaded module " + module);
      if (module.isPackaged()) {
        continue;
      }
      if (module instanceof Language) {
        Language language = (Language) module;
        for (Generator gen : language.getGenerators()) {
          modules.add(gen);
        }
      }
    }
  }

  protected void collectFromModelFiles(Set<SModelDescriptor> modelDescriptor) {
    for (File f : myWhatToDo.getModels()) {
      if (f.getPath().endsWith(MPSExtentions.DOT_MODEL)) {
        processModelFile(modelDescriptor, f);
      }
    }
  }

  private void processModelFile(Set<SModelDescriptor> modelDescriptors, File f) {
    final IFile ifile = FileSystem.getInstance().getFileByPath(f.getAbsolutePath());
    //  try to find if model is loaded 
    SModelDescriptor model = SModelRepository.getInstance().findModel(ifile);
    if (model != null) {
      modelDescriptors.add(model);
      info("Found model " + model);
      return;
    }
    //  if model is not loaded, read it 
    try {
      DescriptorLoadResult dr = ModelPersistence.loadDescriptor(ifile);
      SModelReference modelReference;
      if (dr.getUID() != null) {
        modelReference = SModelReference.fromString(dr.getUID());
      } else {
        modelReference = SModelReference.fromPath(ifile.getPath());
      }
      info("Read model " + modelReference);
      DescriptorLoadResult d = new RegularModelDataSource(null, ifile).loadDescriptor(null, modelReference.getSModelFqName());
      SModelDescriptor existingDescr = SModelRepository.getInstance().getModelDescriptor(d.getHeader().getModelReference());
      if (existingDescr == null) {
        error("Module for " + ifile.getPath() + " was not found. Use \"library\" tag to load required modules.");
      } else {
        modelDescriptors.add(existingDescr);
      }
    } catch (ModelReadException e) {
      log(e);
    }
  }

  private void log(String text, int level) {
    if (level <= myWhatToDo.getLogLevel()) {
      myLogger.log(text, level);
    }
  }

  public void info(String text) {
    log(text, org.apache.tools.ant.Project.MSG_INFO);
  }

  public void verbose(String text) {
    log(text, org.apache.tools.ant.Project.MSG_VERBOSE);
  }

  public void warning(String text) {
    log(text, org.apache.tools.ant.Project.MSG_WARN);
    myWarnings.add(text);
  }

  public void debug(String text) {
    log(text, org.apache.tools.ant.Project.MSG_DEBUG);
  }

  public void error(String text) {
    log(text, org.apache.tools.ant.Project.MSG_ERR);
    myErrors.add(text);
  }

  public void log(Throwable e) {
    StringBuffer sb = MpsWorker.extractStackTrace(e);
    error(sb.toString());
  }

  public void log(String text, Throwable e) {
    StringBuffer sb = MpsWorker.extractStackTrace(e);
    error(text + "\n" + sb.toString());
  }

  protected void configureMPS(boolean loadIdeaPlugins) {
    String mpsInternal = System.getProperty("mps.internal");
    System.setProperty("idea.is.internal", (mpsInternal == null ?
      "false" :
      mpsInternal
    ));
    System.setProperty("idea.no.jre.check", "true");
    if (!(loadIdeaPlugins)) {
      System.setProperty("idea.load.plugins", "false");
    }
    System.setProperty("idea.platform.prefix", "Idea");
    StringBuffer pluginPath = new StringBuffer();
    File pluginDir = new File(PathManager.getPreinstalledPluginsPath());
    for (File pluginFolder : pluginDir.listFiles()) {
      if (pluginPath.length() > 0) {
        pluginPath.append(File.pathSeparator);
      }
      pluginPath.append(pluginFolder.getPath());
    }
    System.setProperty("plugin.path", pluginPath.toString());
  }

  public static StringBuffer extractStackTrace(Throwable e) {
    StringWriter writer = new StringWriter();
    e.printStackTrace(new PrintWriter(writer));
    return writer.getBuffer();
  }

  public class MyMessageHandlerAppender implements ILoggingHandler {
    public MyMessageHandlerAppender() {
    }

    public void info(LogEntry e) {
      MpsWorker.this.verbose(e.getMessage());
    }

    public void warning(LogEntry e) {
      MpsWorker.this.warning(e.getMessage());
    }

    public void debug(LogEntry e) {
      MpsWorker.this.debug(e.getMessage());
    }

    public void error(LogEntry e) {
      if (e.getThrowable() != null) {
        MpsWorker.this.log(e.getThrowable());
      } else {
        MpsWorker.this.error(e.getMessage());
      }
    }

    public void fatal(LogEntry e) {
      if (e.getThrowable() != null) {
        MpsWorker.this.log(e.getThrowable());
      } else {
        MpsWorker.this.error(e.getMessage());
      }
    }
  }

  protected static interface AntLogger {
    public void log(String text, int level);
  }

  private static class ProjectComponentLogger implements MpsWorker.AntLogger {
    private final ProjectComponent myProjectComponent;

    public ProjectComponentLogger(ProjectComponent projectComponent) {
      myProjectComponent = projectComponent;
    }

    public void log(String text, int level) {
      myProjectComponent.log(text, level);
    }
  }

  public static class SystemOutLogger implements MpsWorker.AntLogger {
    public SystemOutLogger() {
    }

    public void log(String text, int level) {
      if (level == org.apache.tools.ant.Project.MSG_ERR) {
        System.err.println(text);
      } else {
        System.out.println(text);
      }
    }
  }

  public static class LogLogger implements MpsWorker.AntLogger {
    public LogLogger() {
    }

    public void log(String text, int level) {
      switch (level) {
        case org.apache.tools.ant.Project.MSG_ERR:
          MpsWorker.LOG.error(text);
          break;
        case org.apache.tools.ant.Project.MSG_WARN:
          MpsWorker.LOG.warn(text);
          break;
        case org.apache.tools.ant.Project.MSG_INFO:
          MpsWorker.LOG.info(text);
          break;
        case org.apache.tools.ant.Project.MSG_DEBUG:
        case org.apache.tools.ant.Project.MSG_VERBOSE:
          MpsWorker.LOG.debug(text);
          break;
        default:
          MpsWorker.LOG.fatal("[unknown level " + level + "] " + text);
          break;
      }
    }
  }

  protected class ObjectsToProcess {
    private final Set<Project> myProjects = new LinkedHashSet<Project>();
    private final Set<IModule> myModules = new LinkedHashSet<IModule>();
    private final Set<SModelDescriptor> myModels = new LinkedHashSet<SModelDescriptor>();

    public ObjectsToProcess() {
    }

    public ObjectsToProcess(Set<? extends Project> mpsProjects, Set<IModule> modules, Set<SModelDescriptor> models) {
      myProjects.addAll(mpsProjects);
      myModules.addAll(modules);
      myModels.addAll(models);
    }

    public Set<Project> getProjects() {
      return myProjects;
    }

    public Set<IModule> getModules() {
      return myModules;
    }

    public Set<SModelDescriptor> getModels() {
      return myModels;
    }

    public boolean hasAnythingToGenerate() {
      return !(myModels.isEmpty()) || !(myProjects.isEmpty()) || !(myModules.isEmpty());
    }
  }
}
