package jetbrains.mps.checkers;

/*Generated by MPS */

import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import jetbrains.mps.errors.IErrorReporter;
import java.util.HashMap;
import java.util.HashSet;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.QuickFixProvider;
import jetbrains.mps.errors.SimpleErrorReporter;
import jetbrains.mps.errors.MessageStatus;
import org.jetbrains.mps.openapi.module.SRepository;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import jetbrains.mps.smodel.event.SModelChildEvent;
import jetbrains.mps.smodel.event.SModelReferenceEvent;
import jetbrains.mps.smodel.event.SModelPropertyEvent;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.AbstractNodesReadListener;
import jetbrains.mps.smodel.NodeReadEventsCaster;
import jetbrains.mps.smodel.SModelAdapter;
import jetbrains.mps.smodel.SModelRepositoryAdapter;
import org.jetbrains.mps.openapi.model.SModelReference;

public class LanguageErrorsComponent {
  private Map<SNode, Set<IErrorReporter>> myNodesToErrors = new HashMap<SNode, Set<IErrorReporter>>();
  private Map<SNode, Set<SNode>> myDependenciesToNodes = new HashMap<SNode, Set<SNode>>();
  private Map<SNode, Set<SNode>> myNodesToDependecies = new HashMap<SNode, Set<SNode>>();
  private Set<SNode> myInvalidNodes = new HashSet<SNode>();
  private Set<SNode> myDependenciesToInvalidate = new HashSet<SNode>();
  private LanguageErrorsComponent.MyModelListener myModelListener = new LanguageErrorsComponent.MyModelListener();
  private LanguageErrorsComponent.MyModelRepositoryListener myModelRepositoryListener = new LanguageErrorsComponent.MyModelRepositoryListener();
  private Set<SModel> myListenedModels = new HashSet<SModel>();
  private boolean myCheckedRoot = false;
  private SNode myCurrentNode = null;
  private SModel myModel;
  private boolean myUpdateInspector = false;

  private static <T> void addToMappedSet(Map<SNode, Set<T>> map, SNode key, T value) {
    Set<T> setOfNodes = MapSequence.fromMap(map).get(key);
    if (setOfNodes == null) {
      setOfNodes = new HashSet<T>(1);
      MapSequence.fromMap(map).put(key, setOfNodes);
    }
    SetSequence.fromSet(setOfNodes).addElement(value);
  }

  public LanguageErrorsComponent(SModel model) {
    myModel = model;
    SModelRepository.getInstance().addModelRepositoryListener(myModelRepositoryListener);
  }
  public void dispose() {
    this.removeModelListener();
    SModelRepository.getInstance().removeModelRepositoryListener(myModelRepositoryListener);
  }
  private void removeModelListener() {
    for (SModel modelDescriptor : myListenedModels) {
      ((SModelInternal) modelDescriptor).removeModelListener(myModelListener);
    }
    SetSequence.fromSet(myListenedModels).clear();
  }
  public void addDependency(SNode dependency) {
    if (myCurrentNode == null) {
      return;
    }
    if (dependency == null) {
      return;
    }
    addDependencyMapping(myCurrentNode, dependency);
    addModelListener(SNodeOperations.getModel(dependency));
  }

  private void addDependencyMapping(@NotNull SNode node, @NotNull SNode dependency) {
    addToMappedSet(myNodesToDependecies, node, dependency);
    addToMappedSet(myDependenciesToNodes, dependency, node);
  }
  private Set<SNode> removeDependencyFromMapping(@NotNull SNode dependency) {
    // removing dependency node from any mappings together with all checked nodes 
    // denending on this dependency node 

    // 1. Removing dependency -> nodes mapping for specified dependency 
    Set<SNode> nodes = MapSequence.fromMap(myDependenciesToNodes).removeKey(dependency);

    if (nodes != null) {
      // 2. Removing node -> dependencies mappings for nodes from step 1. 
      for (SNode node : nodes) {
        Set<SNode> nodeDependencies = MapSequence.fromMap(myNodesToDependecies).removeKey(node);
        if (nodeDependencies != null) {
          // 3. Cleaning "backward" dependency -> nodes maping for removed nodes 
          for (SNode nodeDependency : nodeDependencies) {
            Set<SNode> errors = MapSequence.fromMap(myDependenciesToNodes).get(nodeDependency);
            if (errors != null) {
              SetSequence.fromSet(errors).removeElement(node);
              if (SetSequence.fromSet(errors).isEmpty()) {
                MapSequence.fromMap(myDependenciesToNodes).removeKey(nodeDependency);
              }
            }
          }
        }

      }
    }

    // returning a set of checked nodes removed from mapping 
    return nodes;
  }
  private Set<SNode> getDependenciesToInvalidate(SModel model) {
    Set<SNode> result = new HashSet<SNode>();
    for (SNode dependency : MapSequence.fromMap(myDependenciesToNodes).keySet()) {
      if (!(SNodeUtil.isAccessible(dependency, MPSModuleRepository.getInstance())) || SNodeOperations.getModel(dependency) == model) {
        SetSequence.fromSet(result).addElement(dependency);
      }
    }
    return result;
  }

  private void addModelListener(SModel modelDescriptor) {
    if (modelDescriptor == null) {
      return;
    }
    if (!(SetSequence.fromSet(myListenedModels).contains(modelDescriptor))) {
      ((SModelInternal) modelDescriptor).addModelListener(myModelListener);
      SetSequence.fromSet(myListenedModels).addElement(modelDescriptor);
    }
  }

  public void addError(SNode node, String errorString, SNode ruleNode) {
    for (SNode anc : ListSequence.fromList(SNodeOperations.getAncestors(node, null, false))) {
      addDependency(anc);
    }
    addError(node, errorString, ruleNode, new NodeMessageTarget());
  }
  public void addError(SNode errorNode, String errorString, SNode ruleNode, MessageTarget messageTarget) {
    addError(errorNode, errorString, ruleNode, messageTarget, null);
  }
  public void addError(SNode errorNode, String errorString, SNode ruleNode, MessageTarget messageTarget, QuickFixProvider intentionProvider) {
    if (!(ErrorReportUtil.shouldReportError(errorNode))) {
      return;
    }
    String id = (ruleNode == null ? null : ruleNode.getNodeId().toString());
    String modelId = (ruleNode == null ? null : check_29uvfh_a0a0c0cb(ruleNode.getModel()) + "");
    SimpleErrorReporter reporter = new SimpleErrorReporter(errorNode, errorString, modelId, id, MessageStatus.ERROR, messageTarget);
    if (intentionProvider != null) {
      reporter.setIntentionProvider(intentionProvider);
    }

    addToMappedSet(myNodesToErrors, errorNode, reporter);
  }

  private void invalidate() {
    if (SetSequence.fromSet(myDependenciesToInvalidate).isEmpty()) {
      return;
    }
    for (SNode toInvalidate : myDependenciesToInvalidate) {
      invalidateDependency(toInvalidate);
    }
    SetSequence.fromSet(myDependenciesToInvalidate).clear();
  }
  private void invalidateDependency(SNode dependency) {
    Set<SNode> checkedNodes = removeDependencyFromMapping(dependency);
    if (checkedNodes != null) {
      for (SNode node : checkedNodes) {
        // avoid searching for _already_removed_ node later in check() 
        if (SNodeOperations.getModel(node) != null) {
          SetSequence.fromSet(myInvalidNodes).addElement(node);
        }
        MapSequence.fromMap(myNodesToErrors).removeKey(node);
      }
    }
  }
  public boolean check(SNode root, Set<AbstractConstraintsChecker> checkers, SRepository repository) {
    // returns whether state has been changed after check 
    if (root == null) {
      return false;
    }
    invalidate();
    if (myCheckedRoot && SetSequence.fromSet(myInvalidNodes).isEmpty()) {
      return false;
    }
    Queue<SNode> nodesToCheck = QueueSequence.fromQueue(new LinkedList<SNode>());
    QueueSequence.fromQueue(nodesToCheck).addLastElement(root);
    while (QueueSequence.fromQueue(nodesToCheck).isNotEmpty()) {
      SNode node = QueueSequence.fromQueue(nodesToCheck).removeFirstElement();
      if (!(myCheckedRoot) || SetSequence.fromSet(myInvalidNodes).contains(node)) {
        try {
          myCurrentNode = node;
          addDependency(node);
          for (AbstractConstraintsChecker checker : checkers) {
            checker.checkNode(node, this, repository);
          }
        } finally {
          myCurrentNode = null;
        }
      }
      QueueSequence.fromQueue(nodesToCheck).addSequence(ListSequence.fromList(SNodeOperations.getChildren(node)));
    }
    // traversed the whole root, should have been removed all invalid nodes 
    SetSequence.fromSet(myInvalidNodes).clear();
    myCheckedRoot = true;
    myUpdateInspector = true;
    return true;
  }
  public boolean checkInspector() {
    if (myUpdateInspector) {
      myUpdateInspector = false;
      return true;
    }
    return false;
  }
  public Set<IErrorReporter> getErrors() {
    Set<IErrorReporter> result = new HashSet<IErrorReporter>(1);
    for (Set<IErrorReporter> errorReporters : MapSequence.fromMap(myNodesToErrors).values()) {
      SetSequence.fromSet(result).addSequence(SetSequence.fromSet(errorReporters));
    }
    return result;
  }
  public void clear() {
    myCheckedRoot = false;
    SetSequence.fromSet(myDependenciesToInvalidate).clear();
    SetSequence.fromSet(myInvalidNodes).clear();
    myCurrentNode = null;
    MapSequence.fromMap(myDependenciesToNodes).clear();
    MapSequence.fromMap(myNodesToDependecies).clear();
    MapSequence.fromMap(myNodesToErrors).clear();
    removeModelListener();
  }

  private void processEvent(SModelChildEvent event) {
    SetSequence.fromSet(myDependenciesToInvalidate).addElement(event.getParent());
    if (event.isRemoved()) {
      SetSequence.fromSet(myDependenciesToInvalidate).addElement(event.getChild());
    }
    if (event.isAdded()) {
      SetSequence.fromSet(myInvalidNodes).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(((SNode) event.getChild()), null, false, new String[]{})));
      SetSequence.fromSet(myInvalidNodes).addElement(event.getChild());
    }
  }
  private void processEvent(SModelReferenceEvent event) {
    SetSequence.fromSet(myDependenciesToInvalidate).addElement(event.getReference().getSourceNode());
  }
  private void processEvent(SModelPropertyEvent event) {
    SetSequence.fromSet(myDependenciesToInvalidate).addElement(event.getNode());
  }
  public <Result> Result runCheckingAction(_FunctionTypes._return_P0_E0<? extends Result> action) {
    final Set<SNode> accessedNodes = new HashSet<SNode>();
    final Object[] result = new Object[1];
    try {
      AbstractNodesReadListener listener = new AbstractNodesReadListener() {
        @Override
        public void nodeUnclassifiedReadAccess(SNode node) {
          SetSequence.fromSet(accessedNodes).addElement(node);
        }
        @Override
        public void nodePropertyReadAccess(SNode node, String name, String value) {
          SetSequence.fromSet(accessedNodes).addElement(node);
        }
        @Override
        public void nodeReferentReadAccess(SNode node, String role, SNode referent) {
          SetSequence.fromSet(accessedNodes).addElement(node);
          SetSequence.fromSet(accessedNodes).addElement(referent);
        }
        @Override
        public void nodeChildReadAccess(SNode node, String role, SNode child) {
          SetSequence.fromSet(accessedNodes).addElement(node);
          SetSequence.fromSet(accessedNodes).addElement(child);
        }
      };
      NodeReadEventsCaster.setNodesReadListener(listener);
      result[0] = action.invoke();
    } finally {
      NodeReadEventsCaster.removeNodesReadListener();
    }
    for (SNode accessedNode : accessedNodes) {
      addDependency(accessedNode);
    }
    return (Result) result[0];
  }
  public class MyModelListener extends SModelAdapter {
    @Override
    public void beforeModelDisposed(SModel model) {
      if (myModel == model) {
        return;
      }
      for (SNode dependencyToInvalidate : getDependenciesToInvalidate(model)) {
        invalidateDependency(dependencyToInvalidate);
      }
    }
    @Override
    public void referenceRemoved(SModelReferenceEvent event) {
      processEvent(event);
    }
    @Override
    public void referenceAdded(SModelReferenceEvent event) {
      processEvent(event);
    }
    @Override
    public void childRemoved(SModelChildEvent event) {
      processEvent(event);
    }
    @Override
    public void childAdded(SModelChildEvent event) {
      processEvent(event);
    }
    @Override
    public void propertyChanged(SModelPropertyEvent event) {
      processEvent(event);
    }
  }
  public class MyModelRepositoryListener extends SModelRepositoryAdapter {
    @Override
    public void modelRemoved(SModel descriptor) {
      SetSequence.fromSet(myListenedModels).removeElement(descriptor);
    }
  }
  private static SModelReference check_29uvfh_a0a0c0cb(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getReference();
    }
    return null;
  }
}
