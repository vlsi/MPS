package jetbrains.mps.checkers;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.resolve.ReferenceResolverUtils;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.smodel.constraints.ModelConstraints;
import jetbrains.mps.scope.ErrorScope;
import jetbrains.mps.errors.messageTargets.ReferenceMessageTarget;
import jetbrains.mps.smodel.runtime.ReferenceScopeProvider;
import jetbrains.mps.smodel.constraints.ModelConstraintsManager;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.errors.QuickFixProvider;
import jetbrains.mps.errors.QuickFix_Runtime;
import jetbrains.mps.resolve.ResolverComponent;
import org.jetbrains.mps.openapi.model.SModel;

public class RefScopeChecker extends AbstractConstraintsChecker {
  public RefScopeChecker() {
  }
  @Override
  public void checkNode(SNode node, LanguageErrorsComponent component, SRepository repository) {
    if (node == null || SNodeOperations.getModel(node) == null) {
      return;
    }
    SModule module = check_bt3k2y_a0b0b(SNodeOperations.getModel(node));
    if (module == null) {
      return;
    }
    SNode concept = SNodeOperations.getConceptDeclaration(node);
    boolean executeImmediately = ReferenceResolverUtils.canExecuteImmediately(SNodeOperations.getModel(node), repository);
    for (SReference ref : SNodeOperations.getReferences(node)) {
      SNode target = SLinkOperations.getTargetNode(ref);
      SNode ld = SLinkOperations.findLinkDeclaration(ref);
      // don't check unresolved and broken references, they should already have an error message 
      if ((target == null) || ld == null) {
        continue;
      }
      // do we need all these additional dependencies? mb. it's better to use .runcheckingAction() instead? 
      component.addDependency(target);
      component.addDependency(ld);
      component.addDependency(node);
      component.addDependency(SNodeOperations.getParent(node));
      for (SNode c : SNodeOperations.getChildren(node)) {
        component.addDependency(c);
      }
      Scope refScope = ModelConstraints.getScope(ref);
      if (refScope instanceof ErrorScope) {
        component.addError(node, ((ErrorScope) refScope).getMessage(), null, new ReferenceMessageTarget(SLinkOperations.getRole(ref)));
      } else if (!(refScope.contains(target))) {
        String name = target.getName();
        ReferenceScopeProvider scopeProvider = ModelConstraintsManager.getNodeReferentSearchScopeProvider(concept, ref.getRole());
        SNode ruleNode = null;
        if (scopeProvider != null) {
          ruleNode = (scopeProvider.getSearchScopeValidatorNode() != null ? ((SNodePointer) scopeProvider.getSearchScopeValidatorNode()).resolve(MPSModuleRepository.getInstance()) : null);
        }
        component.addError(node, "reference" + ((name == null ? "" : " " + name)) + " (" + SLinkOperations.getRole(ref) + ") is out of search scope", ruleNode, new ReferenceMessageTarget(SLinkOperations.getRole(ref)), createResolveReferenceQuickfix(ref, repository, executeImmediately));
      }
    }
  }
  protected QuickFixProvider createResolveReferenceQuickfix(SReference reference, SRepository repository, boolean executeImmediately) {
    return new RefScopeChecker.ResolveReferenceQuickFix(reference, repository, executeImmediately);
  }
  protected class ResolveReferenceQuickFix implements QuickFixProvider {
    private boolean myIsError;
    protected SReference myReference;
    protected SRepository myRepository;
    private boolean myExecuteImmediately;
    public ResolveReferenceQuickFix(SReference reference, SRepository repository, boolean executeImmediately) {
      myReference = reference;
      myRepository = repository;
      myExecuteImmediately = executeImmediately;
    }
    @Override
    public QuickFix_Runtime getQuickFix() {
      return new QuickFix_Runtime() {
        @Override
        public void execute(SNode node) {
          ResolverComponent.getInstance().resolve(myReference, myRepository);
        }
        @Override
        public String getDescription(SNode node) {
          return "Resolve \"" + myReference.getRole() + "\" reference";
        }
      };
    }
    @Override
    public boolean isExecutedImmediately() {
      return myExecuteImmediately;
    }
    @Override
    public void setIsError(boolean isError) {
      myIsError = isError;
    }
    @Override
    public boolean isError() {
      return myIsError;
    }
  }
  private static SModule check_bt3k2y_a0b0b(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }
}
