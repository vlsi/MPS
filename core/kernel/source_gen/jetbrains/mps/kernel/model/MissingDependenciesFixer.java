package jetbrains.mps.kernel.model;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.project.AbstractModule;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.smodel.SModelOperations;

/**
 * Utility to update imports of a module to respect imports of a given model.
 * 
 * Methods of this class shall be invoked within command/model write lock
 */
public class MissingDependenciesFixer {
  private final SModel myModel;

  public MissingDependenciesFixer(@NotNull SModel modelDescriptor) {
    myModel = modelDescriptor;
  }

  /**
   * For each import of the model with module not in model's module dependencies, add a new one.
   */
  public void fixModuleDependencies() {
    SRepository repository = myModel.getRepository();
    assert repository != null;
    AbstractModule module = (AbstractModule) myModel.getModule();
    assert module != null;

    List<SModelReference> existingImports = getExistingImports();
    fixImports(module, existingImports);
  }

  private void fixImports(@NotNull AbstractModule module, List<SModelReference> importsToAdd) {
    SRepository repository = module.getRepository();
    SearchScope moduleScope = module.getScope();
    for (SModelReference modelImport : importsToAdd) {
      if (moduleScope.resolve(modelImport) != null) {
        continue;
      }
      SModel sm = modelImport.resolve(repository);
      if (sm == null) {
        continue;
      }
      SModule anotherModule = sm.getModule();
      if (anotherModule == null || anotherModule == module) {
        continue;
      }
      module.addDependency(anotherModule.getModuleReference(), false);
    }
  }

  private List<SModelReference> getExistingImports() {
    return SModelOperations.getImportedModelUIDs(myModel);
  }
}
