package jetbrains.mps.util;

/*Generated by MPS */

import jetbrains.mps.smodel.SModelStereotype;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;
import org.jetbrains.mps.util.Condition;
import java.util.Map;
import java.util.LinkedHashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConceptRepository;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.model.SReference;
import java.util.LinkedList;
import java.util.Iterator;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.smodel.Language;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.smodel.SModelRepository;
import java.util.Queue;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.smodel.SModelInternal;
import jetbrains.mps.smodel.FastNodeFinder;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.extapi.model.GeneratableSModel;

public class SNodeOperations {
  public SNodeOperations() {
  }

  public static boolean isAncestor(SNode ancestor, SNode node) {
    if (ancestor == node) {
      return true;
    }
    SNode parentOfChild = node.getParent();
    if (parentOfChild == null) {
      return false;
    }
    return isAncestor(ancestor, parentOfChild);
  }

  public static List<SNode> getChildren(SNode node, boolean includeAttributes) {
    List<SNode> res = new ArrayList<SNode>();
    for (SNode child : node.getChildren()) {
      if (child != null && AttributeOperations.isAttribute(child)) {
        res.add(((SNode) child));
      }
    }
    return res;
  }

  public static Iterable<SNode> getDescendants(SNode node, Condition<SNode> cond, boolean includeFirst) {
    return new SNodeOperations.DescendantsIterable(node, cond, includeFirst);
  }

  public static SNode findParent(SNode node, Condition<SNode> condition) {
    SNode parent = ((SNode) node.getParent());
    while (parent != null) {
      if (condition.met(parent)) {
        return ((SNode) parent);
      }
      parent = ((SNode) parent.getParent());
    }
    return null;
  }

  public static Map<String, String> getProperties(SNode node) {
    Map<String, String> result = new LinkedHashMap<String, String>();
    for (String name : node.getPropertyNames()) {
      result.put(name, node.getProperty(name));
    }
    return result;
  }

  public static List<SNode> getDescendants(SNode node, Condition<SNode> condition) {
    List<SNode> res = ListSequence.fromList(new ArrayList<SNode>());
    collectDescendants(node, res, condition);
    return res;
  }

  private static void collectDescendants(SNode node, List<SNode> list, Condition<SNode> condition) {
    for (SNode child : Sequence.fromIterable(node.getChildren())) {
      if (condition == null || condition == Condition.TRUE_CONDITION || (child instanceof SNode && condition.met(((SNode) child)))) {
        ListSequence.fromList(list).addElement(((SNode) child));
      }
      collectDescendants(child, list, condition);
    }
  }

  /**
   * todo rewrite the code using this
   */
  public static SAbstractConcept getConcept(String name) {
    return SConceptRepository.getInstance().getInstanceConcept(name);
  }

  /**
   * todo rewrite the code using this
   */
  public static Set<String> getChildRoles(SNode n) {
    Set<String> res = SetSequence.fromSet(new HashSet<String>());
    for (SNode child : Sequence.fromIterable(n.getChildren())) {
      SetSequence.fromSet(res).addElement(child.getRoleInParent());
    }
    return res;
  }

  /**
   * todo rewrite the code using this
   */
  public static List<SReference> getReferences(SNode n) {
    List<SReference> res = new LinkedList<SReference>();
    for (SReference ref : Sequence.fromIterable(n.getReferences())) {
      res.add(((jetbrains.mps.smodel.SReference) ref));
    }
    return res;
  }

  /**
   * todo rewrite the code using this
   */
  public static List<SNode> getChildren(SNode n) {
    List<SNode> res = ListSequence.fromList(new ArrayList<SNode>());
    for (SNode child : Sequence.fromIterable(n.getChildren())) {
      ListSequence.fromList(res).addElement((SNode) child);
    }
    return res;
  }

  /**
   * todo rewrite the code using this
   */
  public static Set<String> getReferenceRoles(SNode n) {
    Set<String> res = SetSequence.fromSet(new HashSet<String>());
    for (SReference ref : Sequence.fromIterable(n.getReferences())) {
      SetSequence.fromSet(res).addElement(ref.getRole());
    }
    return res;
  }

  /**
   * todo rewrite the code using this
   */
  public static boolean isRoot(SNode n) {
    return n.getModel() != null && n.getParent() == null;
  }

  /**
   * todo rewrite the code via snode methods
   */
  public static void insertChild(SNode parent, String role, SNode child, SNode anchor, boolean before) {
    if (before) {
      parent.insertChildBefore(role, child, anchor);
    } else {
      insertChild(parent, role, child, anchor);
    }
  }

  /**
   * todo rewrite the code via snode methods
   */
  public static void insertChild(SNode parent, String role, SNode child, SNode anchor) {
    if (anchor != null) {
      parent.insertChildBefore(role, child, ((jetbrains.mps.smodel.SNode) anchor).treeNext());
      return;
    }
    Iterator<? extends SNode> it = parent.getChildren().iterator();
    parent.insertChildBefore(role, child, (it.hasNext() ? it.next() : null));
  }

  /**
   * todo KILL IT! should not be used since nodes are not passed between read actions
   * todo after killing it, correct migration script to return false instead
   */
  @Deprecated
  public static boolean isDisposed(SNode node) {
    return ((jetbrains.mps.smodel.SNode) node).isDisposed();
  }

  /**
   * this is an utility method common to all nodes but needed only for our debug purposes, so we don't put it into SNode
   */
  public static String getDebugText(SNode node) {
    return SNodeUtil.getDebugText(((SNode) node));
  }

  public static Set<String> getChildRoles(SNode n, boolean includeAttributeRoles) {
    final Set<String> augend = new HashSet<String>();
    for (SNode child : n.getChildren()) {
      if (includeAttributeRoles || !((AttributeOperations.isAttribute(child)))) {
        augend.add(child.getRoleInParent());
      }
    }
    return augend;
  }

  public static SNode getChild(SNode node, String role) {
    Iterable<? extends SNode> children = node.getChildren(role);
    if (!(children.iterator().hasNext())) {
      return null;
    }
    return children.iterator().next();
  }

  /**
   * This will be replaced by getting resolve info from a reference in a context containing it
   */
  public static String getResolveInfo(SNode n) {
    String resolveInfo = jetbrains.mps.smodel.SNodeUtil.getResolveInfo(((SNode) n));
    if (resolveInfo != null) {
      return resolveInfo;
    }
    return n.getProperty(jetbrains.mps.smodel.SNodeUtil.property_INamedConcept_name);
  }

  public static void copyProperties(SNode from, final SNode to) {
    for (String name : from.getPropertyNames()) {
      to.setProperty(name, from.getProperty(name));
    }
  }

  public static Language getLanguage(SNode node) {
    final SLanguage language = node.getConcept().getLanguage();
    if (language == null) {
      return null;
    }
    return ModuleRepositoryFacade.getInstance().getModule(language.getQualifiedName(), Language.class);
  }

  public static void copyUserObjects(SNode from, final SNode to) {
    for (Object key : from.getUserObjectKeys()) {
      to.putUserObject(key, from.getUserObject(key));
    }
  }

  public static SModel getModelFromNodeReference(SNodeReference ref) {
    SModelReference mr = ref.getModelReference();
    if (mr == null) {
      return null;
    }
    return SModelRepository.getInstance().getModelDescriptor(mr);
  }

  private static class DescendantsIterable implements Iterator<SNode>, Iterable<SNode> {
    private Condition<SNode> condition;
    private Queue<SNode> queue = new LinkedList<SNode>();
    private SNode current;

    /*package*/ DescendantsIterable(SNode original, @Nullable Condition<SNode> condition, boolean includeFirst) {
      this.condition = condition;
      current = original;
      if (current != null) {
        for (SNode child : current.getChildren()) {
          queue.offer(child);
        }
      }
      if (!(includeFirst)) {
        current = nextInternal();
      }
      while (current != null && condition != null && !(current instanceof SNode && condition.met(((SNode) current)))) {
        current = nextInternal();
      }
    }

    @Override
    public boolean hasNext() {
      return current != null;
    }

    @Override
    public SNode next() {
      SNode result = current;
      do {
        current = nextInternal();
      } while (current != null && condition != null && !(current instanceof SNode && condition.met(((SNode) current))));
      return ((SNode) result);
    }

    @Override
    public void remove() {
      throw new UnsupportedOperationException();
    }

    private SNode nextInternal() {
      SNode next = queue.poll();
      if (next == null) {
        return null;
      }
      for (SNode child : next.getChildren()) {
        queue.offer(child);
      }
      return next;
    }

    @Override
    public Iterator<SNode> iterator() {
      return this;
    }
  }

  public static SNode getTargetNodeSilently(SReference ref) {
    try {
      jetbrains.mps.smodel.SReference.disableLogging();
      return ref.getTargetNode();
    } finally {
      jetbrains.mps.smodel.SReference.enableLogging();
    }
  }

  public static String getModelStereotype(SModel model) {
    return SModelStereotype.getStereotype(model);
  }

  public static String getModelLongName(SModel model) {
    return NameUtil.getModelLongName(model);
  }

  public static List<SModuleReference> getUsedLanguages(SModel model) {
    Iterable<SModuleReference> languages = ((SModelInternal) model).importedLanguages();
    return Sequence.fromIterable(languages).toListSequence();
  }

  public static boolean isModelDisposed(SModel model) {
    return ((SModelInternal) model).isDisposed();
  }

  public static FastNodeFinder getModelFastFinder(SModel model) {
    return ((SModelInternal) model).getFastNodeFinder();
  }

  public static int nodesCount(SModel model) {
    return IterableUtil.asCollection(SNodeUtil.getDescendants(model)).size();
  }

  public static boolean isRegistered(SModel model) {
    return !(model.getRepository() == null || ((SModelBase) model).isDisposed());
  }

  public static boolean isGeneratable(SModel model) {
    // I wonder why this method doesn't reside in SModelOperations 
    return model instanceof GeneratableSModel && ((GeneratableSModel) model).isGeneratable();
  }
}
