package jetbrains.mps.refactoring;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.IMapping;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.smodel.SModelOperations;
import jetbrains.mps.smodel.descriptor.RefactorableSModelDescriptor;
import jetbrains.mps.smodel.SModelRepository;
import java.util.Map;
import java.util.Set;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.logging.Logger;

public class StructureModificationProcessor {
  private ModelLinkMap myModelMap;
  private SModel myModel;

  public StructureModificationProcessor(ModelLinkMap modelMap, SModel model) {
    myModelMap = modelMap;
    myModel = model;
  }

  private boolean playRefactoring(@NotNull StructureModification data) {
    boolean result = data.apply(myModelMap);
    for (IMapping<SModelReference, Integer> entry : MapSequence.fromMap(data.getDependencies())) {
      // also adds implicit import if necessary 
      ((ABCDE) myModel).updateImportedModelUsedVersion(entry.key(), entry.value() + 1);
    }
    return result;
  }

  public boolean updateModelOnLoad() {
    // should be called in loading state 
    if (!(refactoringsPlaybackEnabled() && SModelStereotype.isUserModel(myModel))) {
      return false;
    }
    boolean played = false;
    for (StructureModification data : ListSequence.fromList(sortModifications(getApplicableModifications()))) {
      played |= playRefactoring(data);
    }
    return played;
  }

  public List<StructureModification> getApplicableModifications() {
    List<StructureModification> result = ListSequence.fromList(new ArrayList<StructureModification>());
    for (SModel.ImportElement importElement : ListSequence.fromList(SModelOperations.getAllImportElements(myModel))) {
      RefactorableSModelDescriptor usedModel = as_etzqsh_a0a0a1a5(SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference()), RefactorableSModelDescriptor.class);
      if (usedModel == null) {
        continue;
      }
      for (StructureModification data : ListSequence.fromList(usedModel.getStructureModificationLog().getHistory())) {
        if (importElement.getUsedVersion() <= MapSequence.fromMap(data.getDependencies()).get(usedModel.getSModelReference())) {
          ListSequence.fromList(result).addElement(data);
        }
      }
    }
    return result;
  }

  private List<StructureModification> sortModifications(List<StructureModification> list) {
    // create graph 
    final Map<Integer, Set<Integer>> graph = MapSequence.fromMap(new HashMap<Integer, Set<Integer>>());
lCompare:
    for (final Wrappers._int i = new Wrappers._int(0); i.value < ListSequence.fromList(list).count(); i.value++) {
      Set<Integer> before = SetSequence.fromSet(new HashSet<Integer>());
      List<Integer> after = ListSequence.fromList(new ArrayList<Integer>());
      for (int j : MapSequence.fromMap(graph).keySet()) {
        StructureModification.Relation rel = StructureModification.compare(ListSequence.fromList(list).getElement(j), ListSequence.fromList(list).getElement(i.value));
        if (rel == StructureModification.Relation.EQUAL) {
          continue lCompare;
        }
        if (rel == StructureModification.Relation.BEFORE) {
          SetSequence.fromSet(before).addElement(j);
        }
        if (rel == StructureModification.Relation.AFTER) {
          ListSequence.fromList(after).addElement(j);
        }
      }
      MapSequence.fromMap(graph).put(i.value, before);
      ListSequence.fromList(after).visitAll(new IVisitor<Integer>() {
        public void visit(Integer j) {
          SetSequence.fromSet(MapSequence.fromMap(graph).get(j)).addElement(i.value);
        }
      });
    }
    // sort 
    List<StructureModification> result = ListSequence.fromList(new ArrayList<StructureModification>());
lfind:
    while (MapSequence.fromMap(graph).isNotEmpty()) {
      for (final int k : SetSequence.fromSet(MapSequence.fromMap(graph).keySet())) {
        if (SetSequence.fromSet(MapSequence.fromMap(graph).get(k)).isEmpty()) {
          ListSequence.fromList(result).addElement(ListSequence.fromList(list).getElement(k));
          MapSequence.fromMap(graph).removeKey(k);
          Sequence.fromIterable(MapSequence.fromMap(graph).values()).visitAll(new IVisitor<Set<Integer>>() {
            public void visit(Set<Integer> it) {
              SetSequence.fromSet(it).removeElement(k);
            }
          });
          continue lfind;
        }
      }
      // we have not found next data: loop detected! 
      LOG.error("Loop found in applicable refactorings for " + myModel + "");
      break;
    }
    return result;
  }

  public static void addToLog(@NotNull final StructureModification data) {
    // add all missed dependencies with current version 
    for (StructureModification.Entry entry : ListSequence.fromList(data.getData())) {
      Sequence.fromIterable(entry.getDependentModels()).visitAll(new IVisitor<SModelReference>() {
        public void visit(SModelReference it) {
          data.addDependencyModel(it);
        }
      });
    }
    // add modification to all dependent models 
    for (IMapping<SModelReference, Integer> dependency : MapSequence.fromMap(data.getDependencies())) {
      RefactorableSModelDescriptor model = (RefactorableSModelDescriptor) SModelRepository.getInstance().getModelDescriptor(dependency.key());
      StructureModificationLog modificationLog = model.getStructureModificationLog();
      modificationLog.addStructureModification(data);
      model.setVersion(dependency.value() + 1);
      model.saveStructureModificationLog(modificationLog);
      model.setChanged(true);
    }
  }

  public static boolean hasRefactoringsToPlay(@NotNull SModel model) {
    if (refactoringsPlaybackEnabled() && SModelStereotype.isUserModel(model)) {
      for (SModel.ImportElement importElement : ListSequence.fromList(SModelOperations.getAllImportElements(model))) {
        RefactorableSModelDescriptor usedModel = as_etzqsh_a0a0a0a0a8(SModelRepository.getInstance().getModelDescriptor(importElement.getModelReference()), RefactorableSModelDescriptor.class);
        if (usedModel != null && importElement.getUsedVersion() < usedModel.getVersion()) {
          return true;
        }
      }
    }
    return false;
  }

  public static boolean refactoringsPlaybackEnabled() {
    return !("false".equals(System.getProperty("mps.playRefactorings")));
  }

  private static Logger LOG = Logger.getLogger(StructureModificationProcessor.class);

  private static <T> T as_etzqsh_a0a0a1a5(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }

  private static <T> T as_etzqsh_a0a0a0a0a8(Object o, Class<T> type) {
    return (type.isInstance(o) ?
      (T) o :
      null
    );
  }
}
