package jetbrains.mps.lang.smodel.generator.smodelAdapter;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.RuntimeFlags;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.CopyUtil;
import jetbrains.mps.smodel.SModelUtil_new;
import java.util.ArrayList;
import jetbrains.mps.util.IterableUtil;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import org.jetbrains.mps.util.InstanceOfCondition;
import org.jetbrains.mps.util.Condition;
import org.jetbrains.mps.util.DescendantsTreeIterator;
import org.jetbrains.mps.openapi.language.SConceptRepository;
import jetbrains.mps.kernel.model.SModelUtil;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.smodel.search.ISearchScope;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.scope.Scope;
import jetbrains.mps.smodel.constraints.ModelConstraints;
import jetbrains.mps.scope.ErrorScope;
import jetbrains.mps.scope.ScopeAdapter;
import jetbrains.mps.util.NameUtil;
import jetbrains.mps.smodel.search.SModelSearchUtil;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.util.ConditionalIterable;

public class SNodeOperations {
  private static final Logger LOG = Logger.wrap(LogManager.getLogger(SNodeOperations.class));
  private static boolean ourCastExceptionsEnabled = RuntimeFlags.isExceptionOnBadCast();
  /**
   * Empty list of nodes that can't be modified helps to detect otherwise hard to catch
   * errors when role of non-existent parent is modified.
   * For example, if there's NodeA.nodeB [0..1] and NodeB.nodeC[0..*], the query
   * <code>myA.nodeB.nodeC.add(new NodeC)</code> used to pass silently even if nodeB was not set.
   */
  /*package*/ static final List<SNode> EMPTY_LIST = new EmptyList<SNode>("Attempt to add node to nonexistent parent or role. Node: %s");
  public SNodeOperations() {
  }
  public static SNode copyNode(SNode node) {
    if (node == null) {
      return null;
    }
    return CopyUtil.copy(node);
  }
  public static SNode getContainingRoot(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getContainingRoot();
  }
  @Deprecated
  public static SNode getParent(SNode node, String parentConceptFqName, boolean inclusion, boolean root) {
    // use node.getParent() 
    return SNodeOperations.getAncestor(node, parentConceptFqName, inclusion, root);
  }
  public static SNode getParent(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getParent();
  }
  public static SNode getAncestor(SNode node, String ancestorConceptFqName, boolean inclusion, boolean root) {
    return SNodeOperations.getAncestor(node, ancestorConceptFqName, inclusion, root, false);
  }
  public static SNode getAncestor(SNode node, String ancestorConceptFqName, boolean inclusion, boolean root, boolean sameMetaLevel) {
    if (node == null) {
      return null;
    }
    int metaLevel = (sameMetaLevel ? SModelUtil_new.getMetaLevel(node) : 0);

    // look up for certain concept 
    if (root) {
      SNode rootParent = node.getContainingRoot();
      if (rootParent.getModel() != null && SNodeOperations.nullSafeInstanceOf(rootParent, ancestorConceptFqName)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(rootParent) == metaLevel) {
          return rootParent;
        }
      }
      return null;
    }

    // look-up parent of required type 
    SNode outputNode;
    if (inclusion) {
      outputNode = node;
    } else {
      outputNode = node.getParent();
    }
    if (outputNode == null) {
      return null;
    }
    if (SNodeOperations.nullSafeInstanceOf(outputNode, ancestorConceptFqName)) {
      if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
        return outputNode;
      }
    }
    while ((outputNode = outputNode.getParent()) != null) {
      if (SNodeOperations.nullSafeInstanceOf(outputNode, ancestorConceptFqName)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
          break;
        }
      }
    }
    return outputNode;
  }
  private static boolean nullSafeInstanceOf(SNode node, String conceptFQName) {
    if (conceptFQName == null) {
      return true;
    }
    return SNodeOperations._isInstanceOf(node, conceptFQName);
  }
  public static SNode getAncestorWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion, boolean root) {
    return SNodeOperations.getAncestorWhereConceptInList(node, ancestorConceptFqNames, inclusion, root, false);
  }
  public static SNode getAncestorWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion, boolean root, boolean sameMetaLevel) {
    if (node == null) {
      return null;
    }
    int metaLevel = (sameMetaLevel ? SModelUtil_new.getMetaLevel(node) : 0);
    if (ancestorConceptFqNames.length == 0) {
      return null;
    }
    if (root) {
      SNode rootParent = node.getContainingRoot();
      if (SNodeOperations._isInstanceOf(rootParent, ancestorConceptFqNames)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(rootParent) == metaLevel) {
          return rootParent;
        }
      }
      return null;
    }

    // look-up parent of required type 
    SNode outputNode;
    if (inclusion) {
      outputNode = node;
    } else {
      outputNode = node.getParent();
    }
    if (outputNode == null) {
      return null;
    }
    if (SNodeOperations._isInstanceOf(outputNode, ancestorConceptFqNames)) {
      if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
        return outputNode;
      }
    }
    while ((outputNode = outputNode.getParent()) != null) {
      if (SNodeOperations._isInstanceOf(outputNode, ancestorConceptFqNames)) {
        if (!(sameMetaLevel) || SModelUtil_new.getMetaLevel(outputNode) == metaLevel) {
          return outputNode;
        }
      }
    }
    return null;
  }
  public static List<SNode> getAncestors(SNode node, String ancestorConceptFqName, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    List<SNode> result = new ArrayList<SNode>();
    if (!(inclusion)) {
      node = node.getParent();
    }
    while (node != null) {
      if (ancestorConceptFqName == null || SNodeOperations._isInstanceOf(node, ancestorConceptFqName)) {
        result.add(node);
      }
      node = node.getParent();
    }
    return result;
  }
  public static List<SNode> getAncestorsWhereConceptInList(SNode node, String[] ancestorConceptFqNames, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    List<SNode> result = new ArrayList<SNode>();
    if (!(inclusion)) {
      node = node.getParent();
    }
    while (node != null) {
      if (SNodeOperations._isInstanceOf(node, ancestorConceptFqNames)) {
        result.add(node);
      }
      node = node.getParent();
    }
    return result;
  }
  public static List<SNode> getDescendants(SNode node, final String childConceptFqName, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    return IterableUtil.asList(SNodeUtil.getDescendants(node, (childConceptFqName == null ? null : new InstanceOfCondition(childConceptFqName)), inclusion));
  }
  public static List<SNode> getDescendants(SNode node, final String childConceptFqName, boolean inclusion, final String[] stopConceptFqNames) {
    if (node == null) {
      return EMPTY_LIST;
    }
    if (stopConceptFqNames == null || stopConceptFqNames.length == 0) {
      return getDescendants(node, childConceptFqName, inclusion);
    }
    if (childConceptFqName == null) {
      // It's odd to ignore stop condition when there's no designated childConcept, 
      // but this is how it used to be from revision ad249caf since 2009. 
      return getDescendants(node, null, inclusion);
    }
    return descendantsAsList(node, inclusion, new InstanceOfCondition(childConceptFqName), new InstanceOfCondition(stopConceptFqNames));
  }
  public static List<SNode> getDescendantsWhereConceptInList(SNode node, final String[] descendantConceptFqNames, boolean inclusion) {
    if (node == null || descendantConceptFqNames.length == 0) {
      return EMPTY_LIST;
    }
    return IterableUtil.asList(SNodeUtil.getDescendants(node, new InstanceOfCondition(descendantConceptFqNames), inclusion));
  }
  public static List<SNode> getDescendantsWhereConceptInList(SNode node, final String[] descendantConceptFqNames, boolean inclusion, final String[] stopConceptFqNames) {
    if (node == null || descendantConceptFqNames.length == 0) {
      return EMPTY_LIST;
    }
    if (stopConceptFqNames == null || stopConceptFqNames.length == 0) {
      return getDescendantsWhereConceptInList(node, descendantConceptFqNames, inclusion);
    }
    return descendantsAsList(node, inclusion, new InstanceOfCondition(descendantConceptFqNames), new InstanceOfCondition(stopConceptFqNames));
  }
  private static List<SNode> descendantsAsList(SNode node, boolean inclusion, Condition<SNode> condition, Condition<SNode> stopCondition) {
    // can't use TreeFilterIterator as nodes that match both condition and stopCondition are proper return values 
    ArrayList<SNode> rv = new ArrayList<SNode>();
    final DescendantsTreeIterator it = new DescendantsTreeIterator(node);
    if (!(inclusion) && it.hasNext()) {
      it.next();
    }
    while (it.hasNext()) {
      SNode next = it.next();
      if (condition.met(next)) {
        rv.add(next);
      }
      if (stopCondition.met(next)) {
        it.skipChildren();
      }
    }
    return rv;
  }
  private static boolean _isInstanceOf(SNode node, String[] conceptFqNames) {
    for (String conceptFqName : conceptFqNames) {
      if (conceptFqName == null) {
        continue;
      }
      if (SNodeOperations._isInstanceOf(node, conceptFqName)) {
        return true;
      }
    }
    return false;
  }
  private static boolean _isInstanceOf(SNode node, String conceptFqName) {
    if (node == null) {
      return false;
    }
    return SNodeUtil.isInstanceOf(node, SConceptRepository.getInstance().getInstanceConcept(conceptFqName));
  }
  public static List<SNode> getChildren(SNode node) {
    if (node == null) {
      return EMPTY_LIST;
    }
    return jetbrains.mps.util.SNodeOperations.getChildren(node);
  }
  public static List<SNode> getChildren(SNode node, SNode linkDeclaration) {
    if (node == null || linkDeclaration == null) {
      return EMPTY_LIST;
    }
    linkDeclaration = SModelUtil.getGenuineLinkDeclaration(linkDeclaration);
    return SLinkOperations.getTargets(node, SPropertyOperations.getString(linkDeclaration, "role"), true);
  }
  public static SModel getModel(SNode node) {
    if (node == null) {
      return null;
    }
    return node.getModel();
  }
  public static boolean isInstanceOf(SNode node, String conceptFQName) {
    if (node == null) {
      return false;
    }
    if (conceptFQName == null) {
      return false;
    }
    return SNodeOperations._isInstanceOf(node, conceptFQName);
  }
  public static SNode getNextSibling(SNode node) {
    SNode p = node.getParent();
    if (p == null) {
      return null;
    }
    SNode current = node;
    String currentRole = node.getRoleInParent();
    assert currentRole != null : "role must be not null";
    while (current.getNextSibling() != null) {
      current = current.getNextSibling();
      if (current.getRoleInParent().equals(currentRole)) {
        return current;
      }
    }
    return null;
  }
  public static SNode getPrevSibling(SNode node) {
    SNode p = node.getParent();
    if (p == null) {
      return null;
    }
    SNode current = node;
    String currentRole = node.getRoleInParent();
    assert currentRole != null : "role must be not null";
    SNode fc = p.getFirstChild();
    while (current != fc) {
      current = current.getPrevSibling();
      if (current.getRoleInParent().equals(currentRole)) {
        return current;
      }
    }
    return null;
  }
  public static List<SNode> getPrevSiblings(SNode node, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    List<SNode> result = new ArrayList<SNode>();
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    String role = node.getRoleInParent();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        if (inclusion) {
          result.add(child);
        }
        break;
      }
      result.add(child);
    }
    return result;
  }
  public static List<SNode> getNextSiblings(SNode node, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    List<SNode> result = new ArrayList<SNode>();
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    if (inclusion) {
      result.add(node);
    }
    boolean childFound = false;
    String role = node.getRoleInParent();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        childFound = true;
      } else
      if (childFound) {
        result.add(child);
      }
    }
    return result;
  }
  public static List<SNode> getAllSiblings(SNode node, boolean inclusion) {
    if (node == null) {
      return EMPTY_LIST;
    }
    List<SNode> result = new ArrayList<SNode>();
    SNode parent = node.getParent();
    if (parent == null) {
      return result;
    }
    String role = node.getRoleInParent();
    assert role != null;
    for (SNode child : parent.getChildren(role)) {
      if (child == node) {
        if (inclusion) {
          result.add(child);
        }
      } else {
        result.add(child);
      }
    }
    return result;
  }
  public static SNode insertNewNextSiblingChild(SNode node, String conceptFQName) {
    if (node == null || node.getParent() == null) {
      return null;
    }
    SNode parent = node.getParent();
    SNode newChild = SModelOperations.createNewNode(node.getModel(), conceptFQName);
    if (newChild == null) {
      return null;
    }
    String role = node.getRoleInParent();
    assert parent != null && role != null;
    jetbrains.mps.util.SNodeOperations.insertChild(parent, role, newChild, node);
    return newChild;
  }
  public static SNode insertNewPrevSiblingChild(SNode node, String conceptFqName) {
    if (node == null) {
      return null;
    }
    SNode parent = node.getParent();
    if (parent == null) {
      return null;
    }
    SNode newChild = SModelOperations.createNewNode(node.getModel(), conceptFqName);
    if (newChild == null) {
      return null;
    }
    String role = node.getRoleInParent();
    assert role != null;
    parent.insertChildBefore(role, newChild, node);
    return newChild;
  }
  public static SNode insertNextSiblingChild(SNode node, SNode siblingNode) {
    if (node == null) {
      return null;
    }
    SNode nodeParent = node.getParent();
    if (nodeParent == null || siblingNode == null || node == siblingNode) {
      return siblingNode;
    }
    SNode parent = siblingNode.getParent();
    if (parent != null) {
      parent.removeChild(siblingNode);
    }
    String role = node.getRoleInParent();
    assert role != null;
    jetbrains.mps.util.SNodeOperations.insertChild(nodeParent, role, siblingNode, node);
    return siblingNode;
  }
  public static SNode insertPrevSiblingChild(SNode node, SNode siblingNode) {
    if (node == null) {
      return null;
    }
    SNode nodeParent = node.getParent();
    if (nodeParent == null || siblingNode == null || node == siblingNode) {
      return siblingNode;
    }
    SNode siblingParent = siblingNode.getParent();
    if (siblingParent != null) {
      siblingParent.removeChild(siblingNode);
    }
    String role = node.getRoleInParent();
    assert role != null;
    nodeParent.insertChildBefore(role, siblingNode, node);
    return siblingNode;
  }
  public static SNode replaceWithNewChild(SNode oldChild, String conceptFqName) {
    assert oldChild != null : "can't replace node. node is NULL";
    SNode oldChildParent = oldChild.getParent();
    if (oldChildParent == null && (oldChild.getModel() == null || oldChild.getParent() != null)) {
      return null;
    }
    SModel model = oldChild.getModel();
    SNode newChild = SModelOperations.createNewNode(model, conceptFqName);
    if (newChild == null) {
      return null;
    }
    SNodeUtil.replaceWithAnother(oldChild, newChild);
    SNodeOperations.copyAllAttributes(oldChild, newChild);
    return newChild;
  }
  private static void copyAllAttributes(SNode oldChild, SNode newChild) {
    for (SNode attribute : AttributeOperations.getAllAttributes(oldChild)) {
      if (SNodeOperations.isInstanceOf(attribute, "jetbrains.mps.lang.core.structure.PropertyAttribute")) {
        String propertyName = AttributeOperations.getPropertyName(SNodeOperations.cast(attribute, "jetbrains.mps.lang.core.structure.PropertyAttribute"));
        if ((BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.getConceptDeclaration(newChild), "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", "call_findPropertyDeclaration_1219835742593", new Object[]{propertyName}) == null)) {
          // no such property in new child : don't copy the attribute 
          LOG.error("couldn't copy attribute " + attribute.getConcept().getName() + " for property '" + propertyName + "' : so such property in concept " + newChild.getConcept().getName(), newChild);
          continue;
        }
      }
      if (SNodeOperations.isInstanceOf(attribute, "jetbrains.mps.lang.core.structure.LinkAttribute")) {
        String linkRole = AttributeOperations.getLinkRole(SNodeOperations.cast(attribute, "jetbrains.mps.lang.core.structure.LinkAttribute"));
        if ((BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.getConceptDeclaration(newChild), "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", "call_findLinkDeclaration_1213877394467", new Object[]{linkRole}) == null)) {
          // no such link in new child : don't copy the attribute 
          LOG.error("couldn't copy attribute " + attribute.getConcept().getName() + " for link '" + linkRole + "' : so such link in concept " + newChild.getConcept().getName(), newChild);
          continue;
        }
      }

      newChild.addChild(SNodeOperations.getContainingLinkRole(attribute), SNodeOperations.copyNode(attribute));
    }
  }
  public static SNode replaceWithAnother(SNode node, SNode anotherNode) {
    assert node != null : "can't replace node. node is NULL";
    return ((SNode) SNodeUtil.replaceWithAnother(node, anotherNode));
  }
  public static void deleteNode(SNode node) {
    if (node != null) {
      node.delete();
    }
  }
  public static SNode detachNode(SNode node) {
    if (node != null && node.getModel() != null) {
      SNode parent = node.getParent();
      if (parent != null) {
        parent.removeChild(node);
      } else {
        node.getModel().removeRootNode(node);
      }
    }
    return node;
  }
  public static boolean hasRole(SNode node, String conceptOfParentFqName, String role) {
    if (node == null || node.getParent() == null || conceptOfParentFqName == null || conceptOfParentFqName.length() == 0 || role == null || role.length() == 0) {
      return false;
    }
    SNode expectedConcept = SModelUtil.findConceptDeclaration(conceptOfParentFqName);
    if (expectedConcept == null) {
      return false;
    }
    SNode nodeParent = node.getParent();
    assert nodeParent != null;
    SNode conceptOfParent = SNodeOperations.getConceptDeclaration(nodeParent);
    if (!(SModelUtil.isAssignableConcept(conceptOfParent, expectedConcept))) {
      return false;
    }
    return role.equals(node.getRoleInParent());
  }
  public static SNode getConceptDeclaration(SNode node) {
    return (node == null ? null : SModelUtil.findConceptDeclaration(node.getConcept().getQualifiedName()));
  }
  public static int getIndexInParent(SNode node) {
    if (node == null || node.getParent() == null) {
      return -1;
    }
    String role = node.getRoleInParent();
    if (role == null) {
      return -1;
    }
    return IterableUtil.asList(node.getParent().getChildren(role)).indexOf(node);
  }
  public static List<SNode> getAllAttributes(SNode node) {
    return AttributeOperations.getAllAttributes(node);
  }
  public static boolean isAttribute(SNode node) {
    return AttributeOperations.isAttribute(node);
  }
  public static SNode getNode(String modelUID, String nodeID) {
    return new SNodePointer(modelUID, nodeID).resolve(MPSModuleRepository.getInstance());
  }
  /**
   * use ModelConstraints.getScope() and ModelConstraints.getReferenceDescriptor()
   */
  @Deprecated
  public static ISearchScope getReferentSearchScope(SNode referenceNode, String referenceRole, IOperationContext context) {
    if (referenceNode == null) {
      return null;
    }
    Scope scope = ModelConstraints.getReferenceDescriptor(referenceNode, referenceRole).getScope();
    if (scope instanceof ErrorScope) {
      return null;
    }
    if (scope instanceof ISearchScope.Adapter) {
      return ((ISearchScope.Adapter) scope).getSearchScope();
    }
    return new ScopeAdapter(scope);
  }
  public static SNode cast(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SNodeOperations.isInstanceOf(node, castTo))) {
      String message = "Can't cast node: " + node.getNodeId().toString() + ", concept: " + node.getConcept().getQualifiedName() + " to concept: " + castTo;
      if (ourCastExceptionsEnabled) {
        throw new NodeCastException(message);
      } else {
        LOG.warning(message);
      }
    }
    return node;
  }
  public static SNode as(SNode node, String castTo) {
    if (!(SNodeOperations.isInstanceOf(node, castTo))) {
      return null;
    }
    return node;
  }
  public static SNode castConcept(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SModelUtil.isAssignableConcept(NameUtil.nodeFQName(node), castTo))) {
      String message = "Can't cast concept: " + node.getNodeId().toString() + ", FQName: " + NameUtil.nodeFQName(node) + " to concept: " + castTo;
      if (ourCastExceptionsEnabled) {
        throw new NodeCastException(message);
      } else {
        LOG.warning(message);
      }
    }
    return node;
  }
  public static SNode asConcept(SNode node, String castTo) {
    if (node == null) {
      return null;
    }
    if (!(SModelUtil.isAssignableConcept(NameUtil.nodeFQName(node), castTo))) {
      return null;
    }
    return node;
  }
  public static SNode getContainingLinkDeclaration(SNode childNode) {
    if (childNode == null) {
      return null;
    }
    String role = childNode.getRoleInParent();
    if (role == null) {
      return null;
    }
    SNode c = SNodeOperations.getConceptDeclaration(SNodeOperations.getParent(childNode));
    return SModelSearchUtil.findLinkDeclaration(c, role);
  }
  public static String getContainingLinkRole(SNode childNode) {
    if (childNode == null) {
      return null;
    }
    return childNode.getRoleInParent();
  }
  public static List<SReference> getReferences(SNode node) {
    if (node == null) {
      return new EmptyList<SReference>("Attempt to add reference to unexistent parent. Reference: %s");
    }
    return IterableUtil.asList(node.getReferences());
  }
  public static SReference getReference(SNode node, SNode linkDeclaration) {
    if (node == null || linkDeclaration == null) {
      return null;
    }
    linkDeclaration = SModelUtil.getGenuineLinkDeclaration(linkDeclaration);
    return node.getReference(SPropertyOperations.getString(linkDeclaration, "role"));
  }
  public static Iterable<SNode> ofConcept(Iterable<SNode> nodes, String conceptName) {
    if (conceptName == null) {
      return Sequence.fromIterable(Collections.<SNode>emptyList());
    }
    InstanceOfCondition condition = new InstanceOfCondition(conceptName).tolerateNulls();
    Iterable<SNode> rv = new ConditionalIterable<SNode>(nodes, condition);
    return rv;
  }
}
