package jetbrains.mps.debug.evaluation.ui;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SNode;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.debug.runtime.JavaUiState;
import jetbrains.mps.debug.runtime.DebugSession;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.AttributesRolesUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;

public class HighLevelEvaluationLogic extends AbstractEvaluationLogic {
  private static final Logger LOG = Logger.getLogger(HighLevelEvaluationLogic.class);

  private SNode myLocationRootCopy;
  private SNode myNodeToShow;

  public HighLevelEvaluationLogic(@NotNull IOperationContext context, @NotNull JavaUiState state, @NotNull DebugSession debugSession) {
    super(context, state, debugSession);

    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        // TODO not all languages have block statements; type of used statement should be specified via plugin 
        myNodeToShow = SConceptOperations.createNewNode("jetbrains.mps.baseLanguage.structure.BlockStatement", null);
        SLinkOperations.setNewChild(myNodeToShow, AttributesRolesUtil.childRoleFromAttributeRole("toEvaluateAnnotation"), "jetbrains.mps.debug.evaluation.structure.ToEvaluateAnnotation");

        SNode locationNode = getLocationNode();
        SNode locationRoot = getLocationRoot();
        HighLevelEvaluationLogic.this.myLocationRootCopy = SNodeOperations.copyNode(locationRoot);
        SNode locationNodeCopy = HighLevelEvaluationLogic.this.findNodesCopy(locationRoot, HighLevelEvaluationLogic.this.myLocationRootCopy, locationNode);

        SNodeOperations.insertNextSiblingChild(locationNodeCopy, myNodeToShow);
      }
    });
  }

  @Nullable
  private SNode getLocationRoot() {
    SNode locationNode = getLocationNode();
    if (locationNode != null) {
      return SNodeOperations.getAncestor(locationNode, null, false, true);
    }
    return null;
  }

  private SNode findNodesCopy(SNode root, SNode rootCopy, final SNode originalNodeToFind) {
    if (originalNodeToFind == root) {
      return rootCopy;
    }
    SNode parentsCopy = this.findNodesCopy(root, rootCopy, SNodeOperations.getParent(originalNodeToFind));
    return ListSequence.fromList(SNodeOperations.getChildren(parentsCopy)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.getContainingLinkRole(it).equals(SNodeOperations.getContainingLinkRole(originalNodeToFind));
      }
    }).skip(SNodeOperations.getIndexInParent(originalNodeToFind)).first();
  }

  @NotNull
  public SNode getNodeToShow() {
    return myNodeToShow;
  }

  @NotNull
  public SNode getRootToShow() {
    return myLocationRootCopy;
  }

  @Override
  public void updateState() {
    super.updateState();
    throw new RuntimeException("update state unimplemented!");
  }
}
