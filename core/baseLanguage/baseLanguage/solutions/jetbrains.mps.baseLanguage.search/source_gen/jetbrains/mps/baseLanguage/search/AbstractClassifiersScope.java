package jetbrains.mps.baseLanguage.search;

/*Generated by MPS */

import jetbrains.mps.smodel.search.AbstractSearchScope;
import org.jetbrains.annotations.NotNull;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.util.Condition;
import jetbrains.mps.smodel.BaseAdapter;
import jetbrains.mps.smodel.INodeAdapter;
import jetbrains.mps.baseLanguage.structure.Classifier;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.structure.ClassConcept;
import jetbrains.mps.baseLanguage.structure.Interface;
import jetbrains.mps.baseLanguage.structure.Annotation;
import java.util.Iterator;
import jetbrains.mps.baseLanguage.structure.ConstructorDeclaration;
import jetbrains.mps.baseLanguage.structure.FieldDeclaration;
import jetbrains.mps.baseLanguage.structure.InstanceMethodDeclaration;
import jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration;
import jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration;
import jetbrains.mps.baseLanguage.structure.EnumClass;
import jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration;

public abstract class AbstractClassifiersScope extends AbstractSearchScope implements IClassifiersSearchScope {
  private int myConstraint;

  protected AbstractClassifiersScope(int constraint) {
    this.myConstraint = constraint;
  }

  public int getConstraint() {
    return this.myConstraint;
  }

  @NotNull
  public List<SNode> getNodes(Condition<SNode> condition) {
    return BaseAdapter.toNodes(this.getNodesFormClassifiersList(getClassifiers(), this.myConstraint, BaseAdapter.adapterCondition(condition)));
  }

  protected List<INodeAdapter> getNodesFormClassifiersList(List<Classifier> classifiers, int constraint, Condition<INodeAdapter> condition) {
    List<INodeAdapter> result = new ArrayList<INodeAdapter>();
    if (constraint == 0) {
      return result;
    }
    if ((constraint ^ IClassifiersSearchScope.ANYTHING) == 0) {
      for (Classifier classifier : classifiers) {
        if (condition.met(classifier)) {
          result.add(classifier);
        }
        result.addAll(classifier.getDescendants(condition));
      }
    } else {
      for (Classifier classifier : classifiers) {
        if ((constraint & IClassifiersSearchScope.NON_FINAL) == IClassifiersSearchScope.NON_FINAL && classifier instanceof ClassConcept && ((ClassConcept) classifier).getIsFinal()) {
          continue;
        }
        if ((constraint & IClassifiersSearchScope.INTERFACE) == IClassifiersSearchScope.INTERFACE && classifier instanceof Interface && !(classifier instanceof Annotation) && condition.met(classifier)) {
          result.add(classifier);
        }
        if ((constraint & IClassifiersSearchScope.ANNOTATION) == IClassifiersSearchScope.ANNOTATION && classifier.getClass() == Annotation.class && condition.met(classifier)) {
          result.add(classifier);
        }
        if ((constraint & IClassifiersSearchScope.CLASS) == IClassifiersSearchScope.CLASS && classifier instanceof ClassConcept && condition.met(classifier)) {
          result.add(classifier);
        }
        if ((constraint & IClassifiersSearchScope.CONSTRUCTOR) == IClassifiersSearchScope.CONSTRUCTOR && classifier instanceof ClassConcept) {
          Iterator<ConstructorDeclaration> iterator = ((ClassConcept) classifier).constructors();
          while (iterator.hasNext()) {
            ConstructorDeclaration constructorDeclaration = iterator.next();
            if (condition.met(constructorDeclaration)) {
              result.add(constructorDeclaration);
            }
          }
        }
        if ((constraint & IClassifiersSearchScope.INSTANCE_FIELD) == IClassifiersSearchScope.INSTANCE_FIELD && classifier instanceof ClassConcept) {
          Iterator<FieldDeclaration> iterator = ((ClassConcept) classifier).fields();
          while (iterator.hasNext()) {
            FieldDeclaration member = iterator.next();
            if (condition.met(member)) {
              result.add(member);
            }
          }
        }
        if ((constraint & IClassifiersSearchScope.INSTANCE_METHOD) == IClassifiersSearchScope.INSTANCE_METHOD) {
          Iterator<InstanceMethodDeclaration> iterator = classifier.methods();
          while (iterator.hasNext()) {
            InstanceMethodDeclaration member = iterator.next();
            if (condition.met(member)) {
              result.add(member);
            }
          }
        }
        if ((constraint & IClassifiersSearchScope.STATIC_FIELD) == IClassifiersSearchScope.STATIC_FIELD) {
          Iterator<StaticFieldDeclaration> iterator = classifier.staticFields();
          while (iterator.hasNext()) {
            StaticFieldDeclaration member = iterator.next();
            if (condition.met(member)) {
              result.add(member);
            }
          }
        }
        if ((constraint & IClassifiersSearchScope.STATIC_METHOD) == IClassifiersSearchScope.STATIC_METHOD && classifier instanceof ClassConcept) {
          Iterator<StaticMethodDeclaration> iterator = ((ClassConcept) classifier).staticMethods();
          while (iterator.hasNext()) {
            StaticMethodDeclaration member = iterator.next();
            if (condition.met(member)) {
              result.add(member);
            }
          }
        }
        if ((constraint & IClassifiersSearchScope.ENUM_CONSTANT) == IClassifiersSearchScope.ENUM_CONSTANT && classifier instanceof EnumClass) {
          Iterator<EnumConstantDeclaration> iterator = ((EnumClass) classifier).enumConstants();
          while (iterator.hasNext()) {
            EnumConstantDeclaration member = iterator.next();
            if (condition.met(member)) {
              result.add(member);
            }
          }
        }
      }
    }
    return result;
  }

  public List<SNode> getClassifierNodes() {
    return BaseAdapter.toNodes(getClassifiers());
  }
}
