package jetbrains.mps.baseLanguage.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.quickfix.QuickFix_Runtime;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.search.ClassifierAndSuperClassifiersScope;
import jetbrains.mps.baseLanguage.structure.Classifier;
import jetbrains.mps.smodel.BaseAdapter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class ChooseAppropriateMethodDeclaration_QuickFix extends QuickFix_Runtime {

  public ChooseAppropriateMethodDeclaration_QuickFix() {
  }

  public String getDescription() {
    return "choose appropriate method declaration";
  }

  public void execute(SNode node) {
    if (SNodeOperations.isInstanceOf(((SNode)this.getField("methodCall")[0]), "jetbrains.mps.baseLanguage.structure.ClassCreator") && SNodeOperations.isInstanceOf(((SNode)this.getField("classifier")[0]), "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      SNode constructorCall = SNodeOperations.cast(((SNode)this.getField("methodCall")[0]), "jetbrains.mps.baseLanguage.structure.ClassCreator");
      SNode classConcept = SNodeOperations.cast(((SNode)this.getField("classifier")[0]), "jetbrains.mps.baseLanguage.structure.ClassConcept");
      List<SNode> list = SLinkOperations.getTargets(classConcept, "constructor", true);
      for(SNode constructorDeclaration : list) {
        if (SLinkOperations.getCount(constructorDeclaration, "parameter") == SLinkOperations.getCount(constructorCall, "actualArgument")) {
          boolean good = true;
          List<SNode> parameterTypes = ResolveUtil.parameterTypes(constructorDeclaration, SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(constructorCall), "jetbrains.mps.baseLanguage.structure.ClassifierType"), ((SNode)this.getField("classifier")[0]));
          {
            SNode parameterType;
            SNode argument;
            Iterator<SNode> parameterType_iterator = ListSequence.fromList(parameterTypes).iterator();
            Iterator<SNode> argument_iterator = ListSequence.fromList(SLinkOperations.getTargets(constructorCall, "actualArgument", true)).iterator();
            while (true) {
              if (!(parameterType_iterator.hasNext())) {
                break;
              }
              if (!(argument_iterator.hasNext())) {
                break;
              }
              parameterType = parameterType_iterator.next();
              argument = argument_iterator.next();
              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), parameterType))) {
                good = false;
                break;
              }
            }
          }
          if (good) {
            SLinkOperations.setTarget(constructorCall, "baseMethodDeclaration", constructorDeclaration, false);
            return;
          }
        }
      }
    } else if (SNodeOperations.isInstanceOf(((SNode)this.getField("methodCall")[0]), "jetbrains.mps.baseLanguage.structure.ConstructorInvocationStatement") && SNodeOperations.isInstanceOf(((SNode)this.getField("classifier")[0]), "jetbrains.mps.baseLanguage.structure.ClassConcept")) {
      SNode classConcept = SNodeOperations.cast(((SNode)this.getField("classifier")[0]), "jetbrains.mps.baseLanguage.structure.ClassConcept");
      SNode constructorCall = SNodeOperations.cast(((SNode)this.getField("methodCall")[0]), "jetbrains.mps.baseLanguage.structure.ConstructorInvocationStatement");
      List<SNode> list = SLinkOperations.getTargets(classConcept, "constructor", true);
      for(SNode constructorDeclaration : list) {
        if (SLinkOperations.getCount(constructorDeclaration, "parameter") == SLinkOperations.getCount(constructorCall, "actualArgument")) {
          boolean good = true;
          List<SNode> parameterTypes = ListSequence.fromList(new ArrayList<SNode>());
          for(SNode parameter : SLinkOperations.getTargets(constructorDeclaration, "parameter", true)) {
            ListSequence.fromList(parameterTypes).addElement(SNodeOperations.copyNode(SLinkOperations.getTarget(parameter, "type", true)));
          }
          {
            SNode parameterType;
            SNode argument;
            Iterator<SNode> parameterType_iterator = ListSequence.fromList(parameterTypes).iterator();
            Iterator<SNode> argument_iterator = ListSequence.fromList(SLinkOperations.getTargets(constructorCall, "actualArgument", true)).iterator();
            while (true) {
              if (!(parameterType_iterator.hasNext())) {
                break;
              }
              if (!(argument_iterator.hasNext())) {
                break;
              }
              parameterType = parameterType_iterator.next();
              argument = argument_iterator.next();
              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), parameterType))) {
                good = false;
                break;
              }
            }
          }
          if (good) {
            SLinkOperations.setTarget(constructorCall, "baseMethodDeclaration", constructorDeclaration, false);
            return;
          }
        }
      }
    } else if (SNodeOperations.isInstanceOf(((SNode)this.getField("methodCall")[0]), "jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration") && SNodeOperations.isInstanceOf(((SNode)this.getField("classifier")[0]), "jetbrains.mps.baseLanguage.structure.EnumClass")) {
      SNode constantDeclaration = SNodeOperations.cast(((SNode)this.getField("methodCall")[0]), "jetbrains.mps.baseLanguage.structure.EnumConstantDeclaration");
      SNode enumClass = SNodeOperations.cast(((SNode)this.getField("classifier")[0]), "jetbrains.mps.baseLanguage.structure.EnumClass");
      List<SNode> list = SLinkOperations.getTargets(enumClass, "constructor", true);
      for(SNode constructorDeclaration : list) {
        if (SLinkOperations.getCount(constructorDeclaration, "parameter") == SLinkOperations.getCount(constantDeclaration, "actualArgument")) {
          boolean good = true;
          List<SNode> parameterTypes = ResolveUtil.parameterTypes(constructorDeclaration, SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(constantDeclaration), "jetbrains.mps.baseLanguage.structure.ClassifierType"), ((SNode)this.getField("classifier")[0]));
          {
            SNode parameterType;
            SNode argument;
            Iterator<SNode> parameterType_iterator = ListSequence.fromList(parameterTypes).iterator();
            Iterator<SNode> argument_iterator = ListSequence.fromList(SLinkOperations.getTargets(constantDeclaration, "actualArgument", true)).iterator();
            while (true) {
              if (!(parameterType_iterator.hasNext())) {
                break;
              }
              if (!(argument_iterator.hasNext())) {
                break;
              }
              parameterType = parameterType_iterator.next();
              argument = argument_iterator.next();
              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), parameterType))) {
                good = false;
                break;
              }
            }
          }
          if (good) {
            SLinkOperations.setTarget(constantDeclaration, "baseMethodDeclaration", constructorDeclaration, false);
            return;
          }
        }
      }
    } else if (SNodeOperations.isInstanceOf(SNodeOperations.getParent(((SNode)this.getField("methodCall")[0])), "jetbrains.mps.baseLanguage.structure.DotExpression")) {
      SNode operandType = TypeChecker.getInstance().getTypeOf(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(((SNode)this.getField("methodCall")[0])), "jetbrains.mps.baseLanguage.structure.DotExpression"), "operand", true));
      if (!(SNodeOperations.isInstanceOf(operandType, "jetbrains.mps.baseLanguage.structure.ClassifierType"))) {
        return;
      }
      SNode instanceType = SNodeOperations.cast(operandType, "jetbrains.mps.baseLanguage.structure.ClassifierType");
      ClassifierAndSuperClassifiersScope scope = new ClassifierAndSuperClassifiersScope(((Classifier)SNodeOperations.getAdapter(SLinkOperations.getTarget(instanceType, "classifier", false))));
      List<SNode> mDecls = ((List<SNode>)BaseAdapter.toNodes(scope.getMethodsByName(SPropertyOperations.getString(SLinkOperations.getTarget(((SNode)this.getField("methodCall")[0]), "baseMethodDeclaration", false), "name"))));
      for(SNode methodDecl : mDecls) {
        if (SLinkOperations.getCount(methodDecl, "parameter") == SLinkOperations.getCount(((SNode)this.getField("methodCall")[0]), "actualArgument")) {
          boolean good = true;
          List<SNode> parameterTypes = ResolveUtil.parameterTypes(methodDecl, instanceType, ((SNode)this.getField("classifier")[0]));
          {
            SNode parameterType;
            SNode argument;
            Iterator<SNode> parameterType_iterator = ListSequence.fromList(parameterTypes).iterator();
            Iterator<SNode> argument_iterator = ListSequence.fromList(SLinkOperations.getTargets(((SNode)this.getField("methodCall")[0]), "actualArgument", true)).iterator();
            while (true) {
              if (!(parameterType_iterator.hasNext())) {
                break;
              }
              if (!(argument_iterator.hasNext())) {
                break;
              }
              parameterType = parameterType_iterator.next();
              argument = argument_iterator.next();
              if (!(TypeChecker.getInstance().getSubtypingManager().isSubtype(TypeChecker.getInstance().getTypeOf(argument), parameterType))) {
                good = false;
                break;
              }
            }
          }
          if (good) {
            SLinkOperations.setTarget(((SNode)this.getField("methodCall")[0]), "baseMethodDeclaration", methodDecl, false);
            return;
          }
        }
      }
    }
  }

}
