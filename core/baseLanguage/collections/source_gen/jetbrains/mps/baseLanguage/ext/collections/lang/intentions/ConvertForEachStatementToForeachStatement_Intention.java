package jetbrains.mps.baseLanguage.ext.collections.lang.intentions;

/*Generated by MPS */

import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.bootstrap.smodelLanguage.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.helgins.inference.TypeChecker;
import jetbrains.mps.intentions.BaseIntention;
import jetbrains.mps.intentions.Intention;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.nodeEditor.EditorContext;
import jetbrains.mps.smodel.SNode;

import java.util.HashMap;
import java.util.Map;

public class ConvertForEachStatementToForeachStatement_Intention extends BaseIntention implements Intention {

  private Map<String, Object[]> myMap = new HashMap<String, Object[]>();

  public String getConcept() {
    return "jetbrains.mps.baseLanguage.ext.collections.lang.structure.ForEachStatement";
  }

  public boolean isErrorIntention() {
    return false;
  }

  public String getDescription(SNode node, EditorContext editorContext) {
    return "Convert to \"for (Type var: iterable)\"";
  }

  public boolean isApplicable(SNode node, EditorContext editorContext) {
    return true;
  }

  public void execute(SNode node, EditorContext editorContext) {
    final SNode oldVariable = SLinkOperations.getTarget(node, "variable", true);
    SNode variableType = SNodeOperations.copyNode(TypeChecker.getInstance().getTypeOf(oldVariable));
    SNode foreachStatement = SNodeOperations.replaceWithNewChild(node, "jetbrains.mps.baseLanguage.structure.ForeachStatement");
    SLinkOperations.setTarget(foreachStatement, "body", SLinkOperations.getTarget(node, "body", true), true);
    SLinkOperations.setTarget(foreachStatement, "iterable", SLinkOperations.getTarget(node, "inputSequence", true), true);
    SPropertyOperations.set(foreachStatement, "label", SPropertyOperations.getString(node, "label"));
    SNode newVariable = SLinkOperations.setNewChild(foreachStatement, "variable", "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration");
    SPropertyOperations.set(newVariable, "name", SPropertyOperations.getString(oldVariable, "name"));
    SLinkOperations.setTarget(newVariable, "type", variableType, true);
    for (SNode oldRef : ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(foreachStatement, "body", true), "jetbrains.mps.baseLanguage.ext.collections.lang.structure.ForEachVariableReference", false)).where(new IWhereFilter<SNode>() {

      public boolean accept(SNode it) {
        return SLinkOperations.getTarget(it, "variable", false) == oldVariable;
      }

    })) {
      SLinkOperations.setTarget(SNodeOperations.replaceWithNewChild(oldRef, "jetbrains.mps.baseLanguage.structure.LocalVariableReference"), "variableDeclaration", newVariable, false);
    }
  }

  public Object[] getField(String key) {
    Object[] value = this.myMap.get(key);
    if (value == null) {
      value = new Object[1];
      this.myMap.put(key, value);
    }
    return value;
  }

  public void putArgument(String key, Object argument) {
    this.getField(key)[0] = argument;
  }

  public String getLocationString() {
    return "jetbrains.mps.baseLanguage.ext.collections.lang.intentions";
  }

}
