package jetbrains.mps.dependencies.util;

/*Generated by MPS */

import jetbrains.mps.make.dependencies.graph.Graph;
import java.util.Map;
import jetbrains.mps.project.IModule;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.ModuleUtil;
import jetbrains.mps.smodel.Language;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.make.dependencies.graph.IVertex;
import org.jetbrains.annotations.NotNull;

public class ModuleGraph extends Graph<ModuleGraph.ModuleVertex> {
  private final Map<IModule, ModuleGraph.ModuleVertex> myMap = MapSequence.fromMap(new LinkedHashMap<IModule, ModuleGraph.ModuleVertex>(16, (float) 0.75, false));
  private final _FunctionTypes._return_P1_E0<? extends Set<IModule>, ? super IModule> myGetNextFunction;

  public ModuleGraph(IModule module) {
    this(module, new _FunctionTypes._return_P1_E0<Set<IModule>, IModule>() {
      public Set<IModule> invoke(IModule m) {
        Set<IModule> modules = SetSequence.fromSet(new LinkedHashSet<IModule>());
        SetSequence.fromSet(modules).addSequence(Sequence.fromIterable(ModuleUtil.getDependencies(m)));
        for (Language used : Sequence.fromIterable(ModuleUtil.getUsedLanguages(m))) {
          SetSequence.fromSet(modules).addElement(used);
        }
        SetSequence.fromSet(modules).removeElement(m);
        return modules;
      }
    });
    addVertexes(new ModuleGraph.ModuleVertex(module));
  }

  public ModuleGraph(IModule module, _FunctionTypes._return_P1_E0<? extends Set<IModule>, ? super IModule> getNextFunction) {
    myGetNextFunction = getNextFunction;
    addVertexes(new ModuleGraph.ModuleVertex(module));
  }

  private void addVertexes(ModuleGraph.ModuleVertex vertex) {
    add(vertex);
    Set<IModule> dependency = myGetNextFunction.invoke(vertex.myModule);
    for (IModule dep : SetSequence.fromSet(dependency)) {
      ModuleGraph.ModuleVertex next = MapSequence.fromMap(myMap).get(dep);
      if (next == null) {
        next = new ModuleGraph.ModuleVertex(dep);
        MapSequence.fromMap(myMap).put(dep, next);
        addVertexes(next);
      }
      SetSequence.fromSet(vertex.myNext).addElement(next);
    }
  }

  public List<IModule> findPath(IModule startModule, IModule finishModule) {
    ModuleGraph.ModuleVertex start = MapSequence.fromMap(myMap).get(startModule);
    ModuleGraph.ModuleVertex finish = MapSequence.fromMap(myMap).get(finishModule);
    if (start == null || finish == null) {
      return ListSequence.fromList(new ArrayList<IModule>());
    }
    List<ModuleGraph.ModuleVertex> path = new LinkedList<ModuleGraph.ModuleVertex>();
    ListSequence.fromList(path).addElement(start);
    Set<ModuleGraph.ModuleVertex> visited = SetSequence.fromSet(new HashSet<ModuleGraph.ModuleVertex>());
    SetSequence.fromSet(visited).addElement(start);
    findPath(path, finish, visited);
    return ListSequence.fromList(path).select(new ISelector<ModuleGraph.ModuleVertex, IModule>() {
      public IModule select(ModuleGraph.ModuleVertex it) {
        return it.myModule;
      }
    }).toListSequence();
  }

  private boolean findPath(List<ModuleGraph.ModuleVertex> path, ModuleGraph.ModuleVertex finish, Set<ModuleGraph.ModuleVertex> visited) {
    ModuleGraph.ModuleVertex last = ListSequence.fromList(path).last();
    if (last.equals(finish)) {
      return true;
    }
    for (ModuleGraph.ModuleVertex next : SetSequence.fromSet(last.getNexts())) {
      if (!(SetSequence.fromSet(visited).contains(next))) {
        ListSequence.fromList(path).addElement(next);
        SetSequence.fromSet(visited).addElement(next);
        if (findPath(path, finish, visited)) {
          return true;
        }
      }
    }
    ListSequence.fromList(path).removeLastElement();
    return false;
  }

  public class ModuleVertex implements IVertex {
    private final Set<ModuleGraph.ModuleVertex> myNext = SetSequence.fromSet(new LinkedHashSet<ModuleGraph.ModuleVertex>());
    @NotNull
    private final IModule myModule;

    public ModuleVertex(@NotNull IModule module) {
      myModule = module;
    }

    @Override
    public Set<ModuleGraph.ModuleVertex> getNexts() {
      return myNext;
    }

    @Override
    public String toString() {
      return myModule.getModuleFqName();
    }

    @Override
    public boolean equals(Object object) {
      return myModule.equals(((ModuleGraph.ModuleVertex) object).myModule);
    }

    @Override
    public int hashCode() {
      return myModule.hashCode();
    }

    public IModule getModule() {
      return myModule;
    }
  }
}
