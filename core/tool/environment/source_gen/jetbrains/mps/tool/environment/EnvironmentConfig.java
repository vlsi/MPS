package jetbrains.mps.tool.environment;

/*Generated by MPS */

import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import java.util.Map;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import org.jetbrains.annotations.Nullable;
import java.util.Collections;
import jetbrains.mps.core.tool.environment.util.PathManager;

/**
 * Represents a configuration options list for an environment, used a Builder pattern
 * 
 * 
 * @see jetbrains.mps.tool.environment.Environment 
 * @see jetbrains.mps.tool.environment.EnvironmentContainer 
 */
public class EnvironmentConfig {
  private final Set<PluginDescriptor> myPlugins = SetSequence.fromSet(new LinkedHashSet<PluginDescriptor>());
  private final Map<String, File> myMacros = MapSequence.fromMap(new LinkedHashMap<String, File>(16, (float) 0.75, false));
  private final Set<String> myLibs = SetSequence.fromSet(new LinkedHashSet<String>());
  private boolean myLoadPluginsByDefault = false;

  private EnvironmentConfig() {
  }

  /**
   * 
   * @return null if we do not want to specify plugins to the platform
   */
  @Nullable
  public Set<PluginDescriptor> getPlugins() {
    if (myLoadPluginsByDefault) {
      return null;
    }
    return SetSequence.fromSet(myPlugins).asUnmodifiable();
  }

  public Map<String, File> getMacros() {
    return Collections.unmodifiableMap(myMacros);
  }

  public Set<String> getLibs() {
    return SetSequence.fromSet(myLibs).asUnmodifiable();
  }

  public EnvironmentConfig addPlugin(String path, String id) {
    SetSequence.fromSet(myPlugins).addElement(new PluginDescriptor(path, id));
    return this;
  }

  public EnvironmentConfig addMacro(String macroName, File macroValue) {
    MapSequence.fromMap(myMacros).put(macroName, macroValue);
    return this;
  }

  public EnvironmentConfig addLib(String libPath) {
    SetSequence.fromSet(myLibs).addElement(libPath);
    return this;
  }

  public EnvironmentConfig withDefaultSamples() {
    return addMacro("samples_home", new File(System.getProperty("user.dir"), "samples"));
  }

  public EnvironmentConfig withDefaultPlugins() {
    return withMakePlugin().withCorePlugin().withTestingPlugin();
  }

  public EnvironmentConfig withMakePlugin() {
    return addPlugin("mpsmake", "jetbrains.mps.ide.make");
  }

  public EnvironmentConfig withVcsPlugin() {
    return addPlugin("vcs", "jetbrains.mps.vcs").withGit4IdeaPlugin();
  }

  public EnvironmentConfig withTestingPlugin() {
    return addPlugin("mps-testing", "jetbrains.mps.testing");
  }

  public EnvironmentConfig withCorePlugin() {
    return addPlugin("mps-core", "jetbrains.mps.core");
  }

  public EnvironmentConfig withGit4IdeaPlugin() {
    return addPlugin("git4idea", "Git4Idea");
  }

  public EnvironmentConfig withBuildPlugin() {
    return addPlugin("mps-build", "jetbrains.mps.build");
  }

  public EnvironmentConfig withMigrationPlugin() {
    return addPlugin("migrationAssistant", "jetbrains.mps.ide.migration.assistant");
  }

  public EnvironmentConfig withBootstrapLibraries() {
    for (String path : PathManager.getBootstrapPaths()) {
      addLib(path);
    }
    addLib(PathManager.getLanguagesPath());
    return this;
  }

  public EnvironmentConfig withWorkbenchPath() {
    String workbenchPath = PathManager.getHomePath() + File.separator + "workbench";
    addLib(workbenchPath);
    return this;
  }

  public static EnvironmentConfig defaultConfig() {
    return new EnvironmentConfig().withDefaultSamples().withDefaultPlugins().withBootstrapLibraries().withWorkbenchPath();
  }

  /**
   * 
   * @return EnvironmentConfig with no specified plugins. At the time of writing it meant that the platform will load all the plugins. Note that one needs to provide a proper class path.
   */
  public static EnvironmentConfig defaultConfigNoPluginsSpecified() {
    EnvironmentConfig defaultConf = defaultConfig();
    defaultConf.myLoadPluginsByDefault = false;
    return defaultConf;
  }

  /**
   * fixme: currently the repository within the 'empty environment' is inconsistent (mps-core plugin is needed),
   * so use defaultConfig
   */
  public static EnvironmentConfig emptyConfig() {
    return new EnvironmentConfig();
  }
}
