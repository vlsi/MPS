package jetbrains.mps.tool.builder.make;

/*Generated by MPS */

import jetbrains.mps.tool.builder.paths.ModuleOutputPaths;
import jetbrains.mps.tool.builder.paths.OutputPathRedirects;
import jetbrains.mps.tool.common.Script;
import jetbrains.mps.tool.builder.MpsWorker;
import jetbrains.mps.project.Project;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.smodel.ModelAccess;
import java.util.concurrent.Future;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.script.ScriptBuilder;
import jetbrains.mps.make.facet.IFacet;
import jetbrains.mps.smodel.resources.IMResource;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.project.IModule;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.List;
import java.util.Map;
import jetbrains.mps.make.script.IScriptController;
import java.util.concurrent.ExecutionException;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.smodel.resources.ModelsToResources;
import jetbrains.mps.generator.GenerationFacade;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.generator.impl.dependencies.GenerationDependenciesCache;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.generator.info.GeneratorPathsComponent;
import jetbrains.mps.generator.info.ForeignPathsProvider;
import java.io.File;
import jetbrains.mps.internal.make.runtime.util.DirUtil;

public class ReducedGenerationWorker extends GeneratorWorker {
  private ModuleOutputPaths myOutputPaths;
  private ReducedGenerationWorker.MyForeignRootPaths myForeignRootPaths;
  private OutputPathRedirects myOutputRedirects;

  public ReducedGenerationWorker(Script whatToDo) {
    super(whatToDo);
  }

  public ReducedGenerationWorker(Script whatToDo, MpsWorker.AntLogger logger) {
    super(whatToDo, logger);
  }

  @Override
  protected void generate(Project project, MpsWorker.ObjectsToProcess go) {
    ProjectOperationContext ctx = new ProjectOperationContext(project);

    ModelAccess.instance().flushEventQueue();
    Future<IResult> res;
    IOperationContext context = new ProjectOperationContext(project);


    BuildMakeService bms = new BuildMakeService();
    MakeSession ms = new MakeSession(context, getMyMessageHandler(), true) {
      @Override
      public IScript toScript(ScriptBuilder scriptBuilder) {
        scriptBuilder.withFacetNames(new IFacet.Name("jetbrains.mps.build.reduced.ReportFiles"), new IFacet.Name("jetbrains.mps.build.reduced.CollectHashes"));
        return scriptBuilder.toScript();
      }
    };

    final Iterable<IMResource> resources = Sequence.fromIterable(collectResources(ctx, go)).toListSequence();
    this.myOutputPaths = new ModuleOutputPaths(Sequence.fromIterable(resources).select(new ISelector<IMResource, IModule>() {
      public IModule select(IMResource r) {
        return r.module();
      }
    }));

    final String outputRoot = myWhatToDo.getProperty("OUTPUT_ROOT_DIR");
    final String cachesOutputRoot = myWhatToDo.getProperty("CACHES_OUTPUT_ROOT_DIR");
    final boolean useTransientOutput = Sequence.fromIterable(resources).any(new IWhereFilter<IMResource>() {
      public boolean accept(IMResource r) {
        return r.module().getModuleDescriptor().isUseTransientOutput();
      }
    });
    this.myOutputRedirects = new OutputPathRedirects(myOutputPaths, outputRoot, cachesOutputRoot, useTransientOutput);
    this.myForeignRootPaths = new ReducedGenerationWorker.MyForeignRootPaths(myOutputPaths.getOutputPaths());

    ReducedMakeFacetConfiguration facetConf = new ReducedMakeFacetConfiguration(myOutputRedirects);
    final List<String> writtenFiles = facetConf.getWrittenFiles();
    final List<String> deletedFiles = facetConf.getDeletedFiles();
    final Map<String, String> fileHashes = facetConf.getFileHashes();

    IScriptController scriptCtl = facetConf.configureFacets();

    try {
      res = bms.make(ms, resources, null, scriptCtl);
      if (!(res.get().isSucessful())) {
        myErrors.add("Make was not successful");
      }
      for (String f : writtenFiles) {
        System.out.println("##WRITTEN##" + f);
      }
      for (String f : deletedFiles) {
        System.out.println("##DELETED##" + f);
      }
    } catch (InterruptedException e) {
      myErrors.add(e.toString());
    } catch (ExecutionException e) {
      myErrors.add(e.toString());
    }
  }

  @Override
  protected void showStatistic() {
    // do nothing 
  }

  @Override
  protected Iterable<IMResource> collectResources(IOperationContext context, final MpsWorker.ObjectsToProcess go) {
    final Wrappers._T<Iterable<SModel>> models = new Wrappers._T<Iterable<SModel>>(null);
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        models.value = Sequence.fromIterable(models.value).concat(SetSequence.fromSet(go.getModels()));
      }
    });
    return Sequence.fromIterable(new ModelsToResources(context, Sequence.fromIterable(models.value).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel smd) {
        return GenerationFacade.canGenerate(smd);
      }
    })).resources(false)).select(new ISelector<IResource, IMResource>() {
      public IMResource select(IResource r) {
        return (IMResource) r;
      }
    });
  }

  @Override
  protected void make() {
    // we do not need make in ReducedGenerationWorker 
  }

  @Override
  protected void makeProject() {
  }

  @Override
  protected void setupEnvironment() {
    super.setupEnvironment();
    GenerationDependenciesCache.getInstance().registerCachePathRedirect(new GenerationDependenciesCache.CachePathRedirect() {
      public IFile redirectTo(IFile outputPath) {
        return myOutputRedirects.getCachesOutputRedirect(outputPath.getPath());
      }
    });
    GeneratorPathsComponent.getInstance().registerForeignPathsProvider(new ForeignPathsProvider() {
      public String belongsToForeignPath(IFile path) {
        return (myForeignRootPaths != null ?
          myForeignRootPaths.findForeignPrefix(path.getPath()) :
          null
        );
      }
    });
  }

  public static void main(String[] args) {
    MpsWorker mpsWorker = new ReducedGenerationWorker(Script.fromDumpInFile(new File(args[0])), new MpsWorker.SystemOutLogger());
    mpsWorker.workFromMain();
  }

  private static class MyForeignRootPaths {
    private String[] rootPaths;

    public MyForeignRootPaths(Iterable<String> foreignRoots) {
      this.rootPaths = Sequence.fromIterable(foreignRoots).select(new ISelector<String, String>() {
        public String select(String dir) {
          return DirUtil.normalizeAsDir(dir);
        }
      }).sort(new ISelector<String, String>() {
        public String select(String dir) {
          return dir;
        }
      }, true).toGenericArray(String.class);
    }

    public String findForeignPrefix(String path) {
      int idx = DirUtil.findPrefixAsDir(path, rootPaths);
      return (idx >= 0 ?
        rootPaths[idx] :
        null
      );
    }
  }
}
