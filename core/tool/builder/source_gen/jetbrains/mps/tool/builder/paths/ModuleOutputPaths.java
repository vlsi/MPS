package jetbrains.mps.tool.builder.paths;

/*Generated by MPS */

import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.facets.JavaModuleFacet;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.make.runtime.util.DirUtil;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import jetbrains.mps.extapi.persistence.FolderModelRootBase;
import jetbrains.mps.extapi.persistence.FileBasedModelRoot;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.vfs.impl.JarEntryFile;

public class ModuleOutputPaths {
  private String[] sortedOutDirs;
  private String[] sortedTestOutDirs;
  private String[] sortedOutCacheDirs;
  private String[] sortedTestOutCacheDirs;
  private String[] sortedModelDirs;
  public ModuleOutputPaths(Iterable<SModule> _modules) {
    // FIXME consider re-use of SModuleOperations#getOutputRoots, avoid code duplication 
    Iterable<SModule> modulesWithJavaFacet = Sequence.fromIterable(_modules).where(new IWhereFilter<SModule>() {
      public boolean accept(SModule it) {
        return it.getFacet(JavaModuleFacet.class) != null;
      }
    });
    Iterable<IFile> outputRoots = Sequence.fromIterable(modulesWithJavaFacet).select(new ISelector<SModule, IFile>() {
      public IFile select(SModule it) {
        return it.getFacet(JavaModuleFacet.class).getOutputRoot();
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile it) {
        return it != null;
      }
    });
    Iterable<IFile> outputCacheRoots = Sequence.fromIterable(modulesWithJavaFacet).select(new ISelector<SModule, IFile>() {
      public IFile select(SModule it) {
        return it.getFacet(JavaModuleFacet.class).getOutputCacheRoot();
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile it) {
        return it != null;
      }
    });
    this.sortedOutDirs = DirUtil.sortDirs(Sequence.fromIterable(outputRoots).select(new ISelector<IFile, String>() {
      public String select(IFile it) {
        return it.getPath();
      }
    }));
    this.sortedOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(outputCacheRoots).select(new ISelector<IFile, String>() {
      public String select(IFile it) {
        return it.getPath();
      }
    }));
    // todo: use union of output paths for models? Would be nice to (no need for getOutputRoot() notion then) but the way makeFacet.pathToFile 
    //       is invoked now suggests we get only path/to/module/source_gen here, which won't match any model path 
    Iterable<SModule> modulesWithTestsFacet = Sequence.fromIterable(_modules).where(new IWhereFilter<SModule>() {
      public boolean accept(SModule it) {
        return it.getFacet(TestsFacet.class) != null;
      }
    });
    Iterable<IFile> testOutputRoots = Sequence.fromIterable(modulesWithTestsFacet).select(new ISelector<SModule, IFile>() {
      public IFile select(SModule mod) {
        return mod.getFacet(TestsFacet.class).getTestsOutputPath();
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile it) {
        return it != null;
      }
    });
    Iterable<IFile> testOutputCacheRoots = Sequence.fromIterable(modulesWithTestsFacet).select(new ISelector<SModule, IFile>() {
      public IFile select(SModule mod) {
        return mod.getFacet(TestsFacet.class).getOutputCacheRoot();
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile it) {
        return it != null;
      }
    });
    this.sortedTestOutDirs = DirUtil.sortDirs(Sequence.fromIterable(testOutputRoots).select(new ISelector<IFile, String>() {
      public String select(IFile it) {
        return it.getPath();
      }
    }));
    this.sortedTestOutCacheDirs = DirUtil.sortDirs(Sequence.fromIterable(testOutputCacheRoots).select(new ISelector<IFile, String>() {
      public String select(IFile it) {
        return it.getPath();
      }
    }));

    // XXX would be nice if model root tells its path as an object, rather than string 
    Iterable<String> modelRootPaths = Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {
      public Iterable<ModelRoot> translate(SModule mod) {
        return mod.getModelRoots();
      }
    }).ofType(FolderModelRootBase.class).select(new ISelector<FolderModelRootBase, String>() {
      public String select(FolderModelRootBase smr) {
        return smr.getPath();
      }
    });
    modelRootPaths = Sequence.fromIterable(modelRootPaths).concat(Sequence.fromIterable(_modules).translate(new ITranslator2<SModule, ModelRoot>() {
      public Iterable<ModelRoot> translate(SModule mod) {
        return mod.getModelRoots();
      }
    }).ofType(FileBasedModelRoot.class).select(new ISelector<FileBasedModelRoot, String>() {
      public String select(FileBasedModelRoot smr) {
        return smr.getContentRoot();
      }
    }));

    this.sortedModelDirs = DirUtil.sortDirs(Sequence.fromIterable(modelRootPaths).select(new ISelector<String, IFile>() {
      public IFile select(String path) {
        return FileSystem.getInstance().getFileByPath(path);
      }
    }).where(new IWhereFilter<IFile>() {
      public boolean accept(IFile f) {
        return f.isDirectory() && !(f instanceof JarEntryFile);
      }
    }).select(new ISelector<IFile, String>() {
      public String select(IFile dir) {
        return dir.getPath();
      }
    }));
  }
  public String toLocalPath(String path) {
    String localOut = toLocal(path, sortedOutDirs);
    if (localOut != null) {
      return localOut;
    }
    return toLocal(path, sortedTestOutDirs);
  }
  public String toLocalCachePath(String path) {
    String localCacheOut = toLocal(path, sortedOutCacheDirs);
    if (localCacheOut != null) {
      return localCacheOut;
    }
    return toLocal(path, sortedTestOutCacheDirs);
  }
  private String toLocal(String path, String[] sortedDirs) {
    String normPath = DirUtil.normalizeAsDir(path);
    int idx = DirUtil.findPrefixAsDir(normPath, sortedDirs);
    if (idx >= 0) {
      return DirUtil.withoutPrefix(normPath, sortedDirs[idx]);
    }
    // not found 
    return null;
  }
  public Iterable<String> getOutputPaths() {
    return Sequence.fromIterable(Sequence.fromArray(sortedOutDirs)).concat(Sequence.fromIterable(Sequence.fromArray(sortedTestOutDirs))).concat(Sequence.fromIterable(Sequence.fromArray(sortedModelDirs)));
  }
}
