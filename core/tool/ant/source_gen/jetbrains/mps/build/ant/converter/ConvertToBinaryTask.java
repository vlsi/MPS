package jetbrains.mps.build.ant.converter;

/*Generated by MPS */

import org.apache.tools.ant.taskdefs.Copy;
import java.util.Map;
import java.util.HashMap;
import java.io.File;
import org.apache.tools.ant.util.FirstMatchMapper;
import org.apache.tools.ant.util.GlobPatternMapper;
import org.apache.tools.ant.util.IdentityMapper;
import org.apache.tools.ant.BuildException;
import jetbrains.mps.build.ant.MPSClasspathUtil;
import java.util.List;
import java.net.URL;
import java.util.ArrayList;
import java.net.MalformedURLException;
import java.net.URLClassLoader;
import java.lang.reflect.Method;
import java.io.IOException;
import org.apache.tools.ant.util.FileUtils;
import org.apache.tools.ant.types.FilterSetCollection;
import java.util.Vector;
import org.apache.tools.ant.Project;

public class ConvertToBinaryTask extends Copy {
  private Map<String, String> toConvert = new HashMap<String, String>();
  private File mpsHome;


  public ConvertToBinaryTask() {
    FirstMatchMapper mapper = new FirstMatchMapper();
    GlobPatternMapper first = new GlobPatternMapper();
    first.setFrom("*.mps");
    first.setTo("*.mpb");
    mapper.add(first);
    mapper.add(new IdentityMapper());
    add(mapper);
    fileUtils = new ConvertToBinaryTask.FileUtilsEx(fileUtils);
  }

  public void setMpsHome(File mpsHome) {
    this.mpsHome = mpsHome;
  }

  public File getMpsHome() {
    return mpsHome;
  }

  @Override
  public void execute() throws BuildException {
    super.execute();
    if (!(toConvert.isEmpty())) {
      Iterable<File> classPaths = MPSClasspathUtil.buildClasspath(getProject(), mpsHome);
      List<URL> classPathUrls = new ArrayList<URL>();
      for (File path : classPaths) {
        try {
          classPathUrls.add(new URL("file:///" + path));
        } catch (MalformedURLException e) {
          throw new BuildException(e);
        }
      }
      URLClassLoader classLoader = new URLClassLoader(classPathUrls.toArray(new URL[classPathUrls.size()]), this.getClass().getClassLoader());
      try {
        Class<?> converterClass = classLoader.loadClass("jetbrains.mps.tool.builder.converter.ConvertToBinaryWorker");
        Object converter = converterClass.newInstance();
        Method method = converterClass.getMethod("convert", Map.class);
        method.invoke(converter, toConvert);
      } catch (Throwable t) {
        if (t instanceof RuntimeException && t.getCause() instanceof IOException) {
          t = t.getCause();
        }
        throw new BuildException("Cannot convert .mps into .mpb: " + t.getMessage() + "\n" + "Used class path: " + classPathUrls.toString(), t);
      }
    }
  }

  public class FileUtilsEx extends FileUtils {
    private final FileUtils delegate;

    public FileUtilsEx(FileUtils delegate) {
      this.delegate = delegate;
    }

    @Override
    public String getDefaultEncoding() {
      return delegate.getDefaultEncoding();
    }

    @Override
    public void copyFile(File sourceFile, File destFile, FilterSetCollection filters, Vector filterChains, boolean overwrite, boolean preserveLastModified, boolean append, String inputEncoding, String outputEncoding, Project project, boolean force) throws IOException {
      if (sourceFile.getPath().endsWith(".mps")) {
        toConvert.put(sourceFile.getPath(), destFile.getPath());
      } else {
        delegate.copyFile(sourceFile, destFile, filters, filterChains, overwrite, preserveLastModified, append, inputEncoding, outputEncoding, project, force);
      }
    }
  }
}
