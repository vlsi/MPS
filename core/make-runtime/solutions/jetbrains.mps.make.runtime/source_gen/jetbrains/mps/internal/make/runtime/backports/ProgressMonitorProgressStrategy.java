package jetbrains.mps.internal.make.runtime.backports;

/*Generated by MPS */

import jetbrains.mps.internal.make.runtime.script.AbstractProgressStrategy;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import java.util.Deque;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.DequeSequence;
import java.util.LinkedList;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class ProgressMonitorProgressStrategy extends AbstractProgressStrategy {
  private static final String TOTAL = "__TOTAL__";
  private static final int MAXWORK = 10000;
  @NotNull
  private ProgressMonitor monitor;
  private Deque<Tuples._2<ProgressMonitor, AbstractProgressStrategy.Work>> monitorWorkStack = DequeSequence.fromDequeNew(new LinkedList<Tuples._2<ProgressMonitor, AbstractProgressStrategy.Work>>());
  private boolean isInitialized;
  private int done;
  public ProgressMonitorProgressStrategy() {
    super(TOTAL);
    reset(new EmptyProgressMonitor());
  }
  public void reset(ProgressMonitor monitor) {
    this.monitor = (monitor != null ? monitor : new EmptyProgressMonitor());
    DequeSequence.fromDequeNew(monitorWorkStack).clear();
    this.done = 0;
    this.isInitialized = false;
  }
  public void initializeIfNeeded() {
    if (!(isInitialized)) {
      monitor.start("", MAXWORK);
      isInitialized = true;
    }
  }
  public boolean isCanceled() {
    return monitor.isCanceled();
  }
  public ProgressMonitor getProgressMonitor() {
    initializeIfNeeded();
    return (DequeSequence.fromDequeNew(monitorWorkStack).isEmpty() ? monitor : DequeSequence.fromDequeNew(monitorWorkStack).peekElement()._0());
  }
  @Override
  protected void begunWork(AbstractProgressStrategy.Work wrk) {
    initializeIfNeeded();
    ProgressMonitor submon;
    if (DequeSequence.fromDequeNew(monitorWorkStack).isEmpty()) {
      submon = monitor.subTask((int) Math.floor(wrk.prevWorkRatio() * MAXWORK));
    } else {
      submon = DequeSequence.fromDequeNew(monitorWorkStack).peekElement()._0().subTask(wrk.prevWork());
    }
    submon.start(wrk.name(), wrk.workLeft());
    DequeSequence.fromDequeNew(monitorWorkStack).pushElement(MultiTuple.<ProgressMonitor,AbstractProgressStrategy.Work>from(submon, wrk));
  }
  @Override
  protected void advancedWork(AbstractProgressStrategy.Work wrk) {
    initializeIfNeeded();
    if (wrk == DequeSequence.fromDequeNew(monitorWorkStack).peekElement()._1()) {
      ProgressMonitor mon = DequeSequence.fromDequeNew(monitorWorkStack).peekElement()._0();
      mon.advance(wrk.workDone());
      mon.step(wrk.comment());
    }
  }
  @Override
  protected void finishedWork(AbstractProgressStrategy.Work wrk) {
    initializeIfNeeded();
    popMatchingMonitor(wrk).done();
  }
  private ProgressMonitor popMatchingMonitor(AbstractProgressStrategy.Work work) {
    while (DequeSequence.fromDequeNew(monitorWorkStack).isNotEmpty()) {
      if (DequeSequence.fromDequeNew(monitorWorkStack).peekElement()._1() == work) {
        return DequeSequence.fromDequeNew(monitorWorkStack).popElement()._0();
      }
      DequeSequence.fromDequeNew(monitorWorkStack).popElement()._0().done();
    }
    return monitor;
  }
}
