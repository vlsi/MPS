package jetbrains.mps.internal.make.runtime.util;

/*Generated by MPS */

import jetbrains.mps.make.delta.IDelta;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.vfs.IFile;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.List;
import jetbrains.mps.make.delta.IDeltaVisitor;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.ArrayList;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.util.Arrays;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.generator.info.GeneratorPathsComponent;

public class FilesDelta implements IDelta {
  private static Logger LOG = LogManager.getLogger(FilesDelta.class);
  private IFile rootDir;
  private Map<IFile, FilesDelta.Status> files = MapSequence.fromMap(new HashMap<IFile, FilesDelta.Status>());
  private Map<IFile, List<IFile>> generatedChildren = MapSequence.fromMap(new HashMap<IFile, List<IFile>>());
  private String key;

  public FilesDelta(IFile dir) {
    this.rootDir = dir;
    this.key = "(IFile)" + DirUtil.asDir(DirUtil.straighten(DirUtil.urlToPath(dir.getAbsolutePath())));
  }

  public FilesDelta(IFile dir, IFile cachesDir) {
    this.rootDir = dir;
    this.key = "(IFile)" + DirUtil.asDir(DirUtil.straighten(DirUtil.urlToPath(dir.getAbsolutePath())));
    cacheGenChildren(dir, cachesDir);
  }

  private FilesDelta(FilesDelta copyFrom) {
    this.rootDir = copyFrom.rootDir;
    this.key = copyFrom.key;
    copy(copyFrom);
  }

  public void written(IFile file) {
    LOG.debug("Written " + file);
    MapSequence.fromMap(files).put(file, FilesDelta.Status.WRITTEN);
  }

  public void kept(IFile file) {
    LOG.debug("Kept " + file);
    MapSequence.fromMap(files).put(file, FilesDelta.Status.KEPT);
  }

  public void deleted(IFile file) {
    LOG.debug("Deleted " + file);
    MapSequence.fromMap(files).put(file, FilesDelta.Status.DELETED);
  }

  @Override
  public boolean reconcile() {
    return acceptVisitor(new FilesDelta.Visitor() {
      @Override
      public boolean acceptDeleted(IFile file) {
        FilesDelta.LOG.debug("Reconciled: deleting " + file);
        try {
          file.delete();
        } catch (RuntimeException ignore) {
          FilesDelta.LOG.error("Exception deleting file " + file, ignore);
        }
        return true;
      }
    });
  }

  @Override
  public boolean acceptVisitor(IDeltaVisitor visitor) {
    if (!(visitor instanceof FilesDelta.Visitor)) {
      return true;
    }
    return acceptFilesVisitor(((FilesDelta.Visitor) visitor));
  }

  @Override
  public IDelta merge(IDelta toMerge) {
    if (!(toMerge instanceof FilesDelta)) {
      throw new IllegalArgumentException();
    }
    if (!(this.contains(toMerge))) {
      throw new IllegalArgumentException();
    }
    return new FilesDelta((FilesDelta) this).copy((FilesDelta) toMerge);
  }

  private boolean acceptFilesVisitor(final FilesDelta.Visitor visitor) {
    visitor.acceptRoot(rootDir);
    MapSequence.fromMap(files).visitAll(new IVisitor<IMapping<IFile, FilesDelta.Status>>() {
      public void visit(IMapping<IFile, FilesDelta.Status> m) {
        if (m.value() == FilesDelta.Status.KEPT && !(m.key().isDirectory())) {
          visitor.acceptKept(m.key());
        } else if (m.value() == FilesDelta.Status.WRITTEN) {
          visitor.acceptWritten(m.key());
        }
      }
    });
    ListSequence.fromList(this.collectFilesToDelete()).visitAll(new IVisitor<IFile>() {
      public void visit(IFile f) {
        visitor.acceptDeleted(f);
      }
    });
    return true;
  }

  private List<IFile> collectFilesToDelete() {
    String[] pathsToKeep = MapSequence.fromMap(files).where(new IWhereFilter<IMapping<IFile, FilesDelta.Status>>() {
      public boolean accept(IMapping<IFile, FilesDelta.Status> f) {
        return f.value() != FilesDelta.Status.DELETED;
      }
    }).select(new ISelector<IMapping<IFile, FilesDelta.Status>, String>() {
      public String select(IMapping<IFile, FilesDelta.Status> f) {
        return (f.key().isDirectory() ?
          DirUtil.normalizeAsDir(f.key().getPath()) :
          DirUtil.normalize(f.key().getPath())
        );
      }
    }).sort(new ISelector<String, String>() {
      public String select(String p) {
        return p;
      }
    }, true).toListSequence().toGenericArray(String.class);

    List<IFile> filesToDelete = ListSequence.fromList(new ArrayList<IFile>());

    Queue<IFile> dirQueue = QueueSequence.fromQueueAndArray(new LinkedList<IFile>(), rootDir);
    while (QueueSequence.fromQueue(dirQueue).isNotEmpty()) {
      IFile dir = QueueSequence.fromQueue(dirQueue).removeFirstElement();
      String dirpath = DirUtil.normalizeAsDir(dir.getPath());
      int diridx = Arrays.binarySearch(pathsToKeep, dirpath);

      for (Tuples._2<IFile, String> fileAndPath : Sequence.fromIterable(getChildren(dir)).select(new ISelector<IFile, Tuples._2<IFile, String>>() {
        public Tuples._2<IFile, String> select(IFile f) {
          return MultiTuple.<IFile,String>from(f, DirUtil.normalize(f.getPath()));
        }
      }).sort(new ISelector<Tuples._2<IFile, String>, String>() {
        public String select(Tuples._2<IFile, String> t) {
          return t._1();
        }
      }, true)) {
        if (fileAndPath._0().isDirectory()) {
          int fidx = Arrays.binarySearch(pathsToKeep, DirUtil.normalizeAsDir(fileAndPath._1()));
          fidx = (fidx < 0 ?
            -1 - fidx :
            fidx
          );
          if (fidx >= pathsToKeep.length || !(DirUtil.startsWith(pathsToKeep[fidx], fileAndPath._1()))) {
            ListSequence.fromList(filesToDelete).addElement(fileAndPath._0());
            if (fidx >= pathsToKeep.length) {
              break;
            }
          } else if (fidx < pathsToKeep.length) {
            QueueSequence.fromQueue(dirQueue).addLastElement(fileAndPath._0());
          }
        } else {
          int fidx = Arrays.binarySearch(pathsToKeep, fileAndPath._1());
          if (fidx < 0 && diridx < 0) {
            ListSequence.fromList(filesToDelete).addElement(fileAndPath._0());
          }
        }
      }
    }

    return filesToDelete;
  }

  private void cacheGenChildren(IFile dir, IFile cachesDir) {
    List<IFile> genChildren = GeneratorPathsComponent.getInstance().getGeneratedChildren(dir, cachesDir);
    if (ListSequence.fromList(genChildren).isNotEmpty()) {
      MapSequence.fromMap(generatedChildren).put(dir, ListSequence.fromListWithValues(new ArrayList<IFile>(), genChildren));
    }
  }

  private Iterable<IFile> getChildren(IFile dir) {
    Iterable<IFile> realChilren = (Iterable<IFile>) dir.getChildren();
    if (GeneratorPathsComponent.getInstance().isForeign(dir)) {
      List<IFile> genChildren = MapSequence.fromMap(generatedChildren).get(dir);
      return ListSequence.fromList(genChildren).intersect(Sequence.fromIterable(realChilren));
    }
    return realChilren;
  }

  private FilesDelta copy(FilesDelta that) {
    if (DirUtil.startsWith(this.key, that.key)) {
      this.key = that.key;
      this.rootDir = that.rootDir;
    } else if (!(DirUtil.startsWith(that.key, this.key))) {
      throw new IllegalArgumentException();
    }
    MapSequence.fromMap(files).putAll(that.files);
    MapSequence.fromMap(generatedChildren).putAll(that.generatedChildren);
    return this;
  }

  @Override
  public boolean contains(IDelta other) {
    if (!(other instanceof FilesDelta)) {
      return false;
    }
    FilesDelta that = (FilesDelta) other;
    if (that.key.equals(this.key)) {
      return true;
    }
    return DirUtil.startsWith(that.key, this.key);
  }

  public static class Visitor implements IDeltaVisitor {
    public Visitor() {
    }

    public boolean acceptRoot(IFile root) {
      return true;
    }

    public boolean acceptWritten(IFile file) {
      return true;
    }

    public boolean acceptKept(IFile file) {
      return true;
    }

    public boolean acceptDeleted(IFile file) {
      return true;
    }
  }

  public static   enum Status {
    WRITTEN(),
    KEPT(),
    DELETED();

    Status() {
    }
  }
}
