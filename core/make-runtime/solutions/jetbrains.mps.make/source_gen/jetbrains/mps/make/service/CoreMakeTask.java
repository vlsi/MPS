package jetbrains.mps.make.service;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.make.script.IScriptController;
import jetbrains.mps.messages.IMessageHandler;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.progress.ProgressMonitor;
import java.util.Map;
import jetbrains.mps.make.facet.ITarget;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Iterator;
import jetbrains.mps.messages.Message;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.messages.IMessage;
import jetbrains.mps.InternalFlag;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.make.runtime.script.CompositeResult;
import jetbrains.mps.internal.make.runtime.script.Script;
import jetbrains.mps.internal.make.runtime.script.TimeStatisticResource;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.logging.MpsAppenderSkeleton;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.apache.log4j.Priority;
import org.jetbrains.annotations.Nullable;

public class CoreMakeTask {
  private static Logger LOG = LogManager.getLogger(CoreMakeTask.class);
  private IResult myResult = null;
  protected final Iterable<IScript> myScripts;
  protected final String myScrName;
  private final Iterable<? extends Iterable<IResource>> myClInput;
  private final IScriptController myController;
  private final IMessageHandler myMessageHandler;

  public CoreMakeTask(@NotNull String title, Iterable<IScript> scripts, String scrName, Iterable<? extends Iterable<IResource>> clInput, IScriptController ctl, IMessageHandler mh) {
    this.myScripts = scripts;
    this.myScrName = scrName;
    this.myClInput = clInput;
    this.myController = ctl;
    this.myMessageHandler = mh;
  }

  public void run(@NotNull ProgressMonitor monitor) {
    try {
      doRun(monitor);
    } finally {
      try {
        reconcile();
      } catch (RuntimeException ex) {
        LOG.debug("Unexpected exception", ex);
      }
    }
  }

  protected void doRun(ProgressMonitor monitor) {
    final Map<ITarget.Name, Long> timeStatistic = MapSequence.fromMap(new HashMap<ITarget.Name, Long>());

    aboutToStart();
    final int clsize = Sequence.fromIterable(this.myClInput).count();
    if (clsize == 0) {
      return;
    }
    monitor.start("", clsize);
    try {
      int idx = 0;
      Iterator<IScript> scit = Sequence.fromIterable(myScripts).iterator();
      Iterator<? extends Iterable<IResource>> clit = Sequence.fromIterable(myClInput).iterator();
      while (scit.hasNext() && clit.hasNext()) {
        Iterable<IResource> cl = clit.next();
        IScript scr = scit.next();

        if (!(scr.isValid())) {
          String msg = myScrName + " not started: invalid make script";
          myMessageHandler.handle(new Message(MessageKind.ERROR, msg));
          displayInfo(msg);
          for (IMessage err : scr.validationErrors()) {
            myMessageHandler.handle(err);
          }
          this.myResult = new IResult.FAILURE(null);
          break;
        }

        if (InternalFlag.isInternalMode()) {
          myMessageHandler.handle(new Message(MessageKind.INFORMATION, "Modules cluster " + (idx + 1) + "/" + clsize + " [" + IterableUtils.join(Sequence.fromIterable(cl).select(new ISelector<IResource, String>() {
            public String select(IResource r) {
              return (r).describe();
            }
          }), ", ") + "]"));
        }

        monitor.step((idx + 1) + "/" + clsize + " " + IterableUtils.join(Sequence.fromIterable(cl).select(new ISelector<IResource, String>() {
          public String select(IResource r) {
            return (r).describe();
          }
        }), ","));
        this.myResult = scr.execute(this.myController, cl, monitor.subTask(1));
        if (this.myResult instanceof CompositeResult) {
          IResource timeStatResource = Sequence.fromIterable(((CompositeResult) this.myResult).getResult(Script.TIME_STATISTIC_RESULT_NAME).output()).first();
          Map<ITarget.Name, Long> currentStatistic = ((TimeStatisticResource) timeStatResource).getStatistic();
          for (ITarget.Name targetName : SetSequence.fromSet(MapSequence.fromMap(currentStatistic).keySet())) {
            MapSequence.fromMap(timeStatistic).put(targetName, ((MapSequence.fromMap(timeStatistic).containsKey(targetName) ?
              MapSequence.fromMap(timeStatistic).get(targetName) :
              0
            )) + MapSequence.fromMap(currentStatistic).get(targetName));
          }
        }
        if (!(this.myResult.isSucessful()) || monitor.isCanceled()) {
          break;
        }
        idx++;
      }
    } finally {
      long overallTime = Sequence.fromIterable(MapSequence.fromMap(timeStatistic).values()).foldLeft(0L, new ILeftCombinator<Long, Long>() {
        public Long combine(Long s, Long it) {
          return s + it;
        }
      });
      List<ITarget.Name> otherTargets = ListSequence.fromList(new ArrayList<ITarget.Name>());

      long currentTime = 0;
      for (IMapping<ITarget.Name, Long> stat : MapSequence.fromMap(timeStatistic).sort(new ISelector<IMapping<ITarget.Name, Long>, Long>() {
        public Long select(IMapping<ITarget.Name, Long> it) {
          return it.value();
        }
      }, false)) {
        if (currentTime < overallTime * 0.95) {
          LOG.info("\"" + stat.key().name() + "\" target execution time: " + stat.value() + " ms");
          currentTime += stat.value();
        } else {
          ListSequence.fromList(otherTargets).addElement(stat.key());
        }
      }

      LOG.info("Other targets execution time: " + (overallTime - currentTime) + " ms; " + IterableUtils.join(ListSequence.fromList(otherTargets).select(new ISelector<ITarget.Name, String>() {
        public String select(ITarget.Name it) {
          return it.name() + ": " + MapSequence.fromMap(timeStatistic).get(it) + " ms";
        }
      }), ", "));

      monitor.done();
    }
  }

  protected void displayInfo(String info) {
  }

  protected void aboutToStart() {
  }

  protected void reconcile() {
    if (this.myResult == null) {
      String msg = this.myScrName + " aborted";
      displayInfo(msg);
    } else if (!(this.myResult.isSucessful())) {
      String msg = this.myScrName + " failed";
      myMessageHandler.handle(new Message(MessageKind.ERROR, msg + ". See previous messages for details."));
      displayInfo(msg);
    } else {
      String msg = this.myScrName + " successful";
      displayInfo(msg);
    }
  }

  public IMessageHandler getMessageHandler() {
    return myMessageHandler;
  }

  public IResult getResult() {
    return myResult;
  }

  public static class RelayingLoggingHandler extends MpsAppenderSkeleton {
    private static Tuples._2<ThreadGroup, IMessageHandler> GROUP_HANDLER;
    private ThreadLocal<IMessageHandler> messageHandler = new ThreadLocal<IMessageHandler>() {
      @Override
      protected IMessageHandler initialValue() {
        return (CoreMakeTask.RelayingLoggingHandler.GROUP_HANDLER._0() == Thread.currentThread().getThreadGroup() ?
          CoreMakeTask.RelayingLoggingHandler.GROUP_HANDLER._1() :
          null
        );
      }
    };

    public RelayingLoggingHandler(IMessageHandler mh) {
      this.messageHandler.set(mh);
      GROUP_HANDLER = MultiTuple.<ThreadGroup,IMessageHandler>from(Thread.currentThread().getThreadGroup(), mh);
    }

    public void startRelaying() {
      this.register();
    }

    public void stopRelaying() {
      this.unRegister();
    }

    @Override
    protected void append(@NotNull Priority priority, @NotNull String categoryName, @NotNull String messageText, @Nullable Throwable throwable, @Nullable Object object) {
      IMessageHandler mh = messageHandler.get();
      if (mh != null) {
        Message message = new Message(MessageKind.fromPriority(priority), messageText);
        message.setHintObject(object);
        mh.handle(message);
      }
    }
  }
}
