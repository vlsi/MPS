package jetbrains.mps.persistence.java.library;

/*Generated by MPS */

import jetbrains.mps.extapi.model.ReloadableSModelBase;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SModel;
import org.jetbrains.mps.openapi.persistence.ModelRoot;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.extapi.persistence.FolderSetDataSource;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.nodeidmap.ForeignNodeIdMap;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.reloading.CompositeClassPathItem;
import jetbrains.mps.baseLanguage.javastub.ASMModelLoader;
import jetbrains.mps.project.IModule;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.project.ModuleId;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.reloading.ClassPathFactory;
import jetbrains.mps.smodel.SModelStereotype;
import java.io.File;
import java.io.IOException;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.SModelRepository;

public class JavaClassStubModelDescriptor extends ReloadableSModelBase {
  private static final Logger LOG = Logger.getLogger(JavaClassStubModelDescriptor.class);

  private SModel myModel;
  private ModelRoot myModelRoot;

  public JavaClassStubModelDescriptor(SModelReference modelReference, FolderSetDataSource source, ModelRoot root) {
    super(modelReference, source);
    myModelRoot = root;
  }

  @Override
  protected SModel getCurrentModelInternal() {
    return myModel;
  }

  @NotNull
  @Override
  public FolderSetDataSource getSource() {
    return (FolderSetDataSource) super.getSource();
  }

  @Override
  public synchronized SModel getSModelInternal() {
    if (myModel == null) {
      myModel = createModel();
      myModel.setModelDescriptor(this);
      fireModelStateChanged(ModelLoadingState.NOT_LOADED, ModelLoadingState.FULLY_LOADED);
    }
    return myModel;
  }

  @Override
  public boolean isLoaded() {
    return myModel != null;
  }

  private SModel createModel() {
    SModel model = new SModel(getReference(), new ForeignNodeIdMap());
    for (Language l : getLanguagesToImport()) {
      model.addLanguage(l.getModuleReference());
    }
    CompositeClassPathItem cp = createClassPath();
    new ASMModelLoader(((IModule) myModelRoot.getModule()), cp, model.getModelDescriptor(), false).updateModel();
    updateTimestamp();
    return model;
  }

  protected Set<Language> getLanguagesToImport() {
    Set<String> moduleIds = SetSequence.fromSet(new HashSet<String>());
    SetSequence.fromSet(moduleIds).addElement(MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("f3061a53-9226-4cc5-a443-f952ceaf5816")).getModuleReference().getModuleId().toString());
    Iterable<Language> languages = SetSequence.fromSet(moduleIds).select(new ISelector<String, Language>() {
      public Language select(String it) {
        return ((Language) MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString(it)));
      }
    });
    return SetSequence.fromSetWithValues(new HashSet<Language>(), languages);
  }

  private CompositeClassPathItem createClassPath() {
    CompositeClassPathItem cp = new CompositeClassPathItem();
    for (String dir : ((FolderSetDataSource) getSource()).getPaths()) {
      try {
        if (dir.indexOf("!") != -1) {
          cp.add(ClassPathFactory.getInstance().createFromPath(dir.substring(0, dir.indexOf("!")), this.getClass().getName()));
        } else {
          String name = SModelStereotype.withoutStereotype(getReference().getModelName()).replace('.', File.separatorChar);

          // dirty hack for current problems with path separators 
          String dirCorrected = dir.replace('/', File.separatorChar);
          dirCorrected = dirCorrected.replace('\\', File.separatorChar);
          assert dirCorrected.contains(name) : "Strange dir for model: model " + name + "; dir = " + dir;

          int index = dirCorrected.indexOf(name);
          dir = dir.substring(0, index);
          cp.add(ClassPathFactory.getInstance().createFromPath(dir, this.getClass().getName()));
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    return cp;
  }

  @Override
  public void reloadFromDiskSafe() {
    ModelAccess.assertLegalWrite();
    if (getSource().getPaths().isEmpty()) {
      SModelRepository.getInstance().deleteModel(this);
      return;
    }
    reload();
    LOG.assertLog(!(needsReloading()));
  }

  private void reload() {
    if (myModel == null) {
      updateTimestamp();
      return;
    }
    final SModel result = createModel();
    super.replaceModel(new Runnable() {
      @Override
      public void run() {
        myModel = result;
      }
    });
  }


}
