package jetbrains.mps.lang.structure.refactorings;

/*Generated by MPS */

import javax.swing.JScrollPane;
import jetbrains.mps.refactoring.framework.RefactoringContext;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.ide.ThreadUtils;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.hierarchy.ChildHierarchyTreeNode;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.INodeAdapter;
import jetbrains.mps.ide.hierarchy.AbstractHierarchyTree;
import jetbrains.mps.refactoring.framework.ConceptAncestorsProvider;
import jetbrains.mps.lang.core.structure.BaseConcept;
import java.util.Set;
import java.util.HashSet;

public class NodeHierarchyChooser extends JScrollPane {
  private NodeHierarchyChooser.MyHierarchyTree myTree;

  public NodeHierarchyChooser(final RefactoringContext context) {
    super();
    this.myTree = new NodeHierarchyChooser.MyHierarchyTree();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        NodeHierarchyChooser.this.myTree.setHierarchyNode(SNodeOperations.getAncestor(context.getSelectedNode(), "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration", false, false));
      }
    });
    this.setViewportView(this.myTree);
    ThreadUtils.runInUIThreadNoWait(new Runnable() {
      public void run() {
        NodeHierarchyChooser.this.myTree.rebuildNow();
      }
    });
  }

  public SNode getSelectedObject() {
    final ChildHierarchyTreeNode treeNode = (ChildHierarchyTreeNode) myTree.getSelectionPath().getLastPathComponent();
    if (treeNode == null) {
      return null;
    }
    final Wrappers._T<SNode> result = new Wrappers._T<SNode>();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        INodeAdapter nodeAdapter = (INodeAdapter) treeNode.getNode();
        result.value = (nodeAdapter == null ?
          null :
          nodeAdapter.getNode()
        );
      }
    });
    return ((SNode) result.value);
  }

  public static class MyHierarchyTree extends AbstractHierarchyTree<INodeAdapter> {
    private ConceptAncestorsProvider ancestorsProvider;

    public MyHierarchyTree() {
      super(null, INodeAdapter.class, false);
    }

    public void setHierarchyNode(SNode node) {
      this.myHierarchyNode = ((BaseConcept) SNodeOperations.getAdapter(node));
    }

    protected Set<INodeAdapter> getDescendants(INodeAdapter adapter, Set<INodeAdapter> visited) {
      this.ancestorsProvider = new ConceptAncestorsProvider();
      return this.ancestorsProvider.getDescendants(adapter);
    }

    protected INodeAdapter getParent(INodeAdapter adapter) {
      return null;
    }

    protected Set<INodeAdapter> getParents(INodeAdapter adapter, Set<INodeAdapter> visited) {
      return new HashSet();
    }

    protected String noNodeString() {
      return "no node";
    }
  }
}
