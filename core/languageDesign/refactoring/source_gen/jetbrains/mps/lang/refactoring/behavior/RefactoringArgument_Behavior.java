package jetbrains.mps.lang.refactoring.behavior;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.SReference;

public class RefactoringArgument_Behavior {
  public static void init(SNode thisNode) {
  }

  public static boolean call_isTransient_478744034994716004(SNode thisNode) {
    SNode refactoring = SNodeOperations.getAncestor(thisNode, "jetbrains.mps.lang.refactoring.structure.Refactoring", false, false);
    if (!(SNodeOperations.isInstanceOf(refactoring, "jetbrains.mps.lang.refactoring.structure.LoggableRefactoring"))) {
      return true;
    }

    SNode loggableRefactoring = SNodeOperations.cast(refactoring, "jetbrains.mps.lang.refactoring.structure.LoggableRefactoring");
    List<SNode> references = SNodeOperations.getDescendants(SLinkOperations.getTarget(loggableRefactoring, "updateModelBlock", true), "jetbrains.mps.lang.refactoring.structure.RefactoringArgumentReference", false, new String[]{});
    for (SNode reference : references) {
      for (SReference sreference : reference.getReferences()) {
        if (sreference.getTargetNode() == thisNode) {
          return false;
        }
      }
    }
    return true;
  }
}
