package jetbrains.mps.lang.plugin.scripts;

/*Generated by MPS */

import jetbrains.mps.lang.script.runtime.BaseMigrationScript;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.lang.script.runtime.AbstractMigrationRefactoring;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.List;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class FixToolInitAndDispose_MigrationScript extends BaseMigrationScript {
  public FixToolInitAndDispose_MigrationScript(IOperationContext operationContext) {
    super("Fix Tool's Init and Dispose methods");
    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {
      public String getName() {
        return "Fix Tool's Init method";
      }

      public String getAdditionalInfo() {
        return "Fix Tool's Init method";
      }

      public String getFqNameOfConceptToSearchInstances() {
        return "jetbrains.mps.lang.plugin.structure.ProjectPluginInitBlock";
      }

      public boolean isApplicableInstanceNode(SNode node) {
        return (SNodeOperations.getAncestor(node, "jetbrains.mps.lang.plugin.structure.ToolDeclaration", false, false) != null);
      }

      public void doUpdateInstanceNode(SNode node) {
        SNode tool = SNodeOperations.getAncestor(node, "jetbrains.mps.lang.plugin.structure.ToolDeclaration", false, false);

        SNode methodBody = SLinkOperations.getTarget(node, "body", true);
        List<SNode> projectRefs = SNodeOperations.getDescendants(methodBody, "jetbrains.mps.lang.plugin.structure.ConceptFunctionParameter_MPSProject", false, new String[]{});
        {
          SNode projectRef;
          Iterator<SNode> projectRef_iterator = ListSequence.fromList(projectRefs).iterator();
          while (true) {
            if (!(projectRef_iterator.hasNext())) {
              break;
            }
            projectRef = projectRef_iterator.next();
            SNodeOperations.replaceWithNewChild(projectRef, "jetbrains.mps.lang.plugin.structure.ConceptFunctionParameter_Project");
          }
        }

        SNode initBlock = SLinkOperations.setNewChild(tool, "toolInitBlock", "jetbrains.mps.lang.plugin.structure.InitBlock");
        SLinkOperations.setTarget(initBlock, "body", methodBody, true);

        SNodeOperations.deleteNode(node);
      }

      public boolean isShowAsIntention() {
        return true;
      }
    });
    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {
      public String getName() {
        return "Fix Tool's Dispose method";
      }

      public String getAdditionalInfo() {
        return "Fix Tool's Dispose method";
      }

      public String getFqNameOfConceptToSearchInstances() {
        return "jetbrains.mps.lang.plugin.structure.ProjectPluginDisposeBlock";
      }

      public boolean isApplicableInstanceNode(SNode node) {
        return (SNodeOperations.getAncestor(node, "jetbrains.mps.lang.plugin.structure.ToolDeclaration", false, false) != null);
      }

      public void doUpdateInstanceNode(SNode node) {
        SNode tool = SNodeOperations.getAncestor(node, "jetbrains.mps.lang.plugin.structure.ToolDeclaration", false, false);

        SNode methodBody = SLinkOperations.getTarget(node, "body", true);
        List<SNode> projectRefs = SNodeOperations.getDescendants(methodBody, "jetbrains.mps.lang.plugin.structure.ConceptFunctionParameter_MPSProject", false, new String[]{});
        {
          SNode projectRef;
          Iterator<SNode> projectRef_iterator = ListSequence.fromList(projectRefs).iterator();
          while (true) {
            if (!(projectRef_iterator.hasNext())) {
              break;
            }
            projectRef = projectRef_iterator.next();
            SNodeOperations.replaceWithNewChild(projectRef, "jetbrains.mps.lang.plugin.structure.ConceptFunctionParameter_Project");
          }
        }

        SNode disposeBlock = SLinkOperations.setNewChild(tool, "toolDisposeBlock", "jetbrains.mps.lang.plugin.structure.DisposeBlock");
        SLinkOperations.setTarget(disposeBlock, "body", methodBody, true);

        SNodeOperations.deleteNode(node);
      }

      public boolean isShowAsIntention() {
        return true;
      }
    });
  }
}
