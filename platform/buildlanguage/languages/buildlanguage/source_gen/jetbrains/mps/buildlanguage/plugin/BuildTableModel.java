package jetbrains.mps.buildlanguage.plugin;

/*Generated by MPS */

import javax.swing.table.TableModel;
import java.util.List;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Set;
import javax.swing.event.TableModelListener;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.LinkedHashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;
import javax.swing.event.TableModelEvent;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SNodeId;

public class BuildTableModel implements TableModel {
  private static String[] NAMES = {"Script Name" ,"Model" ,"Command Line"};

  private List<SNodePointer> mySNodes = ListSequence.fromList(new ArrayList<SNodePointer>());
  private Map<SNodePointer, String> myCommandLines = MapSequence.fromMap(new HashMap<SNodePointer, String>());
  private final Set<TableModelListener> myListeners = SetSequence.fromSet(new LinkedHashSet<TableModelListener>());

  public BuildTableModel(Map<String, String> data) {
    this.updateStateInternal(loadState(data));
  }

  public void updateState(Map<String, String> data) {
    Map<SNodePointer, String> pointersToMap = loadState(data);
    this.updateStateInternal(pointersToMap);
  }

  private void updateStateInternal(Map<SNodePointer, String> pointersToMap) {
    ListSequence.fromList(this.mySNodes).clear();
    MapSequence.fromMap(this.myCommandLines).clear();
    for(SNodePointer pointer : Sequence.fromIterable(MapSequence.fromMap(pointersToMap).keySet())) {
      ListSequence.fromList(this.mySNodes).addElement(pointer);
      MapSequence.fromMap(this.myCommandLines).put(pointer, pointersToMap.get(pointer));
    }
  }

  public void addTableModelListener(TableModelListener listener) {
    SetSequence.fromSet(this.myListeners).addElement(listener);
  }

  public Class<?> getColumnClass(int column) {
    if (column != 0) {
      return String.class;
    } else
    {
      return SNodePointer.class;
    }
  }

  public int getColumnCount() {
    return NAMES.length;
  }

  public String getColumnName(int p0) {
    return NAMES[p0];
  }

  public int getRowCount() {
    return ListSequence.fromList(this.mySNodes).count();
  }

  public Object getValueAt(int row, int column) {
    final SNodePointer snode = ListSequence.fromList(this.mySNodes).getElement(row);
    if (column == 0) {
      final Wrappers._T<String> name = new Wrappers._T<String>();
      ModelAccess.instance().runReadAction(new Runnable() {

        public void run() {
          name.value = snode.getNode().getName();
        }
      });
      return name.value;
    } else if (column == 1) {
      return snode.getModelReference().getSModelFqName();
    }
    return this.myCommandLines.get(snode);
  }

  public boolean isCellEditable(int row, int column) {
    return column == 2;
  }

  public void removeTableModelListener(TableModelListener listener) {
    SetSequence.fromSet(this.myListeners).removeElement(listener);
  }

  public void setValueAt(Object value, int row, int column) {
    assert column == 2;
    MapSequence.fromMap(this.myCommandLines).put(ListSequence.fromList(this.mySNodes).getElement(row), (String)value);
    this.notifyListeners();
  }

  private void notifyListeners() {
    TableModelEvent event = new TableModelEvent(this);
    for(TableModelListener l : SetSequence.fromSet(this.myListeners)) {
      l.tableChanged(event);
    }
  }

  public Map<String, String> saveState() {
    Map<String, String> mapToSerialize = MapSequence.fromMap(new HashMap<String, String>());
    for(SNodePointer pointer : ListSequence.fromList(this.mySNodes)) {
      MapSequence.fromMap(mapToSerialize).put(pointerToString(pointer), this.myCommandLines.get(pointer));
    }
    return mapToSerialize;
  }


  public static Map<SNodePointer, String> loadState(Map<String, String> state) {
    Map<SNodePointer, String> result = MapSequence.fromMap(new HashMap<SNodePointer, String>());
    if (state == null) {
      return result;
    }
    for(String name : Sequence.fromIterable(MapSequence.fromMap(state).keySet())) {
      SNodePointer pointer = stringToPointer(name);
      if (pointer.getNode() != null) {
        MapSequence.fromMap(result).put(pointer, state.get(name));
      }
    }
    return result;
  }

  private static SNodePointer stringToPointer(String pointerString) {
    String[] split = pointerString.split("#");
    SModelReference smodelId = SModelReference.fromString(split[0]);
    SNodeId id = SNodeId.fromString(split[1]);
    return new SNodePointer(smodelId, id);
  }

  public static String pointerToString(final SNodePointer pointer) {
    final Wrappers._T<String> value = new Wrappers._T<String>();
    ModelAccess.instance().runReadAction(new Runnable() {

      public void run() {
        value.value = pointer.getModel().getSModelReference().toString() + "#" + pointer.getNode().getId();
      }
    });
    return value.value;
  }

}
