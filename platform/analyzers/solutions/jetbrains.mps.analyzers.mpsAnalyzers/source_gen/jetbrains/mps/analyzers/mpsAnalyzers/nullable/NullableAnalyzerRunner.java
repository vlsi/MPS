package jetbrains.mps.analyzers.mpsAnalyzers.nullable;

/*Generated by MPS */

import jetbrains.mps.lang.dataFlow.framework.AnalyzerRunner;
import java.util.Map;
import java.util.List;
import jetbrains.mps.analyzers.runtime.framework.DataFlowConstructor;
import java.util.HashMap;
import jetbrains.mps.smodel.SNode;
import java.util.LinkedList;
import jetbrains.mps.lang.dataFlow.MPSProgramBuilder;
import jetbrains.mps.lang.dataFlow.DataFlowManager;
import jetbrains.mps.lang.dataFlow.framework.DataFlowAnalyzer;
import jetbrains.mps.lang.dataFlow.framework.Program;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.dataFlow.framework.ProgramState;
import jetbrains.mps.lang.dataFlow.framework.instructions.Instruction;
import jetbrains.mps.lang.dataFlow.framework.AnalysisDirection;

public class NullableAnalyzerRunner extends AnalyzerRunner<Map<Object, NullableState>> {
  private Map<String, List<DataFlowConstructor>> myApplicableMap = new HashMap<String, List<DataFlowConstructor>>();
  private SNode myNode;

  public NullableAnalyzerRunner(SNode node) {
    super(null, null);
    myNode = node;
    {
      DataFlowConstructor rule = new RuleNotEqualsNull();
      String conceptName = "jetbrains.mps.baseLanguage.structure.IfStatement";
      if (!(myApplicableMap.containsKey(conceptName))) {
        myApplicableMap.put(conceptName, new LinkedList<DataFlowConstructor>());
      }
      myApplicableMap.get(conceptName).add(rule);
    }
    {
      DataFlowConstructor rule = new RuleNullNotEquals();
      String conceptName = "jetbrains.mps.baseLanguage.structure.IfStatement";
      if (!(myApplicableMap.containsKey(conceptName))) {
        myApplicableMap.put(conceptName, new LinkedList<DataFlowConstructor>());
      }
      myApplicableMap.get(conceptName).add(rule);
    }
    {
      DataFlowConstructor rule = new RuleNotEqualsNullAnd();
      String conceptName = "jetbrains.mps.baseLanguage.structure.IfStatement";
      if (!(myApplicableMap.containsKey(conceptName))) {
        myApplicableMap.put(conceptName, new LinkedList<DataFlowConstructor>());
      }
      myApplicableMap.get(conceptName).add(rule);
    }
    {
      DataFlowConstructor rule = new RuleIfNullReturn();
      String conceptName = "jetbrains.mps.baseLanguage.structure.IfStatement";
      if (!(myApplicableMap.containsKey(conceptName))) {
        myApplicableMap.put(conceptName, new LinkedList<DataFlowConstructor>());
      }
      myApplicableMap.get(conceptName).add(rule);
    }
    {
      DataFlowConstructor rule = new RuleIfNullEqualsReturn();
      String conceptName = "jetbrains.mps.baseLanguage.structure.IfStatement";
      if (!(myApplicableMap.containsKey(conceptName))) {
        myApplicableMap.put(conceptName, new LinkedList<DataFlowConstructor>());
      }
      myApplicableMap.get(conceptName).add(rule);
    }
    myProgram = new MPSProgramBuilder(DataFlowManager.getInstance()).buildProgram(myNode);
    prepareProgram();
    myAnalyzer = new NullableAnalyzerRunner.NullableAnalyzer();
  }

  private void prepareProgram() {
    for (SNode descendant : myNode.getDescendants()) {
      String key = descendant.getConceptFqName();
      if (myApplicableMap.containsKey(key)) {
        for (DataFlowConstructor rule : myApplicableMap.get(key)) {
          if (rule.isApplicable(descendant)) {
            rule.performActions(myProgram);
          }
        }
      }
    }
  }

  public static class NullableAnalyzer implements DataFlowAnalyzer<Map<Object, NullableState>> {
    public NullableAnalyzer() {
    }

    public Map<Object, NullableState> initial(Program program) {
      Map<Object, NullableState> result = new HashMap<Object, NullableState>();
      for (Object var : program.getVariables()) {
        result.put(var, NullableState.UNKNOWN);
      }
      return result;
    }

    public Map<Object, NullableState> merge(Program program, List<Map<Object, NullableState>> input) {
      Map<Object, NullableState> result = new HashMap<Object, NullableState>();
      for (Object var : program.getVariables()) {
        result.put(var, NullableState.UNKNOWN);
      }
      ListSequence.fromList(input).addElement(null);
      for (Object var : ListSequence.fromList(program.getVariables())) {
        for (Map<Object, NullableState> value : ListSequence.fromList(input)) {
          result.put(var, result.get(var).merge(value.get(var)));
        }
      }
      return result;
    }

    public Map<Object, NullableState> fun(Map<Object, NullableState> input, ProgramState state) {
      Map<Object, NullableState> result = new HashMap<Object, NullableState>();
      Instruction instruction = state.getInstruction();
      result.putAll(input);
      if (instruction instanceof notNullInstruction) {
        Object node = instruction.getUserObject("node");
        result.put(node, NullableState.NOTNULL);
      }
      if (instruction instanceof nullableInstruction) {
        Object node = instruction.getUserObject("node");
        result.put(node, NullableState.NULLABLE);
      }
      return result;
    }

    public AnalysisDirection getDirection() {
      return AnalysisDirection.FORWARD;
    }
  }
}
