package jetbrains.mps.baseLanguage.math.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptDescriptor;
import java.util.Arrays;
import jetbrains.mps.smodel.runtime.impl.ConceptDescriptorBuilder;
import jetbrains.mps.smodel.runtime.StaticScope;
import jetbrains.mps.smodel.runtime.interpreted.StructureAspectInterpreted;

public class StructureAspectDescriptor implements jetbrains.mps.smodel.runtime.StructureAspectDescriptor {
  public StructureAspectDescriptor() {
  }
  public ConceptDescriptor getDescriptor(String conceptFqName) {
    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0b, conceptFqName)) {
      case 0:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.AbsExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"expr"}, new boolean[]{false}).alias("abs", "Absolute value of a number").staticScope(StaticScope.NONE).create();
      case 1:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.AbstractIndex").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.baseLanguage.structure.IValidIdentifier").abstract_().create();
      case 2:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ArithmSymbol").super_("jetbrains.mps.baseLanguage.math.structure.MathSymbol").parents("jetbrains.mps.baseLanguage.math.structure.MathSymbol").abstract_().staticScope(StaticScope.NONE).create();
      case 3:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigComplexType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").alias("bigcomplex", "Arbitrary precision complex number").staticScope(StaticScope.NONE).create();
      case 4:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigDecimalType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").alias("bigdecimal", "Arbitrary precision signed decimal number").staticScope(StaticScope.NONE).create();
      case 5:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigIntegerType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").alias("biginteger", "Arbitrary precision integer").staticScope(StaticScope.NONE).create();
      case 6:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigMaxExpression").super_("jetbrains.mps.baseLanguage.math.structure.ExtrSymbol").parents("jetbrains.mps.baseLanguage.math.structure.ExtrSymbol").alias("max", "Maximum of expressions").staticScope(StaticScope.NONE).create();
      case 7:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigMinExpression").super_("jetbrains.mps.baseLanguage.math.structure.ExtrSymbol").parents("jetbrains.mps.baseLanguage.math.structure.ExtrSymbol").alias("min", "Minimum of expressions").staticScope(StaticScope.NONE).create();
      case 8:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigProdExpression").super_("jetbrains.mps.baseLanguage.math.structure.ArithmSymbol").parents("jetbrains.mps.baseLanguage.math.structure.ArithmSymbol").alias("prod", "Product of expressions").staticScope(StaticScope.NONE).create();
      case 9:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.BigSumExpression").super_("jetbrains.mps.baseLanguage.math.structure.ArithmSymbol").parents("jetbrains.mps.baseLanguage.math.structure.ArithmSymbol").alias("sum", "Sum of expressions").staticScope(StaticScope.NONE).create();
      case 10:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ComplexLiteral").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"real", "imag"}, new boolean[]{false, false}).staticScope(StaticScope.NONE).create();
      case 11:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ComplexType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").alias("complex", "Double precision complex number").staticScope(StaticScope.NONE).create();
      case 12:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ConjugateOperation").super_("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").parents("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").alias("", "Matrix conjugate").staticScope(StaticScope.NONE).create();
      case 13:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.CosineExpression").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("cos", "Trigonometric cosine of a value").staticScope(StaticScope.NONE).create();
      case 14:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").super_("jetbrains.mps.baseLanguage.structure.BinaryOperation").parents("jetbrains.mps.baseLanguage.structure.BinaryOperation").children(new String[]{"context"}, new boolean[]{false}).abstract_().staticScope(StaticScope.NONE).create();
      case 15:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DecimalDivExpression").super_("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").parents("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").alias(":/d", "divide operation for big decimal types").staticScope(StaticScope.NONE).create();
      case 16:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DecimalMinusExpression").super_("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").parents("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").alias(":-d", "minus operation for big decimal types").staticScope(StaticScope.NONE).create();
      case 17:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DecimalMulExpression").super_("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").parents("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").alias(":*d", "multiplication operation for big decimal types").staticScope(StaticScope.NONE).create();
      case 18:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DecimalPlusExpression").super_("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").parents("jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation").alias(":+d", "plus operation for bigdecimal types").staticScope(StaticScope.NONE).create();
      case 19:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.Determinant").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("det", "Matrix determinant").staticScope(StaticScope.NONE).create();
      case 20:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.DivExpressionFraction").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"numerator", "denominator"}, new boolean[]{false, false}).alias("frac", "").staticScope(StaticScope.NONE).create();
      case 21:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ExponentExpression").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("exp", "Exponent of a value").staticScope(StaticScope.NONE).create();
      case 22:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ExponentialOperation").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"expr"}, new boolean[]{false}).abstract_().staticScope(StaticScope.NONE).create();
      case 23:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.ExtrSymbol").super_("jetbrains.mps.baseLanguage.math.structure.MathSymbol").parents("jetbrains.mps.baseLanguage.math.structure.MathSymbol").abstract_().staticScope(StaticScope.NONE).create();
      case 24:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.InIntervalExpression").super_("jetbrains.mps.baseLanguage.structure.BinaryOperation").parents("jetbrains.mps.baseLanguage.structure.BinaryOperation").alias(":in:", "is in interval").staticScope(StaticScope.NONE).create();
      case 25:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.IntervalContainsExpression").super_("jetbrains.mps.baseLanguage.structure.BinaryOperation").parents("jetbrains.mps.baseLanguage.structure.BinaryOperation").alias(":contains:", "(?) interval contains").staticScope(StaticScope.NONE).create();
      case 26:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.IntervalLiteral").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").properties("startIncluded", "endIncluded").children(new String[]{"start", "end"}, new boolean[]{false, false}).alias("interval", "Interval literal").staticScope(StaticScope.NONE).create();
      case 27:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.IntervalType").super_("jetbrains.mps.baseLanguage.structure.Type").parents("jetbrains.mps.baseLanguage.structure.Type").children(new String[]{"elementType"}, new boolean[]{false}).alias("interval", "Interval type").staticScope(StaticScope.NONE).create();
      case 28:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.LinearSolveOperation").super_("jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration").parents("jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration").children(new String[]{"type_M", "matrix", "vector", "context"}, new boolean[]{false, false, false, false}).alias("lsolve", "").create();
      case 29:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.LiteralI").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").alias("I", "Imaginary unit").staticScope(StaticScope.NONE).create();
      case 30:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.LogExpression").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("ln", "Natural logarithm of a value").staticScope(StaticScope.NONE).create();
      case 31:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathContext").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept").properties("roundingMode", "precision", "precisionSetting").create();
      case 32:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"param"}, new boolean[]{false}).abstract_().staticScope(StaticScope.NONE).create();
      case 33:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").super_("jetbrains.mps.baseLanguage.structure.Type").parents("jetbrains.mps.baseLanguage.structure.Type").abstract_().staticScope(StaticScope.NONE).create();
      case 34:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathSymbol").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"var", "expression", "precondition", "upperBound"}, new boolean[]{false, false, false, false}).abstract_().staticScope(StaticScope.NONE).create();
      case 35:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathSymbolFromToIndex").super_("jetbrains.mps.baseLanguage.math.structure.AbstractIndex").parents("jetbrains.mps.baseLanguage.math.structure.AbstractIndex").children(new String[]{"from"}, new boolean[]{false}).alias("", "iterate over interval of integers").create();
      case 36:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathSymbolIndex").super_("jetbrains.mps.baseLanguage.math.structure.AbstractIndex").parents("jetbrains.mps.baseLanguage.math.structure.AbstractIndex").children(new String[]{"iterable"}, new boolean[]{false}).alias("", "iterate over arbitrary iterable class").create();
      case 37:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathSymbolIndexReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("indexRef").staticScope(StaticScope.NONE).create();
      case 38:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MathTypeCast").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").properties("target").children(new String[]{"castedExpr"}, new boolean[]{false}).staticScope(StaticScope.NONE).create();
      case 39:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixConstructor").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").properties("column").children(new String[]{"components"}, new boolean[]{true}).alias("[", "Matrix row constructor").staticScope(StaticScope.NONE).create();
      case 40:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixElementAccessExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.lang.core.structure.IDontSubstituteByDefault").children(new String[]{"expression", "rowIndex", "colIndex"}, new boolean[]{false, false, false}).staticScope(StaticScope.NONE).create();
      case 41:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").super_("jetbrains.mps.baseLanguage.math.structure.ExponentialOperation").parents("jetbrains.mps.baseLanguage.math.structure.ExponentialOperation").abstract_().staticScope(StaticScope.NONE).create();
      case 42:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixIndexWildcard").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").alias("*", "Wildcard index").staticScope(StaticScope.NONE).create();
      case 43:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixInitializer").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorInitializer").children(new String[]{"rowIndex", "colIndex", "rowsCount", "colsCount", "expression"}, new boolean[]{false, false, false, false, false}).alias("matrix", "Matrix initializer").staticScope(StaticScope.NONE).create();
      case 44:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixInitializerIndex").super_("jetbrains.mps.lang.core.structure.BaseConcept").parents("jetbrains.mps.lang.core.structure.BaseConcept", "jetbrains.mps.lang.core.structure.INamedConcept", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorInitializer").create();
      case 45:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixInitializerIndexReference").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").references("index").staticScope(StaticScope.NONE).create();
      case 46:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixInverseOperation").super_("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").parents("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").children(new String[]{"context"}, new boolean[]{false}).alias("", "Matrix inverse operation").staticScope(StaticScope.NONE).create();
      case 47:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixNorm").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").properties("deg").children(new String[]{"mat"}, new boolean[]{false}).alias("norm", "").staticScope(StaticScope.NONE).create();
      case 48:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorInitializer").interface_().create();
      case 49:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorType").interface_().create();
      case 50:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorType").properties("rows", "columns").children(new String[]{"elementType"}, new boolean[]{false}).alias("matrix", "").staticScope(StaticScope.NONE).create();
      case 51:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixUnit").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"size"}, new boolean[]{false}).alias("identity", "Identity matrix").staticScope(StaticScope.NONE).create();
      case 52:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.MatrixZero").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").properties("square").children(new String[]{"rows", "columns"}, new boolean[]{false, false}).alias("zero", "Zero matrix").staticScope(StaticScope.NONE).create();
      case 53:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.PowExpression").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression").children(new String[]{"base", "exponent"}, new boolean[]{false, false}).alias("^", "Power expression").staticScope(StaticScope.NONE).create();
      case 54:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.SineExpression").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("sin", "Trigonometric sine of a value").staticScope(StaticScope.NONE).create();
      case 55:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.TangentExpression").super_("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").parents("jetbrains.mps.baseLanguage.math.structure.MathFuncExpression").alias("tan", "Trigonometric tangent of a value").staticScope(StaticScope.NONE).create();
      case 56:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.TransposeOperation").super_("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").parents("jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation").alias("", "Transpose operation").staticScope(StaticScope.NONE).create();
      case 57:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.VectorInitializer").super_("jetbrains.mps.baseLanguage.structure.Expression").parents("jetbrains.mps.baseLanguage.structure.Expression", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorInitializer").children(new String[]{"rowIndex", "expression", "rowsCount"}, new boolean[]{false, false, false}).alias("vector", "Vector initializer").staticScope(StaticScope.NONE).create();
      case 58:
        return new ConceptDescriptorBuilder("jetbrains.mps.baseLanguage.math.structure.VectorType").super_("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType").parents("jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorType").properties("height").children(new String[]{"elementType"}, new boolean[]{false}).alias("vector", "").staticScope(StaticScope.NONE).create();
      default:
        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);
    }
  }
  private static String[] stringSwitchCases_1htk8d_a0a0b = new String[]{"jetbrains.mps.baseLanguage.math.structure.AbsExpression", "jetbrains.mps.baseLanguage.math.structure.AbstractIndex", "jetbrains.mps.baseLanguage.math.structure.ArithmSymbol", "jetbrains.mps.baseLanguage.math.structure.BigComplexType", "jetbrains.mps.baseLanguage.math.structure.BigDecimalType", "jetbrains.mps.baseLanguage.math.structure.BigIntegerType", "jetbrains.mps.baseLanguage.math.structure.BigMaxExpression", "jetbrains.mps.baseLanguage.math.structure.BigMinExpression", "jetbrains.mps.baseLanguage.math.structure.BigProdExpression", "jetbrains.mps.baseLanguage.math.structure.BigSumExpression", "jetbrains.mps.baseLanguage.math.structure.ComplexLiteral", "jetbrains.mps.baseLanguage.math.structure.ComplexType", "jetbrains.mps.baseLanguage.math.structure.ConjugateOperation", "jetbrains.mps.baseLanguage.math.structure.CosineExpression", "jetbrains.mps.baseLanguage.math.structure.DecimalBinaryOperation", "jetbrains.mps.baseLanguage.math.structure.DecimalDivExpression", "jetbrains.mps.baseLanguage.math.structure.DecimalMinusExpression", "jetbrains.mps.baseLanguage.math.structure.DecimalMulExpression", "jetbrains.mps.baseLanguage.math.structure.DecimalPlusExpression", "jetbrains.mps.baseLanguage.math.structure.Determinant", "jetbrains.mps.baseLanguage.math.structure.DivExpressionFraction", "jetbrains.mps.baseLanguage.math.structure.ExponentExpression", "jetbrains.mps.baseLanguage.math.structure.ExponentialOperation", "jetbrains.mps.baseLanguage.math.structure.ExtrSymbol", "jetbrains.mps.baseLanguage.math.structure.InIntervalExpression", "jetbrains.mps.baseLanguage.math.structure.IntervalContainsExpression", "jetbrains.mps.baseLanguage.math.structure.IntervalLiteral", "jetbrains.mps.baseLanguage.math.structure.IntervalType", "jetbrains.mps.baseLanguage.math.structure.LinearSolveOperation", "jetbrains.mps.baseLanguage.math.structure.LiteralI", "jetbrains.mps.baseLanguage.math.structure.LogExpression", "jetbrains.mps.baseLanguage.math.structure.MathContext", "jetbrains.mps.baseLanguage.math.structure.MathFuncExpression", "jetbrains.mps.baseLanguage.math.structure.MathPrimitiveType", "jetbrains.mps.baseLanguage.math.structure.MathSymbol", "jetbrains.mps.baseLanguage.math.structure.MathSymbolFromToIndex", "jetbrains.mps.baseLanguage.math.structure.MathSymbolIndex", "jetbrains.mps.baseLanguage.math.structure.MathSymbolIndexReference", "jetbrains.mps.baseLanguage.math.structure.MathTypeCast", "jetbrains.mps.baseLanguage.math.structure.MatrixConstructor", "jetbrains.mps.baseLanguage.math.structure.MatrixElementAccessExpression", "jetbrains.mps.baseLanguage.math.structure.MatrixExponentialOperation", "jetbrains.mps.baseLanguage.math.structure.MatrixIndexWildcard", "jetbrains.mps.baseLanguage.math.structure.MatrixInitializer", "jetbrains.mps.baseLanguage.math.structure.MatrixInitializerIndex", "jetbrains.mps.baseLanguage.math.structure.MatrixInitializerIndexReference", "jetbrains.mps.baseLanguage.math.structure.MatrixInverseOperation", "jetbrains.mps.baseLanguage.math.structure.MatrixNorm", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorInitializer", "jetbrains.mps.baseLanguage.math.structure.MatrixOrVectorType", "jetbrains.mps.baseLanguage.math.structure.MatrixType", "jetbrains.mps.baseLanguage.math.structure.MatrixUnit", "jetbrains.mps.baseLanguage.math.structure.MatrixZero", "jetbrains.mps.baseLanguage.math.structure.PowExpression", "jetbrains.mps.baseLanguage.math.structure.SineExpression", "jetbrains.mps.baseLanguage.math.structure.TangentExpression", "jetbrains.mps.baseLanguage.math.structure.TransposeOperation", "jetbrains.mps.baseLanguage.math.structure.VectorInitializer", "jetbrains.mps.baseLanguage.math.structure.VectorType"};
}
