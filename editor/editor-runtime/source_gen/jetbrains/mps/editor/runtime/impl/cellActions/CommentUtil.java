package jetbrains.mps.editor.runtime.impl.cellActions;

/*Generated by MPS */

import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import java.util.Iterator;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.AttributeOperations;

public class CommentUtil {
  private CommentUtil() {
  }
  /**
   * 
   * 
   * @param node node to comment. This node must have parent
   * @throws IllegalArgumentException if node does not have parent
   */
  @NotNull
  public static SNode commentOut(@NotNull SNode node) {
    SNode parent = SNodeOperations.getParent(node);
    if (parent == null) {
      throw new IllegalArgumentException("Node to comment has no parent. Node: " + ((String) BHReflection.invoke(node, SMethodTrimmedId.create("getPresentation", null, "hEwIMiw"))) + " Node id: " + node.getNodeId());
    }
    SContainmentLink containmentLink = node.getContainmentLink();
    assert containmentLink != null;
    SNode newComment = CommentUtil.createAndInsertNewComment(parent, containmentLink, node);
    SAbstractConcept targetConcept = containmentLink.getTargetConcept();
    if (!(containmentLink.isMultiple()) && !(containmentLink.isOptional())) {
      parent.addChild(containmentLink, NodeFactoryManager.createNode(targetConcept, null, parent, SNodeOperations.getModel(parent)));
    }
    return newComment;
  }


  /**
   * 
   * 
   * @param attribute attribute containing commented node. This node must have parent
   * @throws IllegalArgumentException if attribute has no parent   
   */
  public static SNode uncomment(@NotNull SNode attribute) {
    SNode parent = SNodeOperations.getParent(attribute);
    if (parent == null) {
      throw new IllegalArgumentException("Node to uncomment has no parent. Node: " + ((String) BHReflection.invoke(attribute, SMethodTrimmedId.create("getPresentation", null, "hEwIMiw"))) + " Node id: " + attribute.getNodeId());
    }
    SContainmentLink containmentLink = ((SContainmentLink) BHReflection.invoke(attribute, SMethodTrimmedId.create("getLink", MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x9d98713f247885aL, "jetbrains.mps.lang.core.structure.ChildAttribute"), "BpxLfMirzf")));
    SNode commentedNode = SLinkOperations.getTarget(attribute, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, 0x2ab99f0d2248e89dL, "commentedNode"));
    if (containmentLink != null) {
      if (!(containmentLink.isMultiple())) {
        SNode currentChild = ListSequence.fromList(SNodeOperations.getChildren(parent, containmentLink)).first();
        if ((currentChild != null)) {
          if (currentChild.getConcept().isAbstract()) {
            SNodeOperations.deleteNode(currentChild);
          } else {
            createAndInsertNewComment(parent, containmentLink, currentChild);
          }
        }
      }
      if (commentedNode != null) {
        attribute.removeChild(commentedNode);
        insertNodeNearComment(parent, attribute, containmentLink, commentedNode);
      }
    }
    SNodeOperations.deleteNode(attribute);
    return commentedNode;
  }
  @NotNull
  private static SNode createAndInsertNewComment(SNode parent, SContainmentLink containmentLink, SNode anchor) {
    SNode newComment = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute")));
    insertInProperPlace(parent, anchor, containmentLink, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute"), newComment);
    BHReflection.invoke(newComment, SMethodTrimmedId.create("setLink", MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x9d98713f247885aL, "jetbrains.mps.lang.core.structure.ChildAttribute"), "BpxLfMirzM"), containmentLink);
    SLinkOperations.setTarget(newComment, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, 0x2ab99f0d2248e89dL, "commentedNode"), anchor);
    return newComment;
  }


  private static void insertNodeNearComment(SNode parent, SNode anchorComment, SContainmentLink linkToInsert, SNode nodeToInsert) {
    insertInProperPlace(parent, anchorComment, linkToInsert, linkToInsert, nodeToInsert);
  }

  private static void insertInProperPlace(SNode parent, SNode anchor, SContainmentLink anchorLink, SContainmentLink linkToInsert, SNode newChild) {
    SNode prev = getPrevious(parent, anchor, anchorLink);
    SNode next = getNext(parent, anchor, anchorLink);
    if (prev != null) {
      parent.insertChildAfter(linkToInsert, newChild, prev);
    } else if (next != null) {
      parent.insertChildBefore(linkToInsert, newChild, next);
    } else {
      parent.addChild(linkToInsert, newChild);
    }
  }



  private static SNode getPrevious(SNode parent, SNode anchor, SContainmentLink containmentLink) {
    Iterator<SNode> iterator = Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(parent, containmentLink)).iterator();
    SNode prev = null;
    SNode next;
    while (iterator.hasNext()) {
      next = iterator.next();
      if (next == anchor) {
        return prev;
      }
      prev = next;
    }
    return null;
  }
  private static SNode getNext(SNode parent, SNode anchor, SContainmentLink containmentLink) {
    Iterator<SNode> iterator = Sequence.fromIterable(AttributeOperations.getChildNodesAndAttributes(parent, containmentLink)).iterator();
    while (iterator.hasNext()) {
      SNode next = iterator.next();
      if (next == anchor) {
        if (iterator.hasNext()) {
          return iterator.next();
        }
      }
    }
    return null;
  }
  public static boolean isComment(SNode node) {
    return SNodeOperations.isInstanceOf(node, MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute"));
  }
  public static SNode getCommentedNode(SNode comment) {
    return SLinkOperations.getTarget(comment, MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, 0x2ab99f0d2248e89dL, "commentedNode"));
  }
}
