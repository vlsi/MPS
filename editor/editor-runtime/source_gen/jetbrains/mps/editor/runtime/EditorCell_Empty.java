package jetbrains.mps.editor.runtime;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.cells.EditorCell_Basic;
import jetbrains.mps.openapi.editor.cells.optional.WithCaret;
import jetbrains.mps.editor.runtime.cells.CaretState;
import jetbrains.mps.nodeEditor.cells.TextLine;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.model.SNode;
import java.awt.Graphics;
import jetbrains.mps.nodeEditor.cells.ParentSettings;
import jetbrains.mps.editor.runtime.style.StyleAttributes;
import jetbrains.mps.editor.runtime.style.Padding;
import java.awt.event.KeyEvent;
import jetbrains.mps.openapi.editor.cells.CellActionType;
import jetbrains.mps.editor.runtime.commands.EditorCommand;
import jetbrains.mps.openapi.editor.cells.CellAction;
import jetbrains.mps.nodeEditor.sidetransform.EditorCell_STHint;
import jetbrains.mps.editor.runtime.style.StyleAttributesUtil;

public class EditorCell_Empty extends EditorCell_Basic implements WithCaret {
  private CaretState myCaretState = new CaretState();
  protected TextLine myTextLine = new TextLine("", getStyle(), false);

  public EditorCell_Empty(EditorContext c, SNode node) {
    super(c, node);
    myTextLine.setCaretEnabled(true);
  }

  @Override
  protected void paintContent(Graphics g, ParentSettings parentSettings) {
    myTextLine.setShowCaret(myCaretState.isVisible() && isWithinSelection() && getEditor().hasFocus());
    myTextLine.paint(g, myX + myGapLeft, myY);
  }

  public void repaintCaret() {
    myTextLine.repaintCaret(getEditor(), getX() + getLeftGap(), getY());
  }

  @Override
  public void switchCaretVisible() {
    myCaretState.tick();
    repaintCaret();
  }

  @Override
  public void setCaretVisible(boolean visible) {
    myCaretState.touch(visible);
    repaintCaret();
  }

  @Override
  protected boolean isSelectionPainted() {
    return false;
  }

  @Override
  public int getAscent() {
    return myTextLine.getAscent();
  }

  @Override
  public int getDescent() {
    return myTextLine.getDescent();
  }

  @Override
  protected void relayoutImpl() {
    if (isPunctuationLayout()) {
      getStyle().set(StyleAttributes.PADDING_LEFT, new Padding(0.0));
      getStyle().set(StyleAttributes.PADDING_RIGHT, new Padding(0.0));
    }
    myTextLine.relayout();
    myHeight = myTextLine.getHeight();
    myWidth = myTextLine.getWidth();
  }

  @Override
  protected boolean doProcessKeyTyped(final KeyEvent event, boolean allowErrors) {
    final EditorContext editorContext = getContext();
    if (!(isTextTypedEvent(event))) {
      return false;
    }

    myCaretState.touch();
    repaintCaret();
    final CellActionType actionType;
    if (isFirstCaretPosition()) {
      actionType = CellActionType.LEFT_TRANSFORM;
    } else if (isLastCaretPosition()) {
      actionType = CellActionType.RIGHT_TRANSFORM;
    } else {
      return true;
    }

    editorContext.getRepository().getModelAccess().executeCommand(new EditorCommand(editorContext) {
      protected void doExecute() {
        CellAction ltAction = editorContext.getEditorComponent().getActionHandler().getApplicableCellAction(EditorCell_Empty.this, actionType);
        ltAction.execute(editorContext);
        EditorCell_STHint stHintCell = EditorCell_STHint.getSTHintCell(getSNode(), getEditorComponent());
        if (stHintCell != null) {
          stHintCell.changeText("" + event.getKeyChar());
          stHintCell.end();
        }
      }
    });
    return true;
  }

  @Override
  public boolean isLastCaretPosition() {
    return StyleAttributesUtil.isLastPositionAllowed(getStyle()) && !(StyleAttributesUtil.isFirstPositionAllowed(getStyle()));
  }

  @Override
  public boolean isFirstCaretPosition() {
    return StyleAttributesUtil.isFirstPositionAllowed(getStyle()) && !(StyleAttributesUtil.isLastPositionAllowed(getStyle()));
  }

  @Override
  public void setSelected(boolean selected) {
    super.setSelected(selected);
    myCaretState.touch(selected);
  }
}
