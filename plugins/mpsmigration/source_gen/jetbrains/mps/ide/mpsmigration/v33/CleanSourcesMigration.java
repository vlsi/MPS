package jetbrains.mps.ide.mpsmigration.v33;

/*Generated by MPS */

import jetbrains.mps.migration.global.BaseProjectMigration;
import jetbrains.mps.migration.global.ProjectMigrationWithOptions;
import jetbrains.mps.migration.global.CleanupProjectMigration;
import jetbrains.mps.project.Project;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.classloading.ClassLoaderManager;
import jetbrains.mps.progress.EmptyProgressMonitor;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.project.AbstractModule;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.facets.TestsFacet;
import jetbrains.mps.generator.fileGenerator.FileGenerationUtil;
import org.jetbrains.mps.openapi.module.SearchScope;
import jetbrains.mps.lang.smodel.query.runtime.CommandUtil;
import jetbrains.mps.lang.smodel.query.runtime.QueryExecutionContext;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.project.Solution;
import jetbrains.mps.project.DevKit;
import jetbrains.mps.project.facets.JavaModuleFacet;
import jetbrains.mps.vfs.ex.IFileEx;

public class CleanSourcesMigration extends BaseProjectMigration implements ProjectMigrationWithOptions, CleanupProjectMigration {
  public static final String OPTION_REMOVE_SOURCES = "jetbrains.mps.removeSources";
  public static final String ID = "jetbrains.mps.cleanSrc_3.3";

  private boolean mySources = false;

  public CleanSourcesMigration() {
    super(CleanSourcesMigration.ID);
  }

  public void forceExecutionNextTime(Project p) {
    setExecuted(p, false);
  }

  @Override
  public String getDescription() {
    return "Clean Generated " + ((mySources ? "Sources" : "Classes"));
  }

  @Override
  public boolean doExecute(Project p) {
    removeGeneratedFiles(mySources, p);
    return true;
  }

  @Override
  public Collection<String> getOptionIds() {
    return Collections.singleton(CleanSourcesMigration.OPTION_REMOVE_SOURCES);
  }

  @Override
  public void setOptionValues(Map<String, Object> values) {
    Object b = values.get(CleanSourcesMigration.OPTION_REMOVE_SOURCES);
    assert b instanceof Boolean;
    mySources = ((Boolean) b);
  }

  public static void removeGeneratedFiles(final boolean sources, final Project p) {
    ApplicationManager.getApplication().runWriteAction(new Runnable() {
      public void run() {
        if (sources) {
          removeGenSources(p);
        }

        // clean genclasses 
        removeClassesGen(p);
      }
    });
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());
      }
    });
  }

  /**
   * todo. Was originally copied from IdeCommandUtil, then changed. Check whether they could 
   * be combined into one piece of universal code
   */
  private static void removeGenSources(Project p) {
    Iterable<SModule> modulesToClean;
    Sequence.fromIterable(getModulesForCleanup(p)).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        IFile outputDir = it.getOutputPath();
        IFile testDir = check_jwqyzj_a0b0a0a1a91(it.getFacet(TestsFacet.class));
        if (outputDir != null) {
          IFile cacheDir = FileGenerationUtil.getCachesDir(outputDir);
          refreshAndDelete(outputDir);
          refreshAndDelete(cacheDir);
        }
        if (testDir != null) {
          IFile testCacheDir = FileGenerationUtil.getCachesDir(testDir);
          refreshAndDelete(testDir);
          refreshAndDelete(testCacheDir);
        }
      }
    });
  }

  private static Iterable<SModule> getModulesForCleanup(Project p) {
    {
      final SearchScope scope = CommandUtil.createScope(p);
      QueryExecutionContext context = new QueryExecutionContext() {
        public SearchScope getDefaultSearchScope() {
          return scope;
        }
      };
      return Sequence.fromIterable(CommandUtil.modules(CommandUtil.createConsoleScope(null, false, context))).where(new IWhereFilter<SModule>() {
        public boolean accept(SModule it) {
          return !((Solution.isBootstrapSolution(it.getModuleReference()))) && !((it instanceof DevKit));
        }
      });
    }
  }

  private static void removeClassesGen(Project p) {
    Sequence.fromIterable(getModulesForCleanup(p)).ofType(AbstractModule.class).visitAll(new IVisitor<AbstractModule>() {
      public void visit(AbstractModule it) {
        IFile classesGen = check_jwqyzj_a0a0a0a0a32(it.getFacet(JavaModuleFacet.class));
        refreshAndDelete(classesGen);
      }
    });
  }

  /**
   * Workaround for output locations that are exposed in SModule/SModuleFacet API as IFile, but are
   * populated through java.io.File and hence might not be up to date here.
   * E.g. ModuleMaker compiles classes of a module with sources only into brand new classes_gen. When CleanSourcesMigration tries to remove classes_gen after project re-open, 
   * it fails to find VFS file of JavaModuleFacet.getClassesGen which doesn't exist and hence is not removed. Then, language classes get loaded from this location (despite the 
   * use of VFS file to build module classpath (see JavaModuleFacetImpl.getClassPath(), it's only name of un-existing VFS file being used), and migration fails as it uses stale LanguageRuntime classes.
   * @see https://youtrack.jetbrains.com/issue/MPS-21303
   */
  private static void refreshAndDelete(IFile f) {
    if (f == null) {
      return;
    }
    if (f instanceof IFileEx) {
      ((IFileEx) f).refresh();
    }
    f.delete();
  }
  private static IFile check_jwqyzj_a0b0a0a1a91(TestsFacet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getTestsOutputPath();
    }
    return null;
  }
  private static IFile check_jwqyzj_a0a0a0a0a32(JavaModuleFacet checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getClassesGen();
    }
    return null;
  }
}
