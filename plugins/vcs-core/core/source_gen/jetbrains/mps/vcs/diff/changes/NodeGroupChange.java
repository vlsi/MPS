package jetbrains.mps.vcs.diff.changes;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNodeId;
import java.util.List;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.vcs.diff.ChangeSet;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.util.NameUtil;

public class NodeGroupChange extends ModelChange {
  private SNodeId myParentNodeId;
  private String myRole;
  private int myBegin;
  private int myEnd;
  private int myResultBegin;
  private int myResultEnd;
  private List<SNodeId> myPreparedIdsToDelete = null;
  private SNodeId myPreparedAnchorId = null;

  public NodeGroupChange(@NotNull ChangeSet changeSet, @NotNull SNodeId parentNodeId, @NotNull String role, int begin, int end, int resultBegin, int resultEnd) {
    super(changeSet);
    myParentNodeId = parentNodeId;
    myRole = role;
    myBegin = begin;
    myEnd = end;
    myResultBegin = resultBegin;
    myResultEnd = resultEnd;
  }

  @NotNull
  public SNodeId getParentNodeId() {
    return myParentNodeId;
  }

  @NotNull
  public String getRole() {
    return myRole;
  }

  public int getBegin() {
    return myBegin;
  }

  public int getEnd() {
    return myEnd;
  }

  public int getResultEnd() {
    return myResultEnd;
  }

  public int getResultBegin() {
    return myResultBegin;
  }

  public void prepare() {
    if (myPreparedIdsToDelete == null) {
      SNode parent = getChangeSet().getOldModel().getNode(myParentNodeId);
      assert parent != null;

      List<? extends SNode> children = IterableUtil.asList(parent.getChildren(myRole));
      myPreparedIdsToDelete = ListSequence.fromList(new ArrayList<SNodeId>());
      for (int i = myBegin; i < myEnd; i++) {
        ListSequence.fromList(myPreparedIdsToDelete).addElement(children.get(i).getNodeId());
      }
      myPreparedAnchorId = (myBegin == 0 ?
        null :
        children.get(myBegin - 1).getNodeId()
      );
    }
  }

  @Override
  public void apply(@NotNull final SModel model, @NotNull NodeCopier nodeCopier) {
    // delete old nodes 
    prepare();
    ListSequence.fromList(myPreparedIdsToDelete).visitAll(new IVisitor<SNodeId>() {
      public void visit(SNodeId id) {
        model.getNode(id).delete();
      }
    });
    myPreparedIdsToDelete = null;

    // copy nodes to insert 
    List<SNode> nodesToAdd = ListSequence.fromList(new ArrayList<SNode>());
    List<? extends SNode> newChildren = IterableUtil.asList(getChangeSet().getNewModel().getNode(myParentNodeId).getChildren(myRole));
    for (int i = myResultBegin; i < myResultEnd; i++) {
      ListSequence.fromList(nodesToAdd).addElement(nodeCopier.copyNode(newChildren.get(i)));
    }

    // insert new nodes 
    SNode anchor = (myPreparedAnchorId == null ?
      null :
      model.getNode(myPreparedAnchorId)
    );
    SNode parent = model.getNode(myParentNodeId);
    for (SNode newNode : ListSequence.fromList(nodesToAdd).reversedList()) {
      parent.insertChild(myRole, newNode, anchor);
    }
  }

  @Nullable
  @Override
  public SNodeId getRootId() {
    return getChangeSet().getOldModel().getNode(myParentNodeId).getContainingRoot().getNodeId();
  }

  @NotNull
  @Override
  public ChangeType getType() {
    if (myBegin == myEnd) {
      return ChangeType.ADD;
    }
    if (myResultBegin == myResultEnd) {
      return ChangeType.DELETE;
    }
    return ChangeType.CHANGE;
  }

  @Override
  public String toString() {
    if (myEnd == myBegin) {
      return String.format("Insert %s into position #%d in role %s of node %s", nodeRange(myResultBegin, myResultEnd), myBegin, myRole, myParentNodeId);
    }
    if (myResultEnd == myResultBegin) {
      return String.format("Delete %s in role %s of node %s", nodeRange(myBegin, myEnd), myRole, myParentNodeId);
    }
    return String.format("Replace %s with nodes %s in role %s of node %s", nodeRange(myBegin, myEnd), nodeRange(myResultBegin, myResultEnd), myRole, myParentNodeId);
  }

  @Override
  public String getDescription() {
    return getDescription(true);
  }

  public String getDescription(boolean verbose) {
    List<? extends SNode> newChildren = null;
    String newIds = null;
    if (verbose) {
      newChildren = IterableUtil.asList(getChangeSet().getNewModel().getNode(myParentNodeId).getChildren(myRole));
      newIds = IterableUtils.join(ListSequence.fromList(newChildren).page(myResultBegin, myResultEnd).select(new ISelector<SNode, String>() {
        public String select(SNode n) {
          return "#" + n.getNodeId();
        }
      }), ", ");
    }

    String oldStuff = (myEnd - myBegin == 1 ?
      myRole :
      NameUtil.formatNumericalString(myEnd - myBegin, myRole)
    );
    String newStuff = (myResultEnd - myResultBegin == 1 ?
      myRole :
      NameUtil.formatNumericalString(myResultEnd - myResultBegin, myRole)
    );
    if (eq_yjf6x2_a0a6a12(newStuff, myRole) && eq_yjf6x2_a0a6a12_0(oldStuff, myRole)) {
      newStuff = "another";
    } else if (myEnd != myBegin) {
      newStuff = "another " + newStuff;
    }
    if (myEnd == myBegin) {
      if (verbose) {
        String addedOrInserted = (myResultEnd == (int) ListSequence.fromList(newChildren).count() ?
          "Added" :
          "Inserted"
        );
        return String.format("%s %s: %s", addedOrInserted, newStuff, newIds);
      } else {
        return String.format("Added %s", newStuff);
      }
    }
    if (myResultEnd == myResultBegin) {
      return String.format("Removed %s", oldStuff);
    }
    if (verbose) {
      return String.format("Replaced %s with %s: %s", oldStuff, newStuff, newIds);
    } else {
      return String.format("Replaced %s with %s", oldStuff, newStuff);
    }
  }

  @NotNull
  @Override
  protected ModelChange createOppositeChange() {
    return new NodeGroupChange(getChangeSet().getOppositeChangeSet(), myParentNodeId, myRole, myResultBegin, myResultEnd, myBegin, myEnd);
  }

  private static String nodeRange(int begin, int end) {
    return (begin + 1 == end ?
      String.format("node #%d", begin) :
      String.format("nodes #%d-%d", begin, end - 1)
    );
  }

  private static boolean eq_yjf6x2_a0a6a12(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }

  private static boolean eq_yjf6x2_a0a6a12_0(Object a, Object b) {
    return (a != null ?
      a.equals(b) :
      a == b
    );
  }
}
