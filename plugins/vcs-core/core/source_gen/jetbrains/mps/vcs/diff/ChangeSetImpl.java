package jetbrains.mps.vcs.diff;

/*Generated by MPS */

import jetbrains.mps.smodel.SModel;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import java.util.concurrent.CopyOnWriteArrayList;
import org.jetbrains.annotations.NotNull;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class ChangeSetImpl implements ChangeSet {
  private final SModel myOldModel;
  private final SModel myNewModel;
  private final List<ModelChange> myModelChanges = new CopyOnWriteArrayList<ModelChange>();
  private ChangeSetImpl myOppositeChangeSet = null;

  public ChangeSetImpl(@NotNull SModel oldModel, @NotNull SModel newModel) {
    myOldModel = oldModel;
    myNewModel = newModel;
  }

  @NotNull
  public List<ModelChange> getModelChanges() {
    return Collections.unmodifiableList(myModelChanges);
  }

  public void clear() {
    ListSequence.fromList(myModelChanges).clear();
  }

  @NotNull
  public <C extends ModelChange> Iterable<C> getModelChanges(final Class<C> changeClass) {
    return ListSequence.fromList(myModelChanges).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return changeClass.isInstance(ch);
      }
    }).select(new ISelector<ModelChange, C>() {
      public C select(ModelChange ch) {
        return (C) ch;
      }
    });
  }

  @NotNull
  public SModel getOldModel() {
    return myOldModel;
  }

  @NotNull
  public SModel getNewModel() {
    return myNewModel;
  }

  @NotNull
  public ChangeSet getOppositeChangeSet() {
    if (myOppositeChangeSet == null) {
      throw new IllegalStateException("opposite chage set is not built");
    }

    return myOppositeChangeSet;
  }

  public void clearOppositeChangeSet() {
    myOppositeChangeSet = null;
  }

  public void buildOppositeChangeSet() {
    if (myOppositeChangeSet == null) {
      ModelAccess.assertLegalRead();

      myOppositeChangeSet = new ChangeSetImpl(myNewModel, myOldModel);
      myOppositeChangeSet.myOppositeChangeSet = this;

      ListSequence.fromList(myOppositeChangeSet.myModelChanges).addSequence(ListSequence.fromList(myModelChanges).select(new ISelector<ModelChange, ModelChange>() {
        public ModelChange select(ModelChange c) {
          return c.getOppositeChange();
        }
      }));
    }
  }

  public void add(@NotNull ModelChange change) {
    ListSequence.fromList(myModelChanges).addElement(change);
    if (myOppositeChangeSet != null) {
      ListSequence.fromList(myOppositeChangeSet.myModelChanges).addElement(change.getOppositeChange());
    }
  }

  public void remove(@NotNull ModelChange change) {
    ListSequence.fromList(myModelChanges).removeElement(change);
    if (myOppositeChangeSet != null) {
      ListSequence.fromList(myOppositeChangeSet.myModelChanges).removeElement(change.getOppositeChange());
    }
  }

  public void addAll(Iterable<? extends ModelChange> changes) {
    ListSequence.fromList(myModelChanges).addSequence(Sequence.fromIterable(changes));
    if (myOppositeChangeSet != null) {
      ListSequence.fromList(myOppositeChangeSet.myModelChanges).addSequence(Sequence.fromIterable(changes).select(new ISelector<ModelChange, ModelChange>() {
        public ModelChange select(ModelChange c) {
          return c.getOppositeChange();
        }
      }));
    }
  }
}
