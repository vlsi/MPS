package jetbrains.mps.vcs.core.mergedriver;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.make.java.ModelDependencies;
import java.io.ByteArrayOutputStream;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.io.IOException;
import org.jdom.JDOMException;
import jetbrains.mps.util.JDOMUtil;
import java.io.OutputStream;
import org.jdom.Document;
import jetbrains.mps.make.java.RootDependencies;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;

/*package*/ class JavaDependenciesMerger extends AbstractContentMerger {
  /*package*/ JavaDependenciesMerger() {
  }

  @Nullable
  @Override
  public Tuples._2<Integer, byte[]> mergeContents(FileContent baseContent, FileContent localContent, FileContent latestContent) {
    try {
      ModelDependencies dependencies = loadDependencies(baseContent);
      copyDependencies(loadDependencies(localContent), dependencies);
      copyDependencies(loadDependencies(latestContent), dependencies);

      ByteArrayOutputStream out = new ByteArrayOutputStream();
      saveDependencies(dependencies, out);
      return MultiTuple.<Integer,byte[]>from(MERGED, out.toByteArray());
    } catch (IOException e) {
      e.printStackTrace();
      return null;
    } catch (JDOMException e) {
      e.printStackTrace();
      return null;
    } catch (JavaDependenciesMerger.MergeException e) {
      e.printStackTrace();
      return null;
    }
  }

  private static ModelDependencies loadDependencies(FileContent content) throws IOException, JDOMException {
    return ModelDependencies.fromXml(JDOMUtil.loadDocument(content.openInputStream()).getRootElement());
  }

  private static void saveDependencies(ModelDependencies deps, OutputStream out) throws IOException {
    JDOMUtil.writeDocument(new Document(deps.toXml()), out);
  }

  private static void copyDependencies(ModelDependencies from, ModelDependencies to) throws JavaDependenciesMerger.MergeException {
    for (RootDependencies fromRootDep : Sequence.fromIterable(from.getDependencies())) {
      RootDependencies toRootDep = to.getDependency(fromRootDep.getFileName());
      if (toRootDep == null) {
        to.addDependencies(fromRootDep);
      } else {
        to.replaceRoot(mergeRootDependencies(fromRootDep, toRootDep));
      }
    }
  }

  private static RootDependencies mergeRootDependencies(RootDependencies rd1, RootDependencies rd2) throws JavaDependenciesMerger.MergeException {
    if (neq_bqsatu_a0a0f(rd1.getClassName(), rd2.getClassName())) {
      throw new JavaDependenciesMerger.MergeException("Different class names: " + rd1.getClassName() + " and " + rd2.getClassName());
    }
    Set<String> dependNodes = rd1.getDependencies();
    SetSequence.fromSet(dependNodes).addSequence(SetSequence.fromSet(rd2.getDependencies()));
    Set<String> extendsNodes = rd1.getExtends();
    SetSequence.fromSet(extendsNodes).addSequence(SetSequence.fromSet(rd2.getExtends()));
    return new RootDependencies(rd1.getClassName(), rd1.getFileName(), SetSequence.fromSet(dependNodes).toListSequence(), SetSequence.fromSet(extendsNodes).toListSequence());
  }

  private static class MergeException extends Exception {
    private MergeException(String msg) {
      super(msg);
    }
  }

  private static boolean neq_bqsatu_a0a0f(Object a, Object b) {
    return !((a != null ?
      a.equals(b) :
      a == b
    ));
  }
}
