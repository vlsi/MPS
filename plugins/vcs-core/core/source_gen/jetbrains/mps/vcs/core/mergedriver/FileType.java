package jetbrains.mps.vcs.core.mergedriver;

/*Generated by MPS */

import jetbrains.mps.project.MPSExtentions;
import java.util.regex.Pattern;
import org.jetbrains.annotations.Nullable;
import java.io.File;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.util.FileUtil;
import java.io.Reader;
import java.io.InputStreamReader;
import java.io.FileInputStream;
import java.io.IOException;

public enum FileType {
  MODEL_ROOT(MPSExtentions.MODEL_ROOT, "(<\\?.*\\?>)?[^<]*<model\\s[^>]*content=\"?root\"?.*"),
  MODEL_HEADER(MPSExtentions.MODEL_HEADER, "(<\\?.*\\?>)?[^<]*<model\\s[^>]*content=\"?header\"?.*"),
  MODEL(MPSExtentions.MODEL, "(<\\?.*\\?>)?[^<]*<model[>\\s].*"),
  LANGUAGE(MPSExtentions.LANGUAGE, "(<\\?.*\\?>)?[^<]*<language[>\\s].*"),
  SOLUTION(MPSExtentions.SOLUTION, "(<\\?.*\\?>)?[^<]*<solution[>\\s].*"),
  DEVKIT(MPSExtentions.DEVKIT, "(<\\?.*\\?>)?[^<]*<dev-kit[>\\s].*"),
  PROJECT(MPSExtentions.IDEA_PROJECT, "(<\\?.*\\?>)?[^<]*<project[>\\s].*"),
  TRACE_CACHE("trace.info", "(<\\?.*\\?>)?[^<]*<debugInfo[>\\s].*"),
  GENERATOR_DEPENDENCIES("generated", "(<\\?.*\\?>)?[^<]*<dependencies[>\\s].*"),
  JAVA_DEPENDENCIES("dependencies", "(<\\?.*\\?>)?[^<]*<dependenciesRoot[>\\s].*");


  public static final FileType[] BY_NAME = {FileType.TRACE_CACHE, FileType.GENERATOR_DEPENDENCIES, FileType.JAVA_DEPENDENCIES};
  public static final FileType[] BY_EXT = {FileType.LANGUAGE, FileType.SOLUTION, FileType.DEVKIT, FileType.PROJECT, FileType.MODEL_ROOT, FileType.MODEL_HEADER, FileType.MODEL};
  private static final String SVN_BASE = ".svn-base";

  private String mySuffix;
  private Pattern myPattern;

  FileType(String suffix, String pattern) {
    mySuffix = suffix;
    myPattern = Pattern.compile(pattern, Pattern.MULTILINE | Pattern.DOTALL);
  }



  public String getSuffix() {
    return mySuffix;
  }

  public static FileType get(@Nullable final String filetype, File file) {
    if (filetype != null) {
      FileType type = Sequence.fromIterable(Sequence.fromArray(FileType.values())).findFirst(new IWhereFilter<FileType>() {
        public boolean accept(FileType t) {
          return filetype.equals(t.mySuffix);
        }
      });
      if (type != null) {
        return type;
      }
      if (PersistenceFacade.getInstance().getModelFactoryExtensions().contains(filetype)) {
        return FileType.MODEL;
      }
    }
    // try get file type from SVN filename 
    final Wrappers._T<String> fileName = new Wrappers._T<String>(file.getName());
    if (fileName.value.endsWith(SVN_BASE)) {
      fileName.value = fileName.value.substring(0, fileName.value.length() - FileType.SVN_BASE.length());
      FileType type = Sequence.fromIterable(Sequence.fromArray(FileType.values())).findFirst(new IWhereFilter<FileType>() {
        public boolean accept(FileType t) {
          return fileName.value.endsWith(t.mySuffix);
        }
      });
      if (type != null) {
        return type;
      }
      if (PersistenceFacade.getInstance().getModelFactoryExtensions().contains(FileUtil.getExtension(fileName.value))) {
        return FileType.MODEL;
      }
    }
    // try to get file type by the beginning of content 
    char[] buf = new char[1000];
    Reader reader = null;
    try {
      reader = new InputStreamReader(new FileInputStream(file), FileUtil.DEFAULT_CHARSET);
      int read = reader.read(buf);
      if (read == -1) {
        return null;
      }
      final String str = new String(buf, 0, read);
      return Sequence.fromIterable(Sequence.fromArray(FileType.values())).findFirst(new IWhereFilter<FileType>() {
        public boolean accept(FileType t) {
          return t.myPattern.matcher(str).matches();
        }
      });
    } catch (IOException ioe) {
      return null;
    } finally {
      FileUtil.closeFileSafe(reader);
    }
  }
}
