package jetbrains.mps.vcspersistence;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.persistence.def.IModelPersistence;
import jetbrains.mps.smodel.persistence.def.v4.ModelPersistence4;
import jetbrains.mps.smodel.persistence.def.v5.ModelPersistence5;
import jetbrains.mps.smodel.persistence.def.v6.ModelPersistence6;
import jetbrains.mps.smodel.persistence.def.v7.ModelPersistence7;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import jetbrains.mps.smodel.SModelHeader;
import org.jetbrains.mps.openapi.persistence.StreamDataSource;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import java.io.InputStream;
import org.xml.sax.InputSource;
import java.io.InputStreamReader;
import jetbrains.mps.util.FileUtil;
import java.io.IOException;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.extapi.persistence.FileDataSource;
import java.util.Map;
import jetbrains.mps.smodel.loading.ModelLoadResult;
import jetbrains.mps.smodel.loading.ModelLoadingState;
import jetbrains.mps.smodel.persistence.def.PersistenceVersionNotFoundException;
import jetbrains.mps.util.xml.XMLSAXHandler;
import jetbrains.mps.smodel.persistence.def.v4.IPersistenceWithReader;
import jetbrains.mps.smodel.persistence.def.v4.IModelReader;
import org.jdom.Document;
import jetbrains.mps.smodel.SModel;
import java.util.List;
import jetbrains.mps.smodel.persistence.lines.LineContent;
import java.io.StringReader;
import jetbrains.mps.util.JDOMUtil;
import org.jdom.JDOMException;
import jetbrains.mps.smodel.DefaultSModel;
import jetbrains.mps.vfs.IFile;
import jetbrains.mps.project.MPSExtentions;
import jetbrains.mps.vfs.FileSystem;
import jetbrains.mps.smodel.persistence.def.DefaultMetadataPersistence;
import org.xml.sax.helpers.DefaultHandler;
import jetbrains.mps.util.xml.BreakParseSAXException;
import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.SAXException;
import org.xml.sax.Attributes;
import jetbrains.mps.smodel.persistence.def.v9.ModelPersistence9;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.util.StringUtil;

/**
 * This is old persistences support for version control purposes. 
 * It's desirable to be possible to see diff and merge with models in very old persistences, which MPS can't fully 
 * support because of changes to SModel. 
 * For VCS purposes, what is needed is to show the model to the user in a state, which is near to how this model 
 * looked in the interested revision. So, while we can't read all the information into new SModel, we can still try to 
 * create a new SModel from an old "model state".
 * 
 * The persistences here 
 * 1. should not be fully-functional. 
 * 2. can use any hacks to "load" the model. 
 * 3. must "load" the SModel in "new format" (as if they were save by the last persistence, see below)
 * 
 * E.g. if in some persistence we had only names of node's concepts, we are still able to remove SConceptByName in newer 
 * MPS versions. The persistences here can use in-repo or even in-structure-models search to obtain concept ids for 
 * names it has. It doesn't matter, how. It must not work under any circumstances. It must not produce the exact vision
 * of the old model. It MUST produce a new SModel. 
 * (??? [Mihail Muhin] isn't it better to produce model with persistence version set to LAST_VERSION?)
 */
public class VCSPersistenceSupport {
  private static final Logger LOG = LogManager.getLogger(VCSPersistenceSupport.class);
  public static final String TARGET_NODE_ID = "targetNodeId";
  public static final String LINK = "link";
  public static final String ROLE = "role";
  public static final String NAME = "name";
  public static final String NAMESPACE = "namespace";
  public static final String NODE = "node";
  public static final String TYPE = "type";
  public static final String ID = "id";
  public static final String RESOLVE_INFO = "resolveInfo";
  public static final String MODEL = "model";
  public static final String PROPERTY = "property";
  public static final String VALUE = "value";
  public static final String IMPORT_ELEMENT = "import";
  public static final String VISIBLE_ELEMENT = "visible";
  public static final String MODEL_IMPORT_INDEX = "index";
  public static final String LANGUAGE = "language";
  public static final String LANGUAGE_ASPECT = "languageAspect";
  public static final String LANGUAGE_ENGAGED_ON_GENERATION = "language-engaged-on-generation";
  public static final String DEVKIT = "devkit";
  public static final String MODEL_UID = "modelUID";
  public static final String VERSION = "version";
  public static final String IMPLICIT = "implicit";
  public static final String ROOTS = "roots";
  public static final String ROOT_CONTENT = "root";
  public static final String PERSISTENCE = "persistence";
  public static final String PERSISTENCE_VERSION = "version";

  @Nullable
  private static IModelPersistence getPersistence(int version) {
    // Assert here was replaced with LOG.error before 3.3 as we've found a couple  
    // places where this incompatibility with older version introduced new bugs 
    // Actually, these places must be fixed (see e.g. MPS-22503). Still, we  
    // leave error here till 3.4 or later to minimize the number of real issues [MM] 
    if (version < 4) {
      LOG.error("unsupported version requested " + version, new Throwable());
    }

    if (version == 4) {
      return new ModelPersistence4();
    }
    if (version == 5) {
      return new ModelPersistence5();
    }
    if (version == 6) {
      return new ModelPersistence6();
    }
    if (version == 7) {
      return new ModelPersistence7();
    }

    // todo remove this after removing usages of VCSPersistenceSupport from everywhere except VCSPersistenceUtil 
    return ModelPersistence.getPersistence(version);
  }

  private static void loadDescriptor(SModelHeader result, StreamDataSource dataSource) throws ModelReadException {
    InputStream in = null;
    try {
      in = dataSource.openInputStream();
      InputSource source = new InputSource(new InputStreamReader(in, FileUtil.DEFAULT_CHARSET));
      parseAndHandleExceptions(source, new VCSPersistenceSupport.MyDescriptorHandler(result), "model descriptor");
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read descriptor from " + dataSource.getLocation() + ": " + e.getMessage(), e);
    } finally {
      FileUtil.closeFileSafe(in);
    }
  }

  @NotNull
  public static SModelHeader loadDescriptor(InputSource source) throws IOException {
    SModelHeader result = new SModelHeader();
    parseAndHandleExceptions(source, new VCSPersistenceSupport.MyDescriptorHandler(result), "model descriptor");
    return result;
  }

  @NotNull
  public static SModelHeader loadDescriptor(StreamDataSource source) throws ModelReadException {
    final SModelHeader result = new SModelHeader();
    loadDescriptor(result, source);
    // for old persistences try to load header from metadata 
    if (result.getPersistenceVersion() < 7 && source instanceof FileDataSource) {
      Map<String, String> metadata = loadMetadata(((FileDataSource) source).getFile());
      if (metadata != null) {
        if (metadata.containsKey(SModelHeader.DO_NOT_GENERATE)) {
          result.setDoNotGenerate(Boolean.parseBoolean(metadata.remove(SModelHeader.DO_NOT_GENERATE)));
        }
      }
    }
    return result;
  }

  private static ModelLoadResult readModel(@NotNull SModelHeader header, @NotNull InputSource source, ModelLoadingState state) throws IOException, ModelReadException {
    IModelPersistence mp = getPersistence(header.getPersistenceVersion());
    if (header.getPersistenceVersion() < 0) {
      throw new ModelReadException("Couldn't read model because of unknown persistence version", null);
    }

    String m = "Can not find appropriate persistence version for model " + header.getModelReference() + "\n Use newer version of JetBrains MPS to load this model.";
    if (mp == null) {
      throw new PersistenceVersionNotFoundException(m);
    }

    // first try to use SAX parser 
    XMLSAXHandler<ModelLoadResult> handler = mp.getModelReaderHandler(state, header);
    if (handler != null) {
      parseAndHandleExceptions(source, handler, "model");
      final ModelLoadResult result = handler.getResult();
      // in case persistence version could change during IModelPersistence activities, might need to update header: 
      // header.setPersistenceVersion(mp.getVersion()); 
      return result;
    }

    // then try to use DOM reader 
    if (!(mp instanceof IPersistenceWithReader)) {
      throw new PersistenceVersionNotFoundException(m);
    }
    IModelReader reader = ((IPersistenceWithReader) mp).getModelReader();
    if (reader == null) {
      throw new PersistenceVersionNotFoundException(m);
    }

    Document document = loadModelDocument(source);
    return new ModelLoadResult((SModel) reader.readModel(document, header), ModelLoadingState.FULLY_LOADED);
  }

  @NotNull
  public static ModelLoadResult readModel(@NotNull SModelHeader header, @NotNull StreamDataSource dataSource, ModelLoadingState state) throws ModelReadException {
    InputStream in = null;
    try {
      in = dataSource.openInputStream();
      InputSource source = new InputSource(new InputStreamReader(in, FileUtil.DEFAULT_CHARSET));
      return readModel(header, source, state);
    } catch (IOException e) {
      throw new ModelReadException("Couldn't read model: " + e.getMessage(), e, header);
    } finally {
      FileUtil.closeFileSafe(in);
    }
  }

  @Nullable
  public static List<LineContent> getLineToContentMap(String content) throws ModelReadException {
    try {
      SModelHeader header;
      header = loadDescriptor(new InputSource(new StringReader(content)));
      IModelPersistence mp = getPersistence(header.getPersistenceVersion());
      if (mp == null) {
        return null;
      }

      XMLSAXHandler<List<LineContent>> handler = mp.getLineToContentMapReaderHandler();
      if (handler == null) {
        return null;
      }

      parseAndHandleExceptions(new InputSource(new StringReader(content)), handler, "line to content map");
      return handler.getResult();
    } catch (IOException ex) {
      throw new ModelReadException(ex.toString(), ex);
    }

  }
  @NotNull
  private static Document loadModelDocument(@NotNull InputSource source) throws IOException {
    try {
      return JDOMUtil.loadDocument(source);
    } catch (JDOMException e) {
      throw new IOException("Exception on loading model from " + source, e);
    }
  }

  @NotNull
  public static DefaultSModel readModel(@NotNull final StreamDataSource source, boolean interfaceOnly) throws ModelReadException {
    SModelHeader header = loadDescriptor(source);
    ModelLoadingState state = (interfaceOnly ? ModelLoadingState.INTERFACE_LOADED : ModelLoadingState.FULLY_LOADED);
    return (DefaultSModel) readModel(header, source, state).getModel();
  }

  @NotNull
  public static DefaultSModel readModel(@NotNull final String content, boolean interfaceOnly) throws ModelReadException {
    try {
      SModelHeader header = loadDescriptor(new InputSource(new StringReader(content)));
      ModelLoadingState state = (interfaceOnly ? ModelLoadingState.INTERFACE_LOADED : ModelLoadingState.FULLY_LOADED);
      return (DefaultSModel) readModel(header, new InputSource(new StringReader(content)), state).getModel();
    } catch (IOException ex) {
      throw new ModelReadException(ex.toString(), ex);
    }
  }

  @Nullable
  private static Map<String, String> loadMetadata(IFile modelFile) {
    String modelPath = modelFile.getPath();
    String versionPath = modelPath.substring(0, modelPath.length() - MPSExtentions.DOT_MODEL.length()) + ".metadata";
    IFile metadataFile = FileSystem.getInstance().getFileByPath(versionPath);
    if (!(metadataFile.exists())) {
      return null;
    }
    return DefaultMetadataPersistence.load(metadataFile);
  }

  /*package*/ static void parseAndHandleExceptions(InputSource source, DefaultHandler handler, String what) throws IOException {
    try {
      JDOMUtil.createSAXParser().parse(source, handler);
    } catch (BreakParseSAXException e) {
      // used to break SAX parsing flow  
    } catch (ParserConfigurationException e) {
      LOG.error(e.toString(), e);
      throw new IOException(String.format("Couldn't read %s: %s", what, e.getMessage()), e);
    } catch (SAXException e) {
      throw new IOException(String.format("Couldn't read %s: %s", what, e.getMessage()), e);
    }
  }

  private static class MyDescriptorHandler extends DefaultHandler {
    private final SModelHeader myResult;
    public MyDescriptorHandler(SModelHeader result) {
      myResult = result;
    }
    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
      if (VCSPersistenceSupport.MODEL.equals(qName)) {
        for (int idx = 0; idx < attributes.getLength(); idx++) {
          String name = attributes.getQName(idx);
          String value = attributes.getValue(idx);
          if (VCSPersistenceSupport.MODEL_UID.equals(name) || ModelPersistence9.REF.equals(name)) {
            final SModelReference mr = (value == null ? null : PersistenceFacade.getInstance().createModelReference(value));
            myResult.setModelReference(mr);
          } else
          if (SModelHeader.DO_NOT_GENERATE.equals(name)) {
            myResult.setDoNotGenerate(Boolean.parseBoolean(value));
          } else
          if ("version".equals(name)) {
            // old model version 
          } else {
            myResult.setOptionalProperty(name, StringUtil.unescapeXml(value));
          }
        }
      } else
      if (VCSPersistenceSupport.PERSISTENCE.equals(qName)) {
        String s = attributes.getValue(VCSPersistenceSupport.PERSISTENCE_VERSION);
        if (s != null) {
          try {
            myResult.setPersistenceVersion(Integer.parseInt(s));
          } catch (NumberFormatException ignored) {
          }
        }
      } else
      if ("attribute".equals(qName)) {
        myResult.setOptionalProperty(attributes.getValue(VCSPersistenceSupport.NAME), attributes.getValue(VCSPersistenceSupport.VALUE));
      } else {
        throw new BreakParseSAXException();
      }
    }
    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {
      throw new BreakParseSAXException();
    }
  }
}
