package jetbrains.mps.ide.modelchecker.actions;

/*Generated by MPS */

import jetbrains.mps.workbench.action.BaseAction;
import javax.swing.Icon;
import com.intellij.openapi.actionSystem.AnActionEvent;
import java.util.Map;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.actionSystem.CommonDataKeys;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.ide.actions.MPSCommonDataKeys;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.ide.modelchecker.platform.actions.ModelCheckerTool;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.behaviour.BHReflection;
import jetbrains.mps.core.aspects.behaviour.SMethodTrimmedId;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Arrays;
import java.util.Comparator;

public class FindReferencesToNonReferenceable_Action extends BaseAction {
  private static final Icon ICON = null;
  public FindReferencesToNonReferenceable_Action() {
    super("Find References to non-referenceable concepts", "", ICON);
    this.setIsAlwaysVisible(false);
    this.setExecuteOutsideCommand(true);
  }
  @Override
  public boolean isDumbAware() {
    return true;
  }
  @Override
  public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {
    // todo: temporary disabled, see MPS-18470 
    return false;
  }
  @Override
  public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {
    this.setEnabledState(event.getPresentation(), this.isApplicable(event, _params));
  }
  @Override
  protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {
    if (!(super.collectActionData(event, _params))) {
      return false;
    }
    {
      Project p = event.getData(CommonDataKeys.PROJECT);
      MapSequence.fromMap(_params).put("project", p);
      if (p == null) {
        return false;
      }
    }
    {
      MPSProject p = event.getData(MPSCommonDataKeys.MPS_PROJECT);
      MapSequence.fromMap(_params).put("mpsProject", p);
      if (p == null) {
        return false;
      }
    }
    return true;
  }
  @Override
  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {
    final List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) ((MPSProject) MapSequence.fromMap(_params).get("mpsProject")).getProjectModels())).where(new IWhereFilter<SModel>() {
      public boolean accept(SModel md) {
        return SModelStereotype.isUserModel(md);
      }
    }));

    ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get("project"))).checkModelsAndShowResult(modelDescriptors, new ReferenceableConceptsChecker());

    // extra debug 
    final Wrappers._int total = new Wrappers._int();
    final Wrappers._int referenceable = new Wrappers._int();
    final Map<String, Integer> used = MapSequence.fromMap(new HashMap<String, Integer>());

    ((MPSProject) MapSequence.fromMap(_params).get("mpsProject")).getModelAccess().runReadAction(new Runnable() {
      public void run() {
        ListSequence.fromList(modelDescriptors).visitAll(new IVisitor<SModel>() {
          public void visit(SModel it) {
            for (SNode n : it.getRootNodes()) {
              for (SNode i : SNodeOperations.getNodeDescendants(n, null, true, new SAbstractConcept[]{})) {
                SNode ccp = SNodeOperations.asConcept(SNodeOperations.getConceptDeclaration(i), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, "jetbrains.mps.lang.structure.structure.ConceptDeclaration"));
                if (ccp != null) {
                  total.value++;
                  if (!(SPropertyOperations.hasValue(ccp, MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0x4b014033eedc8a48L, "staticScope"), "none", null))) {
                    referenceable.value++;
                    String cname = ((String) BHReflection.invoke(ccp, SMethodTrimmedId.create("getFqName", null, "hEwIO9y")));
                    if (MapSequence.fromMap(used).containsKey(cname)) {
                      MapSequence.fromMap(used).put(cname, MapSequence.fromMap(used).get(cname) + 1);
                    } else {
                      MapSequence.fromMap(used).put(cname, 1);
                    }
                  }
                }
              }
            }
          }
        });
      }
    });
    String[] usedNames = SetSequence.fromSet(MapSequence.fromMap(used).keySet()).toGenericArray(String.class);
    Arrays.sort(usedNames, new Comparator<String>() {
      public int compare(String a, String b) {
        return new Integer(MapSequence.fromMap(used).get(a)).compareTo(MapSequence.fromMap(used).get(b));
      }
    });
    System.out.println("" + referenceable.value + " out of " + total.value + " nodes are referenceable");
    for (String s : usedNames) {
      System.out.println(MapSequence.fromMap(used).get(s) + "  " + s);
    }
  }
}
