package jetbrains.mps.ide.modelchecker.actions;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.IOperationContext;
import java.util.List;
import jetbrains.mps.project.IModule;
import jetbrains.mps.progress.ProgressMonitor;
import jetbrains.mps.ide.ThreadUtils;
import java.awt.Frame;
import com.intellij.openapi.progress.TaskInfo;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.ide.findusages.model.IResultProvider;
import jetbrains.mps.ide.findusages.view.FindUtils;
import jetbrains.mps.ide.findusages.model.SearchQuery;
import jetbrains.mps.ide.findusages.model.holders.ModulesHolder;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.NonNls;
import com.intellij.openapi.progress.ProgressIndicator;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.EmptyProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import com.intellij.openapi.command.CommandProcessorEx;
import com.intellij.openapi.command.CommandProcessor;
import com.intellij.openapi.command.UndoConfirmationPolicy;
import com.intellij.openapi.application.ex.ApplicationManagerEx;
import javax.swing.SwingUtilities;
import jetbrains.mps.project.MPSProject;

public class ModelCheckerExecutor {
  private Project project;
  private IOperationContext context;
  private List<IModule> modules;

  public ModelCheckerExecutor(List<IModule> modules, IOperationContext context, Project project) {
    this.project = project;
    this.context = context;
    this.modules = modules;
  }

  public void execImmediately(ProgressMonitor promon) {
    ThreadUtils.assertEDT();
    Runnable process = createProcess(false, promon);
    process.run();
  }

  public void execAsCommand(Frame frame) {
    ThreadUtils.assertEDT();
    TaskInfo task = createTaskInfo();
    final Object cmd = startCommand(task);
    Runnable process = createProcess(true, null);
    Runnable afterFinish = new Runnable() {
      @Override
      public void run() {
        ModelAccess.instance().runCommandInEDT(new Runnable() {
          @Override
          public void run() {
            finishCommand(cmd);
          }
        }, getMPSProject());
      }
    };
    primExec(task, process, afterFinish, frame);
  }

  private Runnable createProcess(final boolean spawnCommands, final ProgressMonitor monitor) {
    return new Runnable() {
      @Override
      public void run() {
        IResultProvider resultProvider = FindUtils.makeProvider(new ModelCheckerIssueFinder() {
          @Override
          protected List<SpecificChecker> getSpecificCheckers() {
            return getMySpecificCheckers();
          }
        });
        final ProgressMonitor promon = getOrCreateProgressMonitor(monitor);
        promon.start("Executing Model Fixes", 200);

        SearchQuery searchQuery = new SearchQuery(new ModulesHolder(modules, context), getMPSProject().getScope());
        SearchResults searchResults = FindUtils.getSearchResults(promon.subTask(100), searchQuery, resultProvider);
        searchResults.removeDuplicates();

        List<ModelCheckerIssue> issuesToFix = ListSequence.fromList(((List<SearchResult<ModelCheckerIssue>>) searchResults.getSearchResults())).select(new ISelector<SearchResult<ModelCheckerIssue>, ModelCheckerIssue>() {
          public ModelCheckerIssue select(SearchResult<ModelCheckerIssue> sr) {
            return sr.getObject();
          }
        }).where(new IWhereFilter<ModelCheckerIssue>() {
          public boolean accept(ModelCheckerIssue sro) {
            return sro instanceof ModelCheckerIssue.NodeIssue && sro.isFixable();
          }
        }).toListSequence();


        ModelCheckerController controller = new ModelCheckerController() {
          @Override
          public void runCommand(Runnable cmd) {
            if (spawnCommands) {
              ModelAccess.instance().runCommandInEDT(cmd, getMPSProject());
            } else {
              cmd.run();
            }
          }
        };
        controller.process(promon.subTask(100), issuesToFix);

        promon.done();
      }
    };
  }

  protected List<SpecificChecker> getMySpecificCheckers() {
    List<SpecificChecker> specificCheckers = ListSequence.fromList(new ArrayList<SpecificChecker>());
    ListSequence.fromList(specificCheckers).addElement(new UnavailableConceptsChecker());
    ListSequence.fromList(specificCheckers).addElement(new ModelPropertiesChecker());
    ListSequence.fromList(specificCheckers).addElement(new UnresolvedReferencesChecker());
    return specificCheckers;
  }

  private TaskInfo createTaskInfo() {
    return new TaskInfo() {
      @NotNull
      @Override
      public String getTitle() {
        return "Checking models";
      }

      @Override
      public String getCancelText() {
        return null;
      }

      @Override
      public String getCancelTooltipText() {
        return null;
      }

      @Override
      public boolean isCancellable() {
        return false;
      }

      @NonNls
      @Override
      public String getProcessId() {
        return "model checker";
      }
    };
  }

  private ProgressMonitor getOrCreateProgressMonitor(ProgressMonitor promon) {
    if (promon != null) {
      return promon;
    }
    ProgressIndicator prind = ProgressManager.getInstance().getProgressIndicator();
    prind = (prind != null ?
      prind :
      new EmptyProgressIndicator()
    );
    return new ProgressMonitorAdapter(prind);
  }

  private void primExec(TaskInfo task, final Runnable proc, final Runnable afterFinish, Frame frame) {
    Runnable process = new Runnable() {
      @Override
      public void run() {
        proc.run();
        if (afterFinish != null) {
          afterFinish.run();
        }
      }
    };
    execAsync(process, task, frame);
  }

  private Object startCommand(TaskInfo task) {
    return ((CommandProcessorEx) CommandProcessor.getInstance()).startCommand(project, task.getTitle(), null, UndoConfirmationPolicy.REQUEST_CONFIRMATION);
  }

  private void finishCommand(Object cmd) {
    ((CommandProcessorEx) CommandProcessor.getInstance()).finishCommand(project, cmd, null);
  }

  private void execAsync(Runnable process, TaskInfo task, Frame frame) {
    ApplicationManagerEx.getApplicationEx().runProcessWithProgressSynchronously(process, task.getTitle(), task.isCancellable(), project, SwingUtilities.getRootPane(frame));
  }

  private MPSProject getMPSProject() {
    return project.getComponent(MPSProject.class);
  }
}
