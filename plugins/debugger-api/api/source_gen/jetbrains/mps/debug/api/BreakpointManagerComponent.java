package jetbrains.mps.debug.api;

/*Generated by MPS */

import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.components.ProjectComponent;
import com.intellij.openapi.components.PersistentStateComponent;
import org.jdom.Element;
import jetbrains.mps.logging.Logger;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.util.Set;
import jetbrains.mps.debug.api.breakpoints.ILocationBreakpoint;
import java.util.HashMap;
import jetbrains.mps.debug.api.breakpoints.IBreakpoint;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.ListIterator;
import jetbrains.mps.util.Computable;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.Nullable;

@State(name = "BreakpointManager", storages = {@Storage(id = "other", file = "$WORKSPACE_FILE$")
})
public class BreakpointManagerComponent implements ProjectComponent, PersistentStateComponent<Element> {
  private static final Logger LOG = Logger.getLogger(BreakpointManagerComponent.class);
  private static final String BREAKPOINTS_LIST_ELEMENT = "breakpointsList";
  private static final BreakpointManagerComponent.DummyIO DUMMY_IO = new BreakpointManagerComponent.DummyIO();
  private final Map<SNodeReference, Set<ILocationBreakpoint>> myRootsToBreakpointsMap = new HashMap<SNodeReference, Set<ILocationBreakpoint>>();
  private boolean myBreakpointsForRootInitialized = false;
  private final Set<IBreakpoint> myBreakpoints = new HashSet<IBreakpoint>();
  private final List<Element> myUnreadBreakpoints = new ArrayList<Element>();
  private BreakpointManagerComponent.IBreakpointsIO myBreakpointsIO = DUMMY_IO;
  private final List<BreakpointManagerComponent.IBreakpointManagerListener> myListeners = new ArrayList<BreakpointManagerComponent.IBreakpointManagerListener>();

  public BreakpointManagerComponent() {
  }

  @NotNull
  @Override
  public String getComponentName() {
    return "Breakpoint Manager";
  }

  @Override
  public void projectOpened() {
  }

  @Override
  public void projectClosed() {
  }

  @Override
  public void initComponent() {
  }

  @Override
  public void disposeComponent() {
    myBreakpointsIO = null;
    //  dispose 
  }

  public void setBreakpointsIO(BreakpointManagerComponent.IBreakpointsIO io) {
    myBreakpointsIO = io;
    reReadState();
  }

  public void addBreakpoint(@NotNull final IBreakpoint breakpoint) {
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        synchronized (myBreakpoints) {
          if (breakpoint instanceof ILocationBreakpoint && myBreakpointsForRootInitialized) {
            addLocationBreakpoint((ILocationBreakpoint) breakpoint);
          }
          breakpoint.setCreationTime(System.currentTimeMillis());
          myBreakpoints.add(breakpoint);
          breakpoint.addToRunningSessions();
        }
      }
    });
    fireBreakpointAdded(breakpoint);
  }

  private void addLocationBreakpoint(ILocationBreakpoint breakpoint) {
    SNode node = breakpoint.getLocation().getSNode();
    if (node != null) {
      SNodeReference rootPointer = new jetbrains.mps.smodel.SNodePointer(node.getContainingRoot());
      Set<ILocationBreakpoint> breakpointsForRoot = myRootsToBreakpointsMap.get(rootPointer);
      if (breakpointsForRoot == null) {
        breakpointsForRoot = new HashSet<ILocationBreakpoint>();
        myRootsToBreakpointsMap.put(rootPointer, breakpointsForRoot);
      }
      //  check the following assumption: one breakpoint for one node 
      for (ILocationBreakpoint breakpointForRoot : breakpointsForRoot) {
        if (breakpointForRoot.getLocation().getNodePointer().equals(breakpoint.getLocation().getNodePointer())) {
          LOG.error("Trying to add a second breakpoint for node", breakpointForRoot.getLocation().getSNode());
          break;
        }
      }
      breakpointsForRoot.add(breakpoint);
    }
  }

  public void removeBreakpoint(@NotNull final IBreakpoint breakpoint) {
    ModelAccess.instance().runReadAction(new Runnable() {
      @Override
      public void run() {
        synchronized (myBreakpoints) {
          if (breakpoint instanceof ILocationBreakpoint) {
            removeLocationBreakpoint((ILocationBreakpoint) breakpoint);
          }
          myBreakpoints.remove(breakpoint);
          breakpoint.removeFromRunningSessions();
        }
      }
    });
    fireBreakpointRemoved(breakpoint);
  }

  private void removeLocationBreakpoint(ILocationBreakpoint breakpoint) {
    SNode node = breakpoint.getLocation().getSNode();
    if (node != null) {
      SNode root = node.getContainingRoot();
      SNodeReference rootPointer = new jetbrains.mps.smodel.SNodePointer(root);
      Set<ILocationBreakpoint> breakpointsForRoot = myRootsToBreakpointsMap.get(rootPointer);
      if (breakpointsForRoot != null) {
        breakpointsForRoot.remove(breakpoint);
      }
    }
  }

  private void clear() {
    synchronized (myBreakpoints) {
      myRootsToBreakpointsMap.clear();
      myBreakpoints.clear();
      myUnreadBreakpoints.clear();
      myBreakpointsForRootInitialized = false;
    }
  }

  public void loadState(Element state) {
    Set<IBreakpoint> newBreakpoints = SetSequence.fromSet(new HashSet<IBreakpoint>());
    Set<IBreakpoint> oldBreakpoints = SetSequence.fromSet(new HashSet<IBreakpoint>());

    loadStateInternal(state, oldBreakpoints, newBreakpoints);

    SetSequence.fromSet(oldBreakpoints).subtract(SetSequence.fromSet(newBreakpoints)).visitAll(new IVisitor<IBreakpoint>() {
      public void visit(IBreakpoint it) {
        fireBreakpointRemoved(it);
      }
    });
    SetSequence.fromSet(newBreakpoints).subtract(SetSequence.fromSet(oldBreakpoints)).visitAll(new IVisitor<IBreakpoint>() {
      public void visit(IBreakpoint it) {
        fireBreakpointAdded(it);
      }
    });
  }

  private void loadStateInternal(Element state, Set<IBreakpoint> oldBreakpoints, Set<IBreakpoint> newBreakpoints) {
    synchronized (myBreakpoints) {
      SetSequence.fromSet(oldBreakpoints).addSequence(SetSequence.fromSet(myBreakpoints));
      clear();
      List breakpointsElement = state.getChildren();
      for (ListIterator it = breakpointsElement.listIterator(); it.hasNext();) {
        Element breakpointElement = (Element) it.next();
        try {
          IBreakpoint breakpoint = myBreakpointsIO.readBreakpoint(breakpointElement);
          if (breakpoint != null) {
            myBreakpoints.add(breakpoint);
          } else {
            myUnreadBreakpoints.add(breakpointElement);
          }
        } catch (Throwable t) {
          LOG.error("Error while loading breakpoint from " + breakpointElement, t);
        }
      }
      SetSequence.fromSet(newBreakpoints).addSequence(SetSequence.fromSet(myBreakpoints));
    }
  }

  public Element getState() {
    Element rootElement = new Element(BREAKPOINTS_LIST_ELEMENT);
    synchronized (myBreakpoints) {
      for (IBreakpoint breakpoint : myBreakpoints) {
        try {
          Element element = myBreakpointsIO.writeBreakpoint(breakpoint);
          if (element != null) {
            rootElement.addContent(element);
          }
        } catch (Throwable t) {
          LOG.error("Error while saving breakpoint " + breakpoint.getPresentation(), t);
        }
      }
    }
    for (Element el : myUnreadBreakpoints) {
      rootElement.addContent((Element) el.clone());
    }
    return rootElement;
  }

  public void reReadState() {
    Set<IBreakpoint> newBreakpoints = SetSequence.fromSet(new HashSet<IBreakpoint>());
    Set<IBreakpoint> oldBreakpoints = SetSequence.fromSet(new HashSet<IBreakpoint>());

    synchronized (myBreakpoints) {
      loadStateInternal(getState(), oldBreakpoints, newBreakpoints);
    }

    SetSequence.fromSet(oldBreakpoints).subtract(SetSequence.fromSet(newBreakpoints)).visitAll(new IVisitor<IBreakpoint>() {
      public void visit(IBreakpoint it) {
        fireBreakpointRemoved(it);
      }
    });
    SetSequence.fromSet(newBreakpoints).subtract(SetSequence.fromSet(oldBreakpoints)).visitAll(new IVisitor<IBreakpoint>() {
      public void visit(IBreakpoint it) {
        fireBreakpointAdded(it);
      }
    });
  }

  public Set<IBreakpoint> getAllIBreakpoints() {
    synchronized (myBreakpoints) {
      return new HashSet<IBreakpoint>(myBreakpoints);
    }
  }

  public void addChangeListener(BreakpointManagerComponent.IBreakpointManagerListener listener) {
    synchronized (myListeners) {
      myListeners.add(listener);
    }
  }

  public void removeChangeListener(BreakpointManagerComponent.IBreakpointManagerListener listener) {
    synchronized (myListeners) {
      myListeners.remove(listener);
    }
  }

  private List<BreakpointManagerComponent.IBreakpointManagerListener> getListeners() {
    synchronized (myListeners) {
      return new ArrayList<BreakpointManagerComponent.IBreakpointManagerListener>(myListeners);
    }
  }

  private void fireBreakpointRemoved(IBreakpoint breakpoint) {
    List<BreakpointManagerComponent.IBreakpointManagerListener> listeners = getListeners();
    for (BreakpointManagerComponent.IBreakpointManagerListener listener : listeners) {
      listener.breakpointRemoved(breakpoint);
    }
  }

  private void fireBreakpointAdded(IBreakpoint breakpoint) {
    List<BreakpointManagerComponent.IBreakpointManagerListener> listeners = getListeners();
    for (BreakpointManagerComponent.IBreakpointManagerListener listener : listeners) {
      listener.breakpointAdded(breakpoint);
    }
  }

  public Set<ILocationBreakpoint> getBreakpoints(final SNodeReference rootPointer) {
    return ModelAccess.instance().runReadAction(new Computable<Set<ILocationBreakpoint>>() {
      public Set<ILocationBreakpoint> compute() {
        synchronized (myBreakpoints) {
          if (!(myBreakpointsForRootInitialized)) {
            myBreakpointsForRootInitialized = true;
            for (IBreakpoint breakpoint : myBreakpoints) {
              if (breakpoint instanceof ILocationBreakpoint) {
                addLocationBreakpoint((ILocationBreakpoint) breakpoint);
              }
            }
          }
          return myRootsToBreakpointsMap.get(rootPointer);
        }
      }
    });
  }

  public static BreakpointManagerComponent getInstance(@NotNull Project project) {
    return project.getComponent(BreakpointManagerComponent.class);
  }

  public static interface IBreakpointManagerListener {
    public void breakpointAdded(@NotNull IBreakpoint breakpoint);
    public void breakpointRemoved(@NotNull IBreakpoint breakpoint);
  }

  public static abstract class BreakpointManagerListener implements BreakpointManagerComponent.IBreakpointManagerListener {
    public BreakpointManagerListener() {
    }

    @Override
    public void breakpointAdded(@NotNull IBreakpoint breakpoints) {
      breakpointsChanged();
    }

    @Override
    public void breakpointRemoved(@NotNull IBreakpoint breakpoint) {
      breakpointsChanged();
    }

    public abstract void breakpointsChanged();
  }

  public static interface IBreakpointsIO {
    @Nullable
    public IBreakpoint readBreakpoint(@NotNull Element element);
    @Nullable
    public Element writeBreakpoint(@NotNull IBreakpoint breakpoint);
  }

  public static class DummyIO implements BreakpointManagerComponent.IBreakpointsIO {
    public DummyIO() {
    }

    @Override
    public IBreakpoint readBreakpoint(@NotNull Element element) {
      return null;
    }

    @Override
    public Element writeBreakpoint(@NotNull IBreakpoint breakpoint) {
      return null;
    }
  }
}
