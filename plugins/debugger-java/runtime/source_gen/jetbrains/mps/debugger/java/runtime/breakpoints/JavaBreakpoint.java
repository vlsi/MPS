package jetbrains.mps.debugger.java.runtime.breakpoints;

/*Generated by MPS */

import jetbrains.mps.debug.api.breakpoints.AbstractBreakpoint;
import jetbrains.mps.debugger.java.runtime.engine.requests.ClassPrepareRequestor;
import jetbrains.mps.debugger.java.runtime.engine.requests.LocatableEventRequestor;
import com.sun.jdi.request.EventRequest;
import jetbrains.mps.logging.Logger;
import com.intellij.openapi.project.Project;
import jetbrains.mps.debugger.java.runtime.engine.events.EventsProcessor;
import jetbrains.mps.debugger.java.runtime.engine.concurrent.ManagerThread;
import java.util.List;
import com.sun.jdi.ReferenceType;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.debugger.java.runtime.engine.RequestManager;
import jetbrains.mps.debugger.java.runtime.engine.events.EventContext;
import com.sun.jdi.event.LocatableEvent;
import com.sun.jdi.ThreadReference;
import com.sun.jdi.StackFrame;
import com.sun.jdi.IncompatibleThreadStateException;

public abstract class JavaBreakpoint extends AbstractBreakpoint implements ClassPrepareRequestor, LocatableEventRequestor {
  private int mySuspendPolicy = EventRequest.SUSPEND_ALL;
  private boolean myLogMessage = false;
  private final Logger LOG = Logger.getLogger(JavaBreakpoint.class);

  protected JavaBreakpoint(Project project) {
    super(project);
  }

  public void createClassPrepareRequest(EventsProcessor debugProcess) {
    // this should be called on every breakpoint when DebugEventsProcessor is attached 
    ManagerThread.assertIsMangerThread();
    //  check is this breakpoint is enabled, vm reference is valid and there're no requests created yet 
    if (!(myIsEnabled)) {
      // || !debugProcess.isAttached() || debugProcess.getRequestManager().findRequests(this).isEmpty() 
      return;
    }
    if (!(isValid())) {
      return;
    }
    createOrWaitPrepare(debugProcess);
    //  updateUI(); 
  }

  public void createOrWaitPrepare(final EventsProcessor debugProcess) {
    String className = getClassNameToPrepare();
    assert (className != null && className.length() > 0);
    // add requests for not prepared classes 
    debugProcess.getRequestManager().callbackOnPrepareClasses(this, className);
    // and get all already prepared classes for a SNode 
    List<ReferenceType> list = debugProcess.getVirtualMachine().classesByName(className);
    for (final ReferenceType refType : list) {
      if (refType.isPrepared()) {
        processClassPrepare(debugProcess, refType);
      }
    }
  }

  protected abstract String getClassNameToPrepare();

  @NotNull
  public abstract JavaBreakpointKind getKind();

  @Override
  public void processClassPrepare(EventsProcessor debugProcess, ReferenceType classType) {
    // this is called when a class for this ClassPrepareRequestor is prepared 
    if (!(myIsEnabled) || !(isValid())) {
      return;
    }
    createRequestForPreparedClass(debugProcess, classType);
  }

  protected abstract void createRequestForPreparedClass(EventsProcessor debugProcess, ReferenceType classType);

  @Override
  public void removeFromRunningSessions() {
    RequestManager.removeClassPrepareRequests(this);
  }

  @Override
  public void addToRunningSessions() {
    RequestManager.createClassPrepareRequests(this);
  }

  @Override
  public int getSuspendPolicy() {
    return mySuspendPolicy;
  }

  public void setSuspendPolicy(final int policy) {
    if (policy != mySuspendPolicy) {
      mySuspendPolicy = policy;
      removeFromRunningSessions();
      addToRunningSessions();
    }
  }

  public boolean isLogMessage() {
    return myLogMessage;
  }

  public void setLogMessage(boolean logMessage) {
    myLogMessage = logMessage;
  }

  @Override
  public boolean isRequestHitByEvent(EventContext context, LocatableEvent event) {
    assert EventsProcessor.isOnPooledThread();
    if (!(isValid())) {
      context.getRequestManager().deleteRequests(this);
      return false;
    }
    try {
      ThreadReference threadReference = event.thread();
      final StackFrame stackFrame = check_e43rhl_a0b0c0q(threadReference);
      if (stackFrame == null) {
        //  might be if the thread has been collected 
        return false;
      }
    } catch (IncompatibleThreadStateException ex) {
      LOG.error(ex);
      return false;
    }
    return true;
  }

  private static StackFrame check_e43rhl_a0b0c0q(ThreadReference checkedDotOperand) throws IncompatibleThreadStateException {
    if (null != checkedDotOperand) {
      return checkedDotOperand.frame(0);
    }
    return null;
  }
}
