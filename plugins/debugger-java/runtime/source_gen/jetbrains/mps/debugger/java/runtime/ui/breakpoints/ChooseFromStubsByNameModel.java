package jetbrains.mps.debugger.java.runtime.ui.breakpoints;

/*Generated by MPS */

import com.intellij.ide.util.gotoByName.ChooseByNameModel;
import java.util.Map;
import java.util.List;
import org.jetbrains.mps.openapi.persistence.NavigationParticipant;
import java.util.LinkedHashMap;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.workbench.goTo.navigation.GotoNavigationUtil;
import jetbrains.mps.ide.findusages.model.scopes.ModelsScope;
import jetbrains.mps.progress.EmptyProgressMonitor;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import org.jetbrains.mps.openapi.model.SModelReference;
import javax.swing.ListCellRenderer;
import com.intellij.ui.ListCellRendererWrapper;
import javax.swing.JList;
import org.jetbrains.annotations.NotNull;

/*package*/ abstract class ChooseFromStubsByNameModel implements ChooseByNameModel {
  private final Map<String, List<NavigationParticipant.NavigationTarget>> myPossibleNodes = new LinkedHashMap<String, List<NavigationParticipant.NavigationTarget>>();
  private final Project myProject;
  /*package*/ ChooseFromStubsByNameModel(final Project mpsProject) {
    myProject = mpsProject;
    mpsProject.getModelAccess().runReadAction(new Runnable() {
      public void run() {
        Iterable<SModel> mds = mpsProject.getProjectModels();
        Iterable<SModel> stubModels = Sequence.fromIterable(mds).where(new IWhereFilter<SModel>() {
          public boolean accept(SModel it) {
            return SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(it));
          }
        });
        Iterable<NavigationParticipant.NavigationTarget> descr = GotoNavigationUtil.getNavigationTargets(NavigationParticipant.TargetKind.ROOT, new ModelsScope(stubModels), new EmptyProgressMonitor());

        for (NavigationParticipant.NavigationTarget descriptor : descr) {
          String name = getName(descriptor);
          List<NavigationParticipant.NavigationTarget> descriptorList = myPossibleNodes.get(name);
          if (descriptorList == null) {
            descriptorList = new ArrayList<NavigationParticipant.NavigationTarget>(4);
            myPossibleNodes.put(name, descriptorList);
          }
          descriptorList.add(descriptor);
        }
      }
    });
  }
  protected abstract boolean isValid(SNode node);
  private boolean isValidClassifier(final NavigationParticipant.NavigationTarget descriptor) {
    return new ModelAccessHelper(myProject.getModelAccess()).runReadAction(new Computable<Boolean>() {
      public Boolean compute() {
        SNode classifier = descriptor.getNodeReference().resolve(myProject.getRepository());
        return (classifier != null) && isValid(classifier);
      }
    });
  }
  private String getName(NavigationParticipant.NavigationTarget descriptor) {
    return descriptor.getPresentation();
  }
  private String getNamespace(NavigationParticipant.NavigationTarget descriptor) {
    SModelReference modelReference = descriptor.getNodeReference().getModelReference();
    if (modelReference != null) {
      return modelReference.getName().getLongName();
    }
    return null;
  }
  @Override
  public String getPromptText() {
    return null;
  }
  @Override
  public String getNotInMessage() {
    return null;
  }
  @Override
  public String getNotFoundMessage() {
    return null;
  }
  @Override
  public String getCheckBoxName() {
    return null;
  }
  @Override
  public char getCheckBoxMnemonic() {
    return (char) 0;
  }
  @Override
  public boolean loadInitialCheckBoxState() {
    return false;
  }
  @Override
  public void saveInitialCheckBoxState(boolean state) {
  }
  @Override
  public ListCellRenderer getListCellRenderer() {
    ListCellRendererWrapper wrapper = new ListCellRendererWrapper<Object>() {
      @Override
      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {
        if (value != null && value instanceof NavigationParticipant.NavigationTarget) {
          String fullName = getFullName(value);
          if (fullName != null) {
            setText(fullName);
          }
        }
      }
    };
    return wrapper;
  }
  @Override
  public String[] getNames(boolean checkBoxState) {
    return myPossibleNodes.keySet().toArray(new String[myPossibleNodes.size()]);
  }
  @Override
  public Object[] getElementsByName(String name, boolean checkBoxState, String pattern) {
    List<NavigationParticipant.NavigationTarget> descriptors = new ArrayList<NavigationParticipant.NavigationTarget>();
    for (NavigationParticipant.NavigationTarget descriptor : myPossibleNodes.get(name)) {
      String descriptorName = getElementName(descriptor);
      if (descriptorName != null && descriptorName.equals(name) && isValidClassifier(descriptor)) {
        descriptors.add(descriptor);
      }
    }
    return descriptors.toArray(new NavigationParticipant.NavigationTarget[descriptors.size()]);
  }
  @Override
  public String getElementName(Object element) {
    return getName((NavigationParticipant.NavigationTarget) element);
  }
  @NotNull
  @Override
  public String[] getSeparators() {
    return new String[]{"."};
  }
  @Override
  public String getFullName(Object element) {
    NavigationParticipant.NavigationTarget navTarget = (NavigationParticipant.NavigationTarget) element;
    String name = getName(navTarget);
    String namespace = getNamespace(navTarget);
    if (namespace == null) {
      return name;
    }
    return namespace + "." + name;
  }
  @Override
  public String getHelpId() {
    return null;
  }
  @Override
  public boolean useMiddleMatching() {
    return true;
  }
}
