package jetbrains.mps.debugger.java.runtime.ui.evaluation;

/*Generated by MPS */

import javax.swing.JPanel;
import jetbrains.mps.logging.Logger;
import com.intellij.openapi.actionSystem.DataKey;
import jetbrains.mps.debugger.java.runtime.evaluation.model.AbstractEvaluationModel;
import jetbrains.mps.debugger.java.runtime.state.DebugSession;
import jetbrains.mps.debug.api.SessionChangeAdapter;
import org.jetbrains.annotations.NotNull;
import java.awt.BorderLayout;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.debugger.java.api.evaluation.Evaluator;
import jetbrains.mps.debugger.java.api.evaluation.proxies.IValueProxy;
import jetbrains.mps.debugger.java.api.evaluation.EvaluationException;
import jetbrains.mps.debugger.java.api.evaluation.InvalidEvaluatedExpressionException;
import jetbrains.mps.debugger.java.api.evaluation.InvocationTargetEvaluationException;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.application.ModalityState;
import com.sun.jdi.ThreadReference;
import jetbrains.mps.debugger.java.api.state.proxy.JavaThread;
import jetbrains.mps.debug.api.AbstractDebugSession;

public abstract class EvaluationUi extends JPanel {
  private static final Logger LOG = Logger.getLogger(EvaluationUi.class);
  public static final DataKey<AbstractEvaluationModel> EVALUATION_MODEL = DataKey.create("Evaluation Model");
  protected final DebugSession myDebugSession;
  protected final EvaluationTree myTree;
  private EvaluationUi.IErrorTextListener myErrorListener;
  private final boolean myAutoUpdate;
  private final SessionChangeAdapter mySessionChangeAdapter = new EvaluationUi.MySessionChangeAdapter();

  public EvaluationUi(@NotNull DebugSession session, boolean autoUpdate) {
    super(new BorderLayout());
    myDebugSession = session;
    myAutoUpdate = autoUpdate;
    myDebugSession.addChangeListener(mySessionChangeAdapter);
    myTree = new EvaluationTree();
  }

  protected abstract void update();

  public abstract void evaluate();

  public void dispose() {
    myDebugSession.removeChangeListener(mySessionChangeAdapter);
    myTree.dispose();
  }

  protected void evaluate(final AbstractEvaluationModel model) {
    if (!(myDebugSession.getEvaluationProvider().canEvaluate())) {
      setErrorText("Program should be paused on breakpoint to evaluate");
      return;
    }
    try {
      final Class clazz = model.generateAndLoadEvaluatorClass();
      setEvaluating(model);
      myDebugSession.getEventsProcessor().scheduleEvaluation(new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          try {
            Evaluator evaluator = model.createEvaluatorInstance(clazz);
            IValueProxy evaluatedValue = evaluator.evaluate();
            if (evaluatedValue != null) {
              setSuccess(evaluatedValue, model);
            } else {
              setFailure(null, "Evaluation returned null.", model);
            }
          } catch (EvaluationException e) {
            setFailure(e, null, model);
          } catch (Throwable t) {
            setFailure(t, null, model);
            LOG.error(t);
          }
        }
      }, check_4q63yg_b0a2a1a3(myDebugSession.getUiState().getThread()));
    } catch (InvalidEvaluatedExpressionException e) {
      setFailure(e.getCause(), null, model);
    } catch (InvocationTargetEvaluationException e) {
      setFailure(e.getCause(), null, model);
      LOG.error(e.getCause());
    } catch (EvaluationException e) {
      setFailure(e, null, model);
    } catch (Throwable t) {
      setFailure(t, null, model);
      LOG.error(t);
    }
  }

  private void setSuccess(@NotNull final IValueProxy evaluatedValue, final AbstractEvaluationModel model) {
    invokeLaterIfNeeded(new Runnable() {
      public void run() {
        myTree.setResultProxy(evaluatedValue, model);
        myTree.rebuildEvaluationTreeNowIfNotDisposed();
      }
    });
  }

  private void setEvaluating(final AbstractEvaluationModel model) {
    invokeLaterIfNeeded(new Runnable() {
      public void run() {
        myTree.setEvaluating(model);
        myTree.rebuildEvaluationTreeNowIfNotDisposed();
      }
    });
  }

  private void setFailure(@Nullable final Throwable error, @Nullable final String message, final AbstractEvaluationModel model) {
    invokeLaterIfNeeded(new Runnable() {
      public void run() {
        if (error != null) {
          myTree.setError(error, model);
        } else {
          myTree.setError(message, model);
        }
        myTree.rebuildEvaluationTreeNowIfNotDisposed();
      }
    });
  }

  protected void setErrorText(String text) {
    if (myErrorListener != null) {
      myErrorListener.updateErrorText(text);
    }
  }

  private void invokeLaterIfNeeded(Runnable runnable) {
    if (ApplicationManager.getApplication().isDispatchThread()) {
      runnable.run();
    } else {
      ApplicationManager.getApplication().invokeLater(runnable, ModalityState.NON_MODAL);
    }
  }

  public void setErrorTextListener(EvaluationUi.IErrorTextListener listener) {
    myErrorListener = listener;
  }

  private static ThreadReference check_4q63yg_b0a2a1a3(JavaThread checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getThread();
    }
    return null;
  }

  public static interface IErrorTextListener {
    public void updateErrorText(String text);
  }

  private class MySessionChangeAdapter extends SessionChangeAdapter {
    public MySessionChangeAdapter() {
    }

    @Override
    public void paused(AbstractDebugSession session) {
      if (myDebugSession == session) {
        myTree.updateLocation(myDebugSession.getUiState().getStackFrame().getLocation().getUnitName(), myDebugSession.getUiState().getThread().getThread());
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            setErrorText("");
            update();
            if (myAutoUpdate) {
              evaluate();
            }
          }
        });
      }
    }

    @Override
    public void stateChanged(AbstractDebugSession session) {
      if (myDebugSession == session) {
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            update();
          }
        });
      }
    }

    @Override
    public void resumed(AbstractDebugSession session) {
      if (myDebugSession == session) {
        ApplicationManager.getApplication().invokeLater(new Runnable() {
          public void run() {
            myTree.rebuildEvaluationTreeNowIfNotDisposed();
          }
        });
      }
    }
  }
}
