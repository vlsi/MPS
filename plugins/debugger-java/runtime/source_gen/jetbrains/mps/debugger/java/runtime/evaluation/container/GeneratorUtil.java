package jetbrains.mps.debugger.java.runtime.evaluation.container;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.debugger.java.api.evaluation.EvaluationException;
import jetbrains.mps.make.IMakeService;
import jetbrains.mps.make.MakeSession;
import jetbrains.mps.make.script.IScript;
import jetbrains.mps.make.script.ScriptBuilder;
import jetbrains.mps.make.facet.IFacet;
import jetbrains.mps.make.facet.ITarget;
import jetbrains.mps.make.script.IResult;
import jetbrains.mps.smodel.resources.ModelsToResources;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.compiler.JavaCompiler;
import jetbrains.mps.make.resources.IResource;
import jetbrains.mps.smodel.resources.FResource;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.project.facets.JavaModuleOperations;
import jetbrains.mps.util.SNodeOperations;
import java.util.concurrent.ExecutionException;
import java.lang.reflect.InvocationTargetException;
import jetbrains.mps.debugger.java.api.evaluation.InvocationTargetEvaluationException;
import jetbrains.mps.compiler.CompilationResultAdapter;
import org.eclipse.jdt.internal.compiler.CompilationResult;
import org.eclipse.jdt.core.compiler.CategorizedProblem;

public class GeneratorUtil {
  @Nullable
  public static Class generateAndLoadEvaluatorClass(Project project, SModel model, String className, IOperationContext context, boolean developerMode, ClassLoader parentloader) throws EvaluationException {
    IMakeService makeService = IMakeService.INSTANCE.get();
    MakeSession makeSession = new MakeSession(context);
    if (makeService.openNewSession(makeSession)) {
      try {
        IScript script = new ScriptBuilder().withFacetNames(new IFacet.Name("jetbrains.mps.lang.core.Generate"), new IFacet.Name("jetbrains.mps.lang.core.TextGen"), new IFacet.Name("jetbrains.mps.debugger.java.evaluation.JavaDebugEvaluate"), new IFacet.Name("jetbrains.mps.make.facets.Make")).withFinalTarget(new ITarget.Name("jetbrains.mps.lang.core.TextGen.textGenToMemory")).toScript();
        IResult result = makeService.make(makeSession, new ModelsToResources(Sequence.<SModel>singleton(model)).resources(false), script).get();
        boolean successful = result.isSucessful();
        String source = null;
        final String desiredSourceUnitName = className + ".java";
        if (successful) {
          JavaCompiler javaCompiler = new JavaCompiler();
          for (IResource res : Sequence.fromIterable(result.output())) {
            if (res instanceof FResource) {
              FResource fres = ((FResource) res);
              Map<String, Object> contents = fres.contents();
              for (String unitName : MapSequence.fromMap(contents).keySet()) {
                if (!(unitName.endsWith(".java"))) {
                  continue;
                }
                javaCompiler.addSource(fres.packageName() + '.' + unitName.substring(0, unitName.length() - 5), String.valueOf(MapSequence.fromMap(contents).get(unitName)));
                if (unitName.equals(desiredSourceUnitName)) {
                  source = String.valueOf(unitName);
                }
              }
            }
          }
          GeneratorUtil.MyCompilationResultAdapter compilationResult = new GeneratorUtil.MyCompilationResultAdapter();
          javaCompiler.addCompilationResultListener(compilationResult);
          javaCompiler.compile(JavaModuleOperations.createClassPathItem(JavaModuleOperations.collectCompileClasspath(model.getModule()), GeneratorUtil.class.getName()));
          javaCompiler.removeCompilationResultListener(compilationResult);

          final String fullClassName = SNodeOperations.getModelLongName(model) + "." + className;
          if (successful && (source != null && source.length() > 0)) {
            if (developerMode) {
              System.err.println("[Generated text]\n" + source + "\n[Generated text]");
            }
            return Class.forName(fullClassName, true, javaCompiler.getClassLoader(parentloader));
          } else if ((source != null && source.length() > 0) && !(successful)) {
            String text = "Errors during compilation";
            if (compilationResult.hasErrors()) {
              text += ":\n" + compilationResult.getMessage();
            } else {
              text += ".";
            }
            throw new EvaluationException(text);
          }
        }
        // else fall-through, up to throws EvaluationException below 
      } catch (InterruptedException e) {
        throw new EvaluationException(e);
      } catch (ExecutionException e) {
        throw new EvaluationException(e);
      } catch (ClassNotFoundException e) {
        throw new EvaluationException(e);
      } finally {
        makeService.closeSession(makeSession);
      }
    }
    throw new EvaluationException("Errors during generation.");
  }
  public static <E> E createInstance(Class clazz, Class[] parameterClasses, Object[] parameters) throws EvaluationException {
    try {
      return (E) clazz.getConstructor(parameterClasses).newInstance(parameters);
    } catch (InvocationTargetException e) {
      throw new InvocationTargetEvaluationException(e.getCause());
    } catch (NoSuchMethodException e) {
      throw new EvaluationException(e);
    } catch (IllegalAccessException e) {
      throw new EvaluationException(e);
    } catch (InstantiationException e) {
      throw new EvaluationException(e);
    }
  }
  private static class MyCompilationResultAdapter extends CompilationResultAdapter {
    private final StringBuffer myBuffer = new StringBuffer();
    private boolean myHasErrors;
    public MyCompilationResultAdapter() {
    }
    @Override
    public void onCompilationResult(CompilationResult result) {
      if (result.hasErrors()) {
        myHasErrors = true;
        for (CategorizedProblem error : result.getErrors()) {
          myBuffer.append(error.getMessage());
          myBuffer.append("\n");
        }
      }
    }
    public boolean hasErrors() {
      return myHasErrors;
    }
    public String getMessage() {
      return myBuffer.toString();
    }
  }
}
