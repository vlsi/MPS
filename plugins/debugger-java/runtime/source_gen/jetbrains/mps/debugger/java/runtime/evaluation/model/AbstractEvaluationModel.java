package jetbrains.mps.debugger.java.runtime.evaluation.model;

/*Generated by MPS */

import jetbrains.mps.debugger.java.api.state.JavaUiState;
import jetbrains.mps.debugger.java.runtime.state.DebugSession;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.descriptor.EditableSModelDescriptor;
import java.util.List;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.smodel.SNode;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.project.ModuleContext;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.smodel.ProjectModels;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.library.GeneralPurpose_DevKit;
import jetbrains.mps.smodel.SModelRepository;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.debugger.java.api.evaluation.EvaluationException;
import jetbrains.mps.generator.generationTypes.InMemoryJavaGenerationHandler;
import jetbrains.mps.ide.messages.DefaultMessageHandler;
import com.intellij.openapi.progress.util.ProgressWindow;
import jetbrains.mps.generator.GenerationFacade;
import java.util.Collections;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.generator.GenerationOptions;
import jetbrains.mps.ide.generator.TransientModelsComponent;
import com.intellij.openapi.util.Disposer;
import jetbrains.mps.debugger.java.api.evaluation.Evaluator;
import java.lang.reflect.InvocationTargetException;
import jetbrains.mps.debugger.java.api.evaluation.InvocationTargetEvaluationException;
import jetbrains.mps.util.Computable;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.compiler.CompilationResultAdapter;
import org.eclipse.jdt.internal.compiler.CompilationResult;
import org.eclipse.jdt.core.compiler.CategorizedProblem;
import jetbrains.mps.generator.IncrementalGenerationStrategy;
import java.util.Map;
import jetbrains.mps.generator.GenerationCacheContainer;
import jetbrains.mps.generator.impl.dependencies.GenerationDependencies;

public abstract class AbstractEvaluationModel {
  /*package*/ static final String EVALUATOR_NAME = "EvaluatorInstance";
  public static final boolean IS_DEVELOPER_MODE = Boolean.getBoolean("evaluation.developer");

  protected JavaUiState myUiState;
  protected final DebugSession myDebugSession;
  protected final IOperationContext myContext;
  protected final EditableSModelDescriptor myAuxModel;
  protected final EvaluationAuxModule myAuxModule;
  protected final List<Language> myLanguages = ListSequence.fromList(new ArrayList<Language>());
  private final List<_FunctionTypes._void_P1_E0<? super SNode>> myGenerationListeners = ListSequence.fromList(new ArrayList<_FunctionTypes._void_P1_E0<? super SNode>>());
  protected final EvaluationContext myEvaluationContext;
  protected final boolean myShowContext;

  public AbstractEvaluationModel(Project project, @NotNull DebugSession session, @NotNull EvaluationAuxModule auxModule, EvaluationContext context, boolean isShowContext) {
    assert !(ApplicationManager.getApplication().isDispatchThread());
    myUiState = session.getUiState();
    myDebugSession = session;
    if (context.getLocationNode() != null) {
      myContext = ModuleContext.create(context.getLocationNode(), ProjectHelper.toMPSProject(project));
    } else {
      myContext = new ModuleContext(auxModule, ProjectHelper.toMPSProject(project));
    }
    myAuxModule = auxModule;

    final EditableSModelDescriptor modelDescriptor = ((EditableSModelDescriptor) ProjectModels.createDescriptorFor(true));
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        modelDescriptor.getSModel().addDevKit(GeneralPurpose_DevKit.MODULE_REFERENCE);
      }
    });
    SModelRepository.getInstance().registerModelDescriptor(modelDescriptor, myAuxModule);

    myAuxModel = modelDescriptor;
    myEvaluationContext = context;
    myShowContext = isShowContext;
  }

  public DebugSession getDebugSession() {
    return this.myDebugSession;
  }

  public EvaluationAuxModule getModule() {
    return myAuxModule;
  }

  public EditableSModelDescriptor getModel() {
    return myAuxModel;
  }

  public List<Language> getRequiredLanguages() {
    return myLanguages;
  }

  @NotNull
  public abstract SNode getNodeToShow();

  public void addGenerationListener(_FunctionTypes._void_P1_E0<? super SNode> listener) {
    ListSequence.fromList(myGenerationListeners).addElement(listener);
  }

  public boolean isDeveloperMode() {
    return AbstractEvaluationModel.IS_DEVELOPER_MODE;
  }

  public void updateState() {
    myUiState = myDebugSession.getUiState();
    myEvaluationContext.setUiState(myUiState);
  }

  public abstract AbstractEvaluationModel copy(boolean isShowContext);

  @Nullable
  public Class generateAndLoadEvaluatorClass() throws EvaluationException {
    try {

      final String fullClassName = this.myAuxModel.getLongName() + "." + AbstractEvaluationModel.EVALUATOR_NAME;
      InMemoryJavaGenerationHandler handler = new MyInMemoryJavaGenerationHandler(false, true, myGenerationListeners);
      AbstractEvaluationModel.MyCompilationResultAdapter compilationResult = new AbstractEvaluationModel.MyCompilationResultAdapter();
      handler.setCompilationListener(compilationResult);
      Project ideaProject = this.myAuxModule.getMPSProject().getProject();
      DefaultMessageHandler messageHandler = new DefaultMessageHandler(ideaProject);
      ProgressWindow progressWindow = new ProgressWindow(false, ideaProject);
      boolean successful = GenerationFacade.generateModels(myContext.getProject(), Collections.singletonList((SModelDescriptor) myAuxModel), myContext, handler, new ProgressMonitorAdapter(progressWindow), messageHandler, GenerationOptions.getDefaults().incremental(new AbstractEvaluationModel.MyIncrementalGenerationStrategy()).saveTransientModels(IS_DEVELOPER_MODE).rebuildAll(false).reporting(false, false, false, 0).create(), myContext.getProject().getComponent(TransientModelsComponent.class));

      Disposer.dispose(progressWindow);

      String source = handler.getSources().get(fullClassName);

      if (successful && (source != null && source.length() > 0)) {
        if (isDeveloperMode()) {
          System.err.println(source);
        }
        ClassLoader parentClassLoader = this.myUiState.getClass().getClassLoader();
        return Class.forName(fullClassName, true, handler.getCompiler().getClassLoader(parentClassLoader));
      } else if ((source != null && source.length() > 0) && !(successful)) {
        String text = "Errors during compilation";
        if (compilationResult.hasErrors()) {
          text += ":\n" + compilationResult.getMessage();
        } else {
          text += ".";
        }
        throw new EvaluationException(text);
      } else {
        throw new EvaluationException("Errors during generation.");
      }
    } catch (EvaluationException e) {
      throw e;
    } catch (ClassNotFoundException e) {
      throw new EvaluationException(e);
    }
  }

  public Evaluator createEvaluatorInstance(Class clazz) throws EvaluationException {
    try {
      Evaluator evaluator;
      try {
        evaluator = (Evaluator) clazz.getConstructor(JavaUiState.class).newInstance(this.myUiState);
      } catch (InvocationTargetException e) {
        // try again 
        myUiState = myDebugSession.refresh();
        evaluator = (Evaluator) clazz.getConstructor(JavaUiState.class).newInstance(this.myUiState);
      }
      return evaluator;
    } catch (InvocationTargetException e) {
      // invocation target exceptions from newInstance method call via reflection 
      // second time, which means refresh did not help 
      // this is bad 
      // I personally think something should be done with all those exceptions 
      // other then hiding them from user 
      // but I do not know what 
      throw new InvocationTargetEvaluationException(e.getCause());
    } catch (NoSuchMethodException e) {
      throw new EvaluationException(e);
    } catch (IllegalAccessException e) {
      throw new EvaluationException(e);
    } catch (InstantiationException e) {
      throw new EvaluationException(e);
    }
  }

  public String getPresentation() {
    return ModelAccess.instance().runReadAction(new Computable<String>() {
      public String compute() {
        return BehaviorReflection.invokeVirtual(String.class, getNodeToShow(), "virtual_getEvaluatorPresentation_9172312269976647295", new Object[]{});
      }
    });
  }

  public class MyCompilationResultAdapter extends CompilationResultAdapter {
    private final StringBuffer myBuffer = new StringBuffer();
    private boolean myHasErrors;

    public MyCompilationResultAdapter() {
    }

    @Override
    public void onCompilationResult(CompilationResult result) {
      if (result.hasErrors()) {
        myHasErrors = true;
        for (CategorizedProblem error : result.getErrors()) {
          myBuffer.append(error.getMessage());
          myBuffer.append("\n");
        }
      }
    }

    public boolean hasErrors() {
      return myHasErrors;
    }

    public String getMessage() {
      return myBuffer.toString();
    }
  }

  private class MyIncrementalGenerationStrategy implements IncrementalGenerationStrategy {
    public MyIncrementalGenerationStrategy() {
    }

    public Map<String, String> getModelHashes(SModelDescriptor p0, IOperationContext p1) {
      return Collections.emptyMap();
    }

    public GenerationCacheContainer getContainer() {
      return null;
    }

    public GenerationDependencies getDependencies(SModelDescriptor p0) {
      return null;
    }

    public boolean isIncrementalEnabled() {
      return false;
    }
  }
}
