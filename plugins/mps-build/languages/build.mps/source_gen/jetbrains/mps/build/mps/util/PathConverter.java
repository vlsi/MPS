package jetbrains.mps.build.mps.util;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.build.behavior.BuildProject_Behavior;
import jetbrains.mps.build.util.Context;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.build.behavior.BuildFolderMacro_Behavior;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.io.File;
import java.io.IOException;

public class PathConverter {
  private String workingDirectory;
  private final Iterable<Tuples._2<String, SNode>> macros;
  private final Iterable<SNode> macrosWithoutPath;

  public PathConverter(SNode project) {
    String workingDir = BuildProject_Behavior.call_getBasePath_4959435991187146924(project, Context.defaultContext());
    this.workingDirectory = normalizePath(workingDir, true);

    final List<Tuples._2<String, SNode>> result = ListSequence.fromList(new ArrayList<Tuples._2<String, SNode>>());
    final List<SNode> withoutPath = ListSequence.fromList(new ArrayList<SNode>());
    ListSequence.fromList(SLinkOperations.getTargets(project, "macros", true)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "jetbrains.mps.build.structure.BuildFolderMacro");
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        String path = normalizePath(BuildFolderMacro_Behavior.call_evaluate_4959435991187146982(SNodeOperations.cast(it, "jetbrains.mps.build.structure.BuildFolderMacro"), Context.defaultContext()), true);
        if (path != null && path.length() > 1) {
          ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(path, SNodeOperations.cast(it, "jetbrains.mps.build.structure.BuildFolderMacro")));
        } else {
          ListSequence.fromList(withoutPath).addElement(SNodeOperations.cast(it, "jetbrains.mps.build.structure.BuildFolderMacro"));
        }
      }
    });
    ListSequence.fromList(result).addElement(MultiTuple.<String,SNode>from(this.workingDirectory, (SNode) null));
    macros = ListSequence.fromList(result).sort(new ISelector<Tuples._2<String, SNode>, Integer>() {
      public Integer select(Tuples._2<String, SNode> it) {
        return it._0().length() * 2 - ((it._1() == null ?
          1 :
          0
        ));
      }
    }, false);
    macrosWithoutPath = withoutPath;
  }

  private SNode buildRelative(String currPath, SNode macro, SModel model) {
    SNode relPath;
    if (macro == null) {
      relPath = SModelOperations.createNewNode(model, null, "jetbrains.mps.build.structure.BuildSourceProjectRelativePath");
    } else {
      relPath = SModelOperations.createNewNode(model, null, "jetbrains.mps.build.structure.BuildSourceMacroRelativePath");
      SLinkOperations.setTarget(SNodeOperations.cast(relPath, "jetbrains.mps.build.structure.BuildSourceMacroRelativePath"), "macro", macro, false);
    }
    buildCompositePath(relPath, currPath, model);
    return relPath;
  }

  public List<SNode> convertPath(String path, SModel model) throws PathConverter.PathConvertException {
    path = normalizePath(path, false);
    String withSlash = normalizePath(path, true);
    List<SNode> result = new ArrayList<SNode>();
    for (Tuples._2<String, SNode> m : Sequence.fromIterable(macros)) {
      String mdir = (path.startsWith("$") && m._1() != null ?
        "${" + SPropertyOperations.getString(m._1(), "name") + "}/" :
        m._0()
      );
      String currPath = (path.length() < mdir.length() ?
        withSlash :
        path
      );

      if (currPath.startsWith(mdir)) {
        currPath = currPath.substring(mdir.length());
      } else {
        continue;
      }
      ListSequence.fromList(result).addElement(buildRelative(currPath, m._1(), model));
    }
    for (SNode m : Sequence.fromIterable(macrosWithoutPath)) {
      String mdir = "${" + SPropertyOperations.getString(m, "name") + "}/";
      String currPath = (path.length() < mdir.length() ?
        withSlash :
        path
      );
      if (currPath.startsWith(mdir)) {
        currPath = currPath.substring(mdir.length());
      } else {
        continue;
      }
      ListSequence.fromList(result).addElement(buildRelative(currPath, m, model));
    }
    if ((int) ListSequence.fromList(result).count() == 0) {
      throw new PathConverter.PathConvertException("source path (" + path + ") should be under working directory (" + workingDirectory + "), or any macros default directory");

    }
    return result;
  }

  private void buildCompositePath(SNode result, String path, SModel model) {
    SNode last = null;
    for (String fname : path.split("/")) {
      if ((fname != null && fname.length() > 0)) {
        SNode npath = SModelOperations.createNewNode(model, null, "jetbrains.mps.build.structure.BuildCompositePath");
        SPropertyOperations.set(npath, "head", fname);
        if (last == null) {
          SLinkOperations.setTarget(result, "compositePart", npath, true);
        } else {
          SLinkOperations.setTarget(last, "tail", npath, true);
        }
        last = npath;
      }
    }
  }

  private static String normalizePath(String path, boolean addSlash) {
    if (path == null || (path == null || path.length() == 0)) {
      return null;
    }
    try {
      path = (path.startsWith("${") ?
        path :
        new File(path).getCanonicalPath()
      );
      path = path.replace("\\", "/");
    } catch (IOException ignore) {
      // ignore 
    }
    if (addSlash && !(path.endsWith("/"))) {
      path = path + "/";
    }
    return path;
  }

  public class PathConvertException extends Exception {
    public PathConvertException(String message) {
      super(message);
    }
  }
}
