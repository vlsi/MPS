package jetbrains.mps.console.ideCommands.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.ide.messages.MessagesViewTool;
import jetbrains.mps.console.tool.ConsoleStream;
import jetbrains.mps.generator.impl.plan.GenerationPlan;
import java.util.Map;
import jetbrains.mps.generator.runtime.TemplateMappingPriorityRule;
import jetbrains.mps.generator.runtime.TemplateModule;
import java.util.HashMap;
import java.util.Collection;
import jetbrains.mps.messages.Message;
import jetbrains.mps.messages.MessageKind;
import java.util.List;
import jetbrains.mps.generator.runtime.TemplateMappingConfiguration;
import jetbrains.mps.util.Pair;
import jetbrains.mps.generator.impl.plan.GenerationPartitioningUtil;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.MPSModuleRepository;
import com.intellij.openapi.project.Project;
import java.util.ArrayList;
import jetbrains.mps.generator.impl.plan.ConnectedComponentPartitioner;
import jetbrains.mps.generator.impl.plan.Conflict;

public class PartitioningHelper {
  private final SModel inputModel;
  private final MessagesViewTool messagesView;
  private final ConsoleStream console;
  private PartitioningHelper(SModel inputModel, MessagesViewTool viewTool, ConsoleStream console) {
    this.inputModel = inputModel;
    this.messagesView = viewTool;
    this.console = console;
  }
  private void show() {
    GenerationPlan plan = new GenerationPlan(inputModel);

    Map<TemplateMappingPriorityRule, TemplateModule> myRule2Generator = new HashMap<TemplateMappingPriorityRule, TemplateModule>();
    for (TemplateModule generator : plan.getGenerators()) {
      Collection<TemplateMappingPriorityRule> priorities = generator.getPriorities();
      if (priorities == null) {
        continue;
      }
      for (TemplateMappingPriorityRule rule : priorities) {
        myRule2Generator.put(rule, generator);
      }
    }
    // print all rules 
    messagesView.add(new Message(MessageKind.INFORMATION, "================================="));
    for (TemplateModule generator : plan.getGenerators()) {
      Collection<TemplateMappingPriorityRule> rules = generator.getPriorities();
      if (rules == null) {
        continue;
      }
      for (TemplateMappingPriorityRule r : rules) {
        Message msg = new Message(MessageKind.INFORMATION, r.toString());
        msg.setHintObject(generator.getReference());
        messagesView.add(msg);
      }
    }
    messagesView.add(new Message(MessageKind.INFORMATION, "================================="));
    if (plan.hasIgnoredPriorityRules()) {
      printPlanConflicts(plan.getIgnoredPriorityRules(), "Ignored mapping priority rules:");
    }
    if (plan.hasConflictingPriorityRules()) {
      printPlanConflicts(plan.getConflicts(), "Conflicting mapping priority rules encountered:");
    }
    // show partitioning 
    console.addText("---------------------  mappings partitioning  -----------------------------------\n\n");
    for (int step = 0; step < plan.getStepCount(); step++) {
      List<TemplateMappingConfiguration> mappingSet = plan.getMappingConfigurations(step);
      console.addText(" [ " + (step + 1) + " ]\n");
      List<Pair<String, TemplateMappingConfiguration>> strings = GenerationPartitioningUtil.toStrings(mappingSet);
      for (Pair<String, TemplateMappingConfiguration> string : strings) {
        SNode node = SConceptOperations.createNewNode("jetbrains.mps.console.ideCommands.structure.ClickableGenerator", null);
        SPropertyOperations.set(node, "moduleId", string.o2.getModel().getSModelReference().resolve(MPSModuleRepository.getInstance()).getModule().getModuleId().toString());
        SPropertyOperations.set(node, "text", string.o1);
        console.addText(" ");
        console.addNode(node);
        console.addText("\n");
      }
      console.addText("\n");
    }
    console.addText("---------------------------------------------------------------------------------\n");
  }
  public static void showMappingPartitioning(Project project, List<SModel> models, ConsoleStream console) {
    // no multiple input models 
    SModel inputModel = models.get(0);

    MessagesViewTool messagesView = project.getComponent(MessagesViewTool.class);
    messagesView.resetAutoscrollOption();

    new PartitioningHelper(inputModel, messagesView, console).show();

    // other 
    List<SNode> roots = new ArrayList<SNode>();
    for (SModel md : models) {
      SModel model = md;
      for (SNode root : model.getRootNodes()) {
        roots.add(root);
      }
    }
    ConnectedComponentPartitioner ccp = new ConnectedComponentPartitioner(roots);
    console.addText(ccp.toString());

    // viewTool.append("---------- conflicts ------------\n"); 
    //   
    // Map<String, String> existing = new HashMap<String, String>(); 
    // MPSModuleRepository repo = MPSModuleRepository.getInstance(); 
    // for(Generator g : repo.getAllGenerators()) { 
    //  List<SModel> templateModels = g.getOwnTemplateModels(); 
    //  for (SModel templateModel : templateModels) { 
    //    SModel m = templateModel; 
    //    for(SNode root : m.getRoots()) { 
    //      for(SNode node : root.getDescendants(new IsInstanceCondition(MappingLabelDeclaration.concept))){ 
    //        MappingLabelDeclaration label = (MappingLabelDeclaration) node.getAdapter(); 
    //        String name = label.getName(); 
    //        String descr = "model = " + m.toString() + ", root =" + root.toString(); 
    //        if(existing.containsKey(name)) { 
    //          viewTool.append("conflict: name = " + name + ", " + descr + ": with + " + existing.get(name) + "\n"); 
    //        } else { 
    //          existing.put(name, descr); 
    //        } 
    //      } 
    //    } 
    //  } 
    // } 
  }
  private void printPlanConflicts(List<Conflict> conflicts, String header) {
    messagesView.add(new Message(MessageKind.ERROR, PartitioningHelper.class, header));
    console.addText(header);
    console.addText("\n\n");
    for (Conflict c : conflicts) {
      Message msg = new Message(MessageKind.ERROR, PartitioningHelper.class, c.getText());
      msg.setHintObject(c.getOrigin());
      messagesView.add(msg);
      console.addText(String.format("%s\n", c.getText()));
    }
    String footer = "=================================";
    console.addText(footer);
    console.addText("\n");
    messagesView.add(new Message(MessageKind.INFORMATION, footer));
  }
}
