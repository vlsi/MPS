package jetbrains.mps.console.ideCommands.util;

/*Generated by MPS */

import com.intellij.openapi.project.Project;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.console.tool.ConsoleStream;
import jetbrains.mps.generator.impl.plan.GenerationPlan;
import java.util.Map;
import jetbrains.mps.project.structure.modules.mappingpriorities.MappingPriorityRule;
import jetbrains.mps.generator.runtime.TemplateModule;
import java.util.HashMap;
import java.util.Collection;
import jetbrains.mps.generator.runtime.TemplateMappingPriorityRule;
import jetbrains.mps.ide.messages.MessagesViewTool;
import jetbrains.mps.messages.Message;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.util.Pair;
import jetbrains.mps.generator.impl.plan.GenerationPartitioningUtil;
import jetbrains.mps.generator.runtime.TemplateMappingConfiguration;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.MPSModuleRepository;
import java.util.ArrayList;
import jetbrains.mps.generator.impl.plan.ConnectedComponentPartitioner;

public class PartitioningHelper {
  public static void showMappingPartitioning(Project project, List<SModel> models, ConsoleStream console) {
    // no multiple input models 
    SModel inputModel = models.get(0);

    GenerationPlan plan = new GenerationPlan(inputModel);


    Map<MappingPriorityRule, TemplateModule> myRule2Generator = new HashMap<MappingPriorityRule, TemplateModule>();
    for (TemplateModule generator : plan.getGenerators()) {
      Collection<TemplateMappingPriorityRule> priorities = generator.getPriorities();
      if (priorities == null) {
        continue;
      }
      for (TemplateMappingPriorityRule rule : priorities) {
        myRule2Generator.put((MappingPriorityRule) rule, generator);
      }
    }
    MessagesViewTool messagesView = project.getComponent(MessagesViewTool.class);
    messagesView.resetAutoscrollOption();
    // print all rules 
    messagesView.add(new Message(MessageKind.INFORMATION, "================================="));
    for (TemplateModule generator : plan.getGenerators()) {
      Collection<TemplateMappingPriorityRule> rules = generator.getPriorities();
      if (rules == null) {
        continue;
      }
      List<Pair<MappingPriorityRule, String>> strings = GenerationPartitioningUtil.toStrings(rules, true);
      for (Pair<MappingPriorityRule, String> string : strings) {
        Message msg = new Message(MessageKind.INFORMATION, " " + string.o2);
        msg.setHintObject(generator.getReference());
        messagesView.add(msg);
      }
    }
    messagesView.add(new Message(MessageKind.INFORMATION, "================================="));
    if (plan.hasConflictingPriorityRules()) {
      // message view 
      messagesView.openToolLater(true);
      messagesView.add(new Message(MessageKind.ERROR, PartitioningHelper.class, "Conflicting mapping priority rules encountered:"));
      console.addText("Conflicting mapping priority rules encountered:\n\n");
      List<Pair<MappingPriorityRule, String>> messagesFull = plan.getConflictingPriorityRulesAsStrings();
      for (Pair<MappingPriorityRule, String> message : messagesFull) {
        Message msg = new Message(MessageKind.ERROR, PartitioningHelper.class, message.o2);
        TemplateModule templateModule = myRule2Generator.get(message.o1);
        msg.setHintObject(templateModule.getReference());
        messagesView.add(msg);
        console.addText(String.format("%s\n", message.o2));
      }
      console.addText("=================================\n");
      messagesView.add(new Message(MessageKind.INFORMATION, "================================="));
    }
    // show partitioning 
    console.addText("---------------------  mappings partitioning  -----------------------------------\n\n");
    for (int step = 0; step < plan.getStepCount(); step++) {
      List<TemplateMappingConfiguration> mappingSet = plan.getMappingConfigurations(step);
      console.addText(" [ " + (step + 1) + " ]\n");
      List<Pair<String, TemplateMappingConfiguration>> strings = GenerationPartitioningUtil.toStrings(mappingSet);
      for (Pair<String, TemplateMappingConfiguration> string : strings) {
        SNode node = SConceptOperations.createNewNode("jetbrains.mps.console.ideCommands.structure.ClickableGenerator", null);
        SPropertyOperations.set(node, "moduleId", string.o2.getModel().getSModelReference().resolve(MPSModuleRepository.getInstance()).getModule().getModuleId().toString());
        SPropertyOperations.set(node, "text", string.o1);
        console.addText(" ");
        console.addNode(node);
        console.addText("\n");
      }
      console.addText("\n");
    }
    console.addText("---------------------------------------------------------------------------------\n");

    // other 
    List<SNode> roots = new ArrayList<SNode>();
    for (SModel md : models) {
      SModel model = md;
      for (SNode root : model.getRootNodes()) {
        roots.add(root);
      }
    }
    ConnectedComponentPartitioner ccp = new ConnectedComponentPartitioner(roots);
    console.addText(ccp.toString());

    // viewTool.append("---------- conflicts ------------\n"); 
    //   
    // Map<String, String> existing = new HashMap<String, String>(); 
    // MPSModuleRepository repo = MPSModuleRepository.getInstance(); 
    // for(Generator g : repo.getAllGenerators()) { 
    //  List<SModel> templateModels = g.getOwnTemplateModels(); 
    //  for (SModel templateModel : templateModels) { 
    //    SModel m = templateModel; 
    //    for(SNode root : m.getRoots()) { 
    //      for(SNode node : root.getDescendants(new IsInstanceCondition(MappingLabelDeclaration.concept))){ 
    //        MappingLabelDeclaration label = (MappingLabelDeclaration) node.getAdapter(); 
    //        String name = label.getName(); 
    //        String descr = "model = " + m.toString() + ", root =" + root.toString(); 
    //        if(existing.containsKey(name)) { 
    //          viewTool.append("conflict: name = " + name + ", " + descr + ": with + " + existing.get(name) + "\n"); 
    //        } else { 
    //          existing.put(name, descr); 
    //        } 
    //      } 
    //    } 
    //  } 
    // } 
  }
}
