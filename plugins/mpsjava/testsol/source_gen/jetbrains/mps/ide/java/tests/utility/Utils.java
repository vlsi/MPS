package jetbrains.mps.ide.java.tests.utility;

/*Generated by MPS */

import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.project.ModuleId;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.textGen.TextGenerationResult;
import jetbrains.mps.textGen.TextGenerationUtil;
import jetbrains.mps.project.ProjectOperationContext;
import jetbrains.mps.tool.builder.FileMPSProject;
import java.io.File;
import jetbrains.mps.util.PathManager;
import jetbrains.mps.ide.java.newparser.JavaParser;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.SModelReference;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.ide.java.newparser.FeatureKind;
import junit.framework.Assert;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.lang.test.matcher.NodeDifference;
import jetbrains.mps.lang.test.matcher.NodesMatcher;
import jetbrains.mps.ide.java.newparser.JavaParseException;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.ide.java.sourceStubs.JavaSourceStubModelRoot;
import java.util.Iterator;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.ide.java.newparser.DirParser;
import jetbrains.mps.baseLanguage.stubs.JavaStubs;
import jetbrains.mps.project.SModelRoot;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.behavior.Classifier_Behavior;

public class Utils {
  private static IModule ourModule = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("c3786d2b-aba2-45e5-8de0-1124fd14259b"));

  public Utils() {
  }

  public static String generateCode(SNode node) {
    TextGenerationResult res = TextGenerationUtil.generateText(new ProjectOperationContext(new FileMPSProject(new File(PathManager.getHomePath()))), node);
    return (String) res.getResult();
  }

  /**
   * Currently doesn't work very well: DynamicReference resolving doesn't seem to happen.
   */
  public static void checkString(String code, SNode expected) {
    try {
      JavaParser parser = new JavaParser();
      SModel mdl;
      mdl = SModelRepository.getInstance().getModelDescriptor(new SModelReference("jetbrains.mps.ide.java.testMaterial.placeholder", "")).getSModel();
      List<SNode> res = parser.parse(code, SModelOperations.getModelName(mdl), FeatureKind.CLASS_STUB, true).getNodes();
      Assert.assertSame(ListSequence.fromList(res).count(), 1);

      SNode result = SNodeOperations.cast(res.get(0), "jetbrains.mps.baseLanguage.structure.Classifier");
      SModelOperations.addRootNode(mdl, result);

      NodePatcher.removeStatements(expected);
      NodePatcher.fixNonStatic(expected);
      NodePatcher.fixNonStatic(result);
      NodePatcher.copyImportAttrs(result, expected);

      Map<SNode, SNode> nodeMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      buildClassifierNodeMap(result, expected, nodeMap);
      NodeDifference diff = NodesMatcher.matchNodes(result, expected, nodeMap);

      Assert.assertEquals(null, diff);

    } catch (JavaParseException e) {
      throw new RuntimeException(e);
    }
  }

  public static void checkFileAsString(File source, SNode expected) {
    String code = FileUtil.read(source);
    checkString(code, expected);
  }

  public static void checkFile(String path, SNode expected) {

    JavaSourceStubModelRoot mr = new JavaSourceStubModelRoot();
    mr.setModule(ourModule);
    mr.setPath(path);

    Iterator<org.jetbrains.mps.openapi.model.SModel> models = mr.loadModels().iterator();
    Assert.assertTrue("No models returned from model root", models.hasNext());

    Iterator<? extends SNode> roots = models.next().getRootNodes().iterator();
    Assert.assertTrue("The model has no roots", roots.hasNext());
    SNode result = SNodeOperations.cast((roots.next()), "jetbrains.mps.baseLanguage.structure.Classifier");

    NodePatcher.removeStatements(expected);
    NodePatcher.fixNonStatic(expected);
    NodePatcher.fixNonStatic(result);
    NodePatcher.copyImportAttrs(result, expected);
    // <node> 
    // <node> 

    Assert.assertEquals(null, NodesMatcher.matchNodes(ListSequence.fromListAndArray(new ArrayList<SNode>(), expected), ListSequence.fromListAndArray(new ArrayList<SNode>(), result)));

  }

  public static void checkStubModel(String dirPath, SModel expected) {
    checkStubModels(dirPath, ListSequence.fromListAndArray(new ArrayList<SModel>(), expected));
  }

  public static void checkStubModels(String dirPath, List<SModel> expected) {

    JavaSourceStubModelRoot mr = new JavaSourceStubModelRoot();
    mr.setModule(ourModule);
    mr.setPath(dirPath);

    List<SModel> models = ListSequence.fromList(new ArrayList<SModel>());
    for (org.jetbrains.mps.openapi.model.SModel md : Sequence.fromIterable(mr.loadModels())) {
      SModel m = ((SModelDescriptor) md).getSModel();
      ListSequence.fromList(models).addElement(m);
    }

    // FIXME removeSModelAttrs is temporary (testImports2 started to have problems) 

    for (SModel m : ListSequence.fromList(models)) {
      for (SNode root : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
        NodePatcher.removeSModelAttrs(root);
      }
    }

    for (SModel m : ListSequence.fromList(expected)) {
      for (SNode root : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
        NodePatcher.removeStatements(SNodeOperations.cast(root, "jetbrains.mps.baseLanguage.structure.Classifier"));
        NodePatcher.removeSModelAttrs(root);
        // <node> 
      }
    }

    compare(models, expected);
  }

  public static void checkSourceModel(String dirPath, SModel expected) {
    try {
      // FIXME  
      JavaParser parser = new JavaParser();
      DirParser dirParser = new DirParser(ourModule, new FileMPSProject(new File(PathManager.getHomePath() + "/MPS.mpr")));
      SModel result = SModelRepository.getInstance().getModelDescriptor(new SModelReference("jetbrains.mps.ide.java.testMaterial.placeholder", "")).getSModel();
      for (SNode r : ListSequence.fromList(SModelOperations.getRoots(result, null))) {
        SNodeOperations.detachNode(r);
      }
      List<SNode> nodes = dirParser.parseDir(parser, new File(dirPath));

      for (SNode n : ListSequence.fromList(nodes)) {
        SModelOperations.addRootNode(result, n);
      }
      JavaParser.tryResolveUnknowns(nodes);
      JavaParser.tryResolveDynamicRefs(nodes);

      Map<SNode, SNode> referentMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
      buildModelNodeMap(result, expected, referentMap);

      boolean wereErrors = compare2models(result, expected, referentMap);
      Assert.assertFalse(wereErrors);

    } catch (JavaParseException e) {
      throw new RuntimeException(e);
    }
  }

  public static void compareBinAndSrcStubs(String binPath, String sourcePath) {
    JavaStubs bin = new JavaStubs();
    JavaSourceStubModelRoot src2 = new JavaSourceStubModelRoot();

    // just 2 distinct modules 
    IModule mod1 = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("c3786d2b-aba2-45e5-8de0-1124fd14259b"));
    IModule mod2 = MPSModuleRepository.getInstance().getModuleById(ModuleId.fromString("49166c31-952a-46f6-8970-ea45964379d0"));

    List<SModel> binModels = ListSequence.fromList(new ArrayList<SModel>());
    SModelRoot binSRoot = new SModelRoot();
    binSRoot.setModule(mod1);
    binSRoot.setPath(binPath);
    Collection<SModelDescriptor> binStubModels = bin.load(binSRoot);
    for (SModelDescriptor md : CollectionSequence.fromCollection(binStubModels)) {
      SModel m = md.getSModel();
      ListSequence.fromList(binModels).addElement(m);

      for (SNode binRoot : ListSequence.fromList(SModelOperations.getRoots(m, null))) {
        NodePatcher.fixNonStatic(binRoot);
        NodePatcher.removeConstructorName(binRoot);
        NodePatcher.removeExtendsObject(binRoot);
        NodePatcher.removeInitializers(binRoot);

        NodePatcher.sortNestedClass(SNodeOperations.cast(binRoot, "jetbrains.mps.baseLanguage.structure.Classifier"));

        // FIXME should be fixed in java source stubs 
        NodePatcher.removeStatements(binRoot);
      }
    }

    Iterable<org.jetbrains.mps.openapi.model.SModel> srcModels;
    List<SModel> srcModelsX = ListSequence.fromList(new ArrayList<SModel>());

    src2.setModule(mod2);
    src2.setPath(sourcePath);
    srcModels = src2.loadModels();

    for (org.jetbrains.mps.openapi.model.SModel m : Sequence.fromIterable(srcModels)) {
      // <node> 

      SModel zzz = ((SModelDescriptor) m).getSModel();
      srcModelsX.add(zzz);

      for (SNode srcRoot : ListSequence.fromList(SModelOperations.getRoots(zzz, null))) {
        NodePatcher.fixNonStatic(srcRoot);
        NodePatcher.removeSourceLevelAnnotations(srcRoot);

        NodePatcher.sortNestedClass(SNodeOperations.cast(srcRoot, "jetbrains.mps.baseLanguage.structure.Classifier"));
      }
    }

    compare(binModels, srcModelsX);
    // <node> 
  }

  public static void compare(Iterable<SModel> leftModels, Iterable<SModel> rightModels) {

    Map<String, SModel> leftModelMap = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel m : Sequence.fromIterable(leftModels)) {
      MapSequence.fromMap(leftModelMap).put(jetbrains.mps.util.SNodeOperations.getModelLongName(m), m);
    }

    Map<String, SModel> rightModelMap = MapSequence.fromMap(new HashMap<String, SModel>());
    for (SModel m : Sequence.fromIterable(rightModels)) {
      MapSequence.fromMap(rightModelMap).put(jetbrains.mps.util.SNodeOperations.getModelLongName(m), m);
    }

    Assert.assertTrue(SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet()).containsSequence(SetSequence.fromSet(MapSequence.fromMap(rightModelMap).keySet())) && SetSequence.fromSet(MapSequence.fromMap(rightModelMap).keySet()).containsSequence(SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())));

    // constructing the map of corresponding nodes 
    Map<SNode, SNode> classMap = MapSequence.fromMap(new HashMap<SNode, SNode>());
    for (String name : SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())) {
      SModel binModel = MapSequence.fromMap(leftModelMap).get(name);
      SModel srcModel = MapSequence.fromMap(rightModelMap).get(name);

      buildModelNodeMap(binModel, srcModel, classMap);
    }

    // <node> 

    boolean errors = false;

    for (String name : SetSequence.fromSet(MapSequence.fromMap(leftModelMap).keySet())) {
      SModel binModel = MapSequence.fromMap(leftModelMap).get(name);
      SModel srcModel = MapSequence.fromMap(rightModelMap).get(name);

      errors = compare2models(binModel, srcModel, classMap) || errors;
    }

    Assert.assertFalse("Models differ", errors);
  }

  public static boolean compare2models(SModel left, SModel right, Map<SNode, SNode> nodeMap) {
    boolean wereErrors = false;
    List<SNode> binRoots = SModelOperations.getRoots(left, null);
    List<SNode> srcRoots = SModelOperations.getRoots(right, null);

    binRoots = ListSequence.fromList(binRoots).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.Classifier"), "name");
      }
    }, true).toListSequence();
    srcRoots = ListSequence.fromList(srcRoots).sort(new ISelector<SNode, String>() {
      public String select(SNode it) {
        return SPropertyOperations.getString(SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.Classifier"), "name");
      }
    }, true).toListSequence();

    // <node> 
    List<NodeDifference> diff = NodesMatcher.matchNodes(binRoots, srcRoots, nodeMap);
    if (diff != null) {
      wereErrors = true;
      System.out.println("Diff: " + diff);
    }
    return wereErrors;
  }

  public static void buildModelNodeMap(SModel left, SModel right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightRootIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightRoot : ListSequence.fromList(SModelOperations.getRoots(right, null))) {
      MapSequence.fromMap(rightRootIndex).put(SPropertyOperations.getString(SNodeOperations.cast(rightRoot, "jetbrains.mps.baseLanguage.structure.IValidIdentifier"), "name"), rightRoot);
    }

    for (SNode leftRoot : ListSequence.fromList(SModelOperations.getRoots(left, null))) {
      SNode rightBrother = MapSequence.fromMap(rightRootIndex).get(SPropertyOperations.getString(SNodeOperations.cast(leftRoot, "jetbrains.mps.baseLanguage.structure.IValidIdentifier"), "name"));
      if ((rightBrother != null)) {
        NodePatcher.copyImportAttrs(leftRoot, rightBrother);
      }
      buildClassifierNodeMap(SNodeOperations.cast(leftRoot, "jetbrains.mps.baseLanguage.structure.Classifier"), SNodeOperations.cast(rightBrother, "jetbrains.mps.baseLanguage.structure.Classifier"), nodeMap);
      // <node> 
    }
  }

  public static void buildClassifierNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {
    // handling this class and nested classes 
    Map<String, SNode> rightNestedIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode cl : ListSequence.fromList(SNodeOperations.getDescendants(right, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{}))) {
      MapSequence.fromMap(rightNestedIndex).put(SPropertyOperations.getString(cl, "name"), cl);
    }

    for (SNode cl : ListSequence.fromList(SNodeOperations.getDescendants(left, "jetbrains.mps.baseLanguage.structure.Classifier", true, new String[]{}))) {
      SNode rightBrother = SNodeOperations.cast(MapSequence.fromMap(rightNestedIndex).get(SPropertyOperations.getString(cl, "name")), "jetbrains.mps.baseLanguage.structure.Classifier");

      // <node> 

      Assert.assertNull(MapSequence.fromMap(nodeMap).get(cl));
      MapSequence.fromMap(nodeMap).put(cl, rightBrother);

      buildJustNodeMap(SLinkOperations.getTargets(left, "typeVariableDeclaration", true), SLinkOperations.getTargets(right, "typeVariableDeclaration", true), nodeMap);
      buildMethodsNodeMap(left, right, nodeMap);

    }

    if (SNodeOperations.isInstanceOf(left, "jetbrains.mps.baseLanguage.structure.Annotation") && SNodeOperations.isInstanceOf(right, "jetbrains.mps.baseLanguage.structure.Annotation")) {
      Map<String, SNode> rightMethodIndex = MapSequence.fromMap(new HashMap<String, SNode>());
      for (SNode mthd : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(right, "jetbrains.mps.baseLanguage.structure.Annotation"), "method", true))) {
        MapSequence.fromMap(rightMethodIndex).put(SPropertyOperations.getString(mthd, "name"), mthd);
      }

      for (SNode mthd : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(left, "jetbrains.mps.baseLanguage.structure.Annotation"), "method", true))) {
        Assert.assertNull(MapSequence.fromMap(nodeMap).get(mthd));
        MapSequence.fromMap(nodeMap).put(mthd, MapSequence.fromMap(rightMethodIndex).get(SPropertyOperations.getString(mthd, "name")));
      }
    }
  }

  public static void buildMethodsNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {
    List<SNode> leftMethods = new ArrayList<SNode>();
    List<SNode> rightMethods = new ArrayList<SNode>();
    ListSequence.fromList(leftMethods).addSequence(Sequence.fromIterable(Classifier_Behavior.call_methods_5292274854859311639(left)));
    ListSequence.fromList(rightMethods).addSequence(Sequence.fromIterable(Classifier_Behavior.call_methods_5292274854859311639(right)));

    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightMthd : ListSequence.fromList(rightMethods)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightMthd, "name"), rightMthd);
    }

    for (SNode leftMthd : ListSequence.fromList(leftMethods)) {
      buildMethodBodyNodeMap(leftMthd, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftMthd, "name")), nodeMap);
      // <node> 
    }
  }

  public static void buildMethodBodyNodeMap(SNode left, SNode right, Map<SNode, SNode> nodeMap) {

    //  type vars 
    buildJustNodeMap(SLinkOperations.getTargets(left, "typeVariableDeclaration", true), SLinkOperations.getTargets(right, "typeVariableDeclaration", true), nodeMap);

    // local vars and params 
    List<SNode> leftVars = new ArrayList<SNode>();
    ListSequence.fromList(leftVars).addSequence(ListSequence.fromList(SLinkOperations.getTargets(left, "parameter", true)));
    ListSequence.fromList(leftVars).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(left, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", false, new String[]{"jetbrains.mps.baseLanguage.structure.AnonymousClass"})));

    List<SNode> rightVars = new ArrayList<SNode>();
    ListSequence.fromList(rightVars).addSequence(ListSequence.fromList(SLinkOperations.getTargets(right, "parameter", true)));
    ListSequence.fromList(rightVars).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(right, "jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration", false, new String[]{"jetbrains.mps.baseLanguage.structure.AnonymousClass"})));

    buildJustNodeMap(leftVars, rightVars, nodeMap);

    // anonymous classes and their insides 


  }

  public static void buildJustNodeMap(List<SNode> left, List<SNode> right, Map<SNode, SNode> nodeMap) {
    Map<String, SNode> rightIndex = MapSequence.fromMap(new HashMap<String, SNode>());
    for (SNode rightNode : ListSequence.fromList(right)) {
      MapSequence.fromMap(rightIndex).put(SPropertyOperations.getString(rightNode, "name"), rightNode);
    }

    for (SNode leftNode : ListSequence.fromList(left)) {
      // <node> 
      MapSequence.fromMap(nodeMap).put(leftNode, MapSequence.fromMap(rightIndex).get(SPropertyOperations.getString(leftNode, "name")));
    }
  }
}
