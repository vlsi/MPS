package jetbrains.mps.ide.java.platform.refactorings;

/*Generated by MPS */

import jetbrains.mps.smodel.IOperationContext;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import java.util.List;
import java.util.ArrayList;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import jetbrains.mps.ide.project.ProjectHelper;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.baseLanguage.util.plugin.refactorings.MethodRefactoringUtils;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.util.plugin.refactorings.InlineMethodRefactoring;

public class InlineMethodRefactoringAnalyzer {
  private IOperationContext myOperationContext;
  private SNode myCall;
  private SNode myMethod;

  public InlineMethodRefactoringAnalyzer(IOperationContext operationContext, SNode call, SNode method) {
    this.myOperationContext = operationContext;
    this.myCall = call;
    this.myMethod = method;
  }

  public String findProblems(final SearchResults<SNode> ussages) {
    final Wrappers._T<List<SNode>> myOverriding = new Wrappers._T<List<SNode>>(new ArrayList<SNode>());
    ProgressManager.getInstance().run(new Task.Modal(ProjectHelper.toIdeaProject(InlineMethodRefactoringAnalyzer.this.myOperationContext.getProject()), "Search for overriding methods", true) {
      public void run(@NotNull final ProgressIndicator indicator) {
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            myOverriding.value = MethodRefactoringUtils.findOverridingMethods(InlineMethodRefactoringAnalyzer.this.myMethod, InlineMethodRefactoringAnalyzer.this.myOperationContext, new ProgressMonitorAdapter(indicator));
          }
        });
      }
    });
    final StringBuffer errors = new StringBuffer();
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        errors.append(InlineMethodRefactoringAnalyzer.this.getOverridingErrors(myOverriding.value));
        if (ussages != null) {
          for (SearchResult<SNode> res : ListSequence.fromList(ussages.getSearchResults())) {
            InlineMethodRefactoringAnalyzer.this.appendRefactoringProblems(res.getObject(), errors);
          }
        } else {
          InlineMethodRefactoringAnalyzer.this.appendRefactoringProblems(InlineMethodRefactoringAnalyzer.this.myCall, errors);
        }
      }
    });
    return errors.toString();
  }

  private String getOverridingErrors(List<SNode> overridingMethods) {
    StringBuffer errors = new StringBuffer();
    if (overridingMethods != null && ListSequence.fromList(overridingMethods).count() > 0) {
      errors.append("Inlined method overriden by this methods: ");
      for (SNode methodDeclaration : ListSequence.fromList(overridingMethods)) {
        errors.append(" ").append(SNodeOperations.getParent(methodDeclaration)).append(".").append(methodDeclaration);
      }
      errors.append(".\n");
    }
    return errors.toString();
  }

  private void appendRefactoringProblems(SNode node, StringBuffer errors) {
    InlineMethodRefactoring ref = new InlineMethodRefactoring(node);
    errors.append(ref.getProblems());
  }
}
