package jetbrains.mps.ide.java.platform.index;

/*Generated by MPS */

import com.intellij.util.indexing.FileBasedIndexExtension;
import jetbrains.mps.workbench.index.SNodeEntry;
import java.util.List;
import com.intellij.util.indexing.ID;
import org.jetbrains.mps.openapi.model.SNode;
import com.intellij.util.indexing.FileBasedIndex;
import com.intellij.psi.search.GlobalSearchScope;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.annotations.NotNull;
import com.intellij.util.io.KeyDescriptor;
import jetbrains.mps.workbench.index.SNodeEntryKeyDescriptor;
import com.intellij.util.io.DataExternalizer;
import jetbrains.mps.workbench.index.SNodeEntryExternalizer;
import java.io.DataOutput;
import java.io.IOException;
import java.io.DataInput;
import com.intellij.util.indexing.DataIndexer;
import com.intellij.util.indexing.FileContent;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.fileTypes.MPSFileTypeFactory;
import java.util.Map;
import jetbrains.mps.extapi.model.SModelData;
import jetbrains.mps.workbench.index.RootNodeNameIndex;
import java.util.Collections;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.apache.log4j.Logger;
import org.jetbrains.mps.openapi.model.SReference;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.util.ArrayList;
import jetbrains.mps.smodel.SNodePointer;

public class ClassifierSuccessorsIndexer extends FileBasedIndexExtension<SNodeEntry, List<SNodeEntry>> {
  private static final ID<SNodeEntry, List<SNodeEntry>> NAME = ID.create("mps.ClassifierSuccessors");

  /*package*/ static void processValues(SNode nextClassifier, FileBasedIndex.ValueProcessor<List<SNodeEntry>> valueProcessor, GlobalSearchScope filter) {
    FileBasedIndex.getInstance().processValues(NAME, new SNodeEntry(SNodeOperations.getPointer(nextClassifier)), null, valueProcessor, filter);
  }

  @NotNull
  @Override
  public ID<SNodeEntry, List<SNodeEntry>> getName() {
    return NAME;
  }

  @Override
  public int getVersion() {
    return 1;
  }

  @Override
  public boolean dependsOnFileContent() {
    return true;
  }

  @Override
  @NotNull
  public FileBasedIndex.InputFilter getInputFilter() {
    return new ClassifierSuccessorsIndexer.InputFilter();
  }

  @Override
  @NotNull
  public KeyDescriptor<SNodeEntry> getKeyDescriptor() {
    return new SNodeEntryKeyDescriptor();
  }

  @Override
  @NotNull
  public DataExternalizer<List<SNodeEntry>> getValueExternalizer() {
    return new DataExternalizer<List<SNodeEntry>>() {
      private final SNodeEntryExternalizer myExternalizer = new SNodeEntryExternalizer(false);

      public void save(@NotNull DataOutput out, List<SNodeEntry> values) throws IOException {
        myExternalizer.saveMany(out, values);
      }
      public List<SNodeEntry> read(@NotNull DataInput in) throws IOException {
        return myExternalizer.readMany(in);
      }
    };
  }

  @NotNull
  @Override
  public DataIndexer<SNodeEntry, List<SNodeEntry>, FileContent> getIndexer() {
    return new ClassifierSuccessorsIndexer.Indexer();
  }

  private static class InputFilter implements FileBasedIndex.InputFilter {
    @Override
    public boolean acceptInput(VirtualFile file) {
      return MPSFileTypeFactory.MPS_FILE_TYPE.equals(file.getFileType());
    }
  }

  private static class Indexer implements DataIndexer<SNodeEntry, List<SNodeEntry>, FileContent> {
    @NotNull
    @Override
    public Map<SNodeEntry, List<SNodeEntry>> map(final FileContent inputData) {
      try {
        SModelData modelData = RootNodeNameIndex.doModelParsing(inputData);
        // e.g. model with merge conflict 
        if (modelData == null) {
          return Collections.emptyMap();
        }

        SModelReference modelReference = modelData.getReference();
        final Map<SNodeEntry, List<SNodeEntry>> result = MapSequence.fromMap(new HashMap<SNodeEntry, List<SNodeEntry>>());
        for (final SNode nextNode : SNodeUtil.getDescendants(modelData.getRootNodes())) {
          if (SNodeOperations.isInstanceOf(nextNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"))) {
            SNode classNode = SNodeOperations.as(nextNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, "jetbrains.mps.baseLanguage.structure.ClassConcept"));
            SNode superclass = SLinkOperations.getTarget(classNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass"));
            if (superclass != null) {
              safeMap(result, superclass, modelReference, classNode);
            }
            for (SNode implementedInterface : ListSequence.fromList(SLinkOperations.getChildren(classNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0xff2ac0b419L, "implementedInterface")))) {
              safeMap(result, implementedInterface, modelReference, classNode);
            }
            if (SNodeOperations.isInstanceOf(classNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass"))) {
              safeMap(result, SNodeOperations.getReference(SNodeOperations.as(classNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, "jetbrains.mps.baseLanguage.structure.AnonymousClass")), MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x1107e0cb103L, 0x1107e0fd2a0L, "classifier")), modelReference, classNode);
            }
          } else if (SNodeOperations.isInstanceOf(nextNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"))) {
            SNode interfaceNode = SNodeOperations.as(nextNode, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, "jetbrains.mps.baseLanguage.structure.Interface"));
            for (SNode extendedInterface : ListSequence.fromList(SLinkOperations.getChildren(interfaceNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, 0x101eddadad7L, "extendedInterface")))) {
              safeMap(result, extendedInterface, modelReference, interfaceNode);
            }
          }
        }
        return result;
      } catch (Exception ex) {
        Logger.getLogger(ClassifierSuccessorsIndexer.class).error(String.format("Failed to index model file %s; %s", inputData.getFileName(), ex.getMessage()), ex);
      }
      return Collections.emptyMap();
    }

    private void safeMap(Map<SNodeEntry, List<SNodeEntry>> result, SNode classifierType, SModelReference modelReference, SNode node) {
      safeMap(result, SNodeOperations.getReference(classifierType, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")), modelReference, node);
    }

    private void safeMap(Map<SNodeEntry, List<SNodeEntry>> result, SReference reference, SModelReference modelReference, SNode node) {
      SNodeReference targetNode = (reference == null ? null : reference.getTargetNodeReference());
      if (targetNode == null) {
        return;
      }
      SNodeEntry key = new SNodeEntry(targetNode);
      List<SNodeEntry> successors = MapSequence.fromMap(result).get(key);
      if (successors == null) {
        successors = new ArrayList<SNodeEntry>();
        MapSequence.fromMap(result).put(key, successors);
      }
      // being carefull with SNodePointer because node is not in a model 
      SNodePointer nodePointer = new SNodePointer(modelReference, node.getNodeId());
      successors.add(new SNodeEntry(nodePointer));
    }
  }
}
