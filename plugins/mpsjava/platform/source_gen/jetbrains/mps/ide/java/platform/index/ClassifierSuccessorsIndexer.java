package jetbrains.mps.ide.java.platform.index;

/*Generated by MPS */

import com.intellij.util.indexing.FileBasedIndexExtension;
import java.util.List;
import com.intellij.util.indexing.ID;
import com.intellij.util.indexing.FileBasedIndex;
import com.intellij.util.io.KeyDescriptor;
import com.intellij.util.io.DataExternalizer;
import com.intellij.util.indexing.DataIndexer;
import com.intellij.util.indexing.FileContent;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.vfs.VirtualFile;
import jetbrains.mps.fileTypes.MPSFileTypeFactory;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.smodel.ModelAccess;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.workbench.goTo.index.RootNodeNameIndex;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SNodeUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.model.SReference;
import java.util.ArrayList;

public class ClassifierSuccessorsIndexer extends FileBasedIndexExtension<GlobalSNodeId, List<GlobalSNodeId>> {
  public static final ID<GlobalSNodeId, List<GlobalSNodeId>> NAME = ID.create("jetbrains.mps.ClassifierSuccessorsIndexer");
  private FileBasedIndex.InputFilter myInputFilter = new ClassifierSuccessorsIndexer.InputFilter();
  private KeyDescriptor<GlobalSNodeId> myKeyDescriptor = new GlobalSNodeIdDescriptor();
  private DataExternalizer<List<GlobalSNodeId>> myDataExternalizer = new ListExternalizer<GlobalSNodeId>(myKeyDescriptor);
  private DataIndexer<GlobalSNodeId, List<GlobalSNodeId>, FileContent> myIndexer = new ClassifierSuccessorsIndexer.Indexer();

  @NotNull
  @Override
  public ID<GlobalSNodeId, List<GlobalSNodeId>> getName() {
    return NAME;
  }

  @Override
  public int getVersion() {
    return 5;
  }

  @Override
  public boolean dependsOnFileContent() {
    return true;
  }

  @Override
  @NotNull
  public FileBasedIndex.InputFilter getInputFilter() {
    return myInputFilter;
  }

  @Override
  @NotNull
  public KeyDescriptor<GlobalSNodeId> getKeyDescriptor() {
    return myKeyDescriptor;
  }

  @Override
  @NotNull
  public DataExternalizer<List<GlobalSNodeId>> getValueExternalizer() {
    return myDataExternalizer;
  }

  @NotNull
  @Override
  public DataIndexer<GlobalSNodeId, List<GlobalSNodeId>, FileContent> getIndexer() {
    return myIndexer;
  }

  private static class InputFilter implements FileBasedIndex.InputFilter {
    private InputFilter() {
    }
    @Override
    public boolean acceptInput(VirtualFile file) {
      return MPSFileTypeFactory.MPS_FILE_TYPE.equals(file.getFileType());
    }
  }

  private static class Indexer implements DataIndexer<GlobalSNodeId, List<GlobalSNodeId>, FileContent> {
    @NotNull
    @Override
    public Map<GlobalSNodeId, List<GlobalSNodeId>> map(final FileContent inputData) {
      final Map<GlobalSNodeId, List<GlobalSNodeId>> result = MapSequence.fromMap(new HashMap<GlobalSNodeId, List<GlobalSNodeId>>());
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          // todo remove this read after 3.2. Needed to get concept fq name from id in 3.2 
          SModel sModel = RootNodeNameIndex.doModelParsing(inputData);
          // e.g. model with merge conflict 
          if (sModel == null) {
            return;
          }

          for (final SNode nextNode : SNodeUtil.getDescendants(sModel)) {
            if (isInstanceOfClassConcept(nextNode)) {
              SNode classNode = (SNode) nextNode;
              if (SLinkOperations.getTarget(classNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass")) != null) {
                safeMap(result, SLinkOperations.getTarget(classNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0x10f6353296dL, "superclass")), classNode);
              }
              for (SNode implementedInterface : ListSequence.fromList(SLinkOperations.getChildren(classNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca66L, 0xff2ac0b419L, "implementedInterface")))) {
                safeMap(result, implementedInterface, classNode);
              }
              if (isInstanceOfAnonymousClassConcept(classNode)) {
                safeMap(result, classNode.getReference("classifier"), classNode);
              }
            } else if (isInstanceOfInterfaceConcept(nextNode)) {
              SNode interfaceNode = (SNode) nextNode;
              for (SNode extendedInterface : ListSequence.fromList(SLinkOperations.getChildren(interfaceNode, MetaAdapterFactory.getContainmentLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101edd46144L, 0x101eddadad7L, "extendedInterface")))) {
                safeMap(result, extendedInterface, interfaceNode);
              }
            }
          }
        }
      });
      return result;
    }

    private void safeMap(Map<GlobalSNodeId, List<GlobalSNodeId>> result, SNode classifierType, SNode node) {
      safeMap(result, classifierType.getReference("classifier"), node);
    }

    private void safeMap(Map<GlobalSNodeId, List<GlobalSNodeId>> result, SReference reference, SNode node) {
      GlobalSNodeId key = GlobalSNodeId.createSNodeId(reference);
      if (key == null) {
        return;
      }
      List<GlobalSNodeId> successors = MapSequence.fromMap(result).get(key);
      if (successors == null) {
        successors = ListSequence.fromList(new ArrayList<GlobalSNodeId>());
        MapSequence.fromMap(result).put(key, successors);
      }
      ListSequence.fromList(successors).addElement(GlobalSNodeId.createSNodeId(node));
    }

    private boolean isInstanceOfClassConcept(SNode node) {
      String conceptFQName = node.getConcept().getQualifiedName();
      return "jetbrains.mps.baseLanguage.structure.ClassConcept".equals(conceptFQName) || "jetbrains.mps.baseLanguage.structure.AnonymousClass".equals(conceptFQName) || "jetbrains.mps.baseLanguage.structure.EnumClass".equals(conceptFQName) || "jetbrains.mps.baseLanguageInternal.structure.ExtractStaticInnerClassConcept".equals(conceptFQName) || "jetbrains.mps.baseLanguage.unitTest.structure.BTestCase".equals(conceptFQName);
    }

    private boolean isInstanceOfAnonymousClassConcept(SNode node) {
      return "jetbrains.mps.baseLanguage.structure.AnonymousClass".equals(node.getConcept().getQualifiedName());
    }

    private boolean isInstanceOfInterfaceConcept(SNode node) {
      String conceptFQName = node.getConcept().getQualifiedName();
      return "jetbrains.mps.baseLanguage.structure.Interface".equals(conceptFQName) || "jetbrains.mps.baseLanguage.structure.Annotation".equals(conceptFQName);
    }
  }
}
