package jetbrains.mps.vcs.diff.ui.merge;

/*Generated by MPS */

import com.intellij.openapi.ui.DialogWrapper;
import javax.swing.Icon;
import com.intellij.icons.AllIcons;
import com.intellij.openapi.project.Project;
import jetbrains.mps.vcs.diff.merge.MergeSession;
import jetbrains.mps.vcs.diff.merge.MergeSessionState;
import org.jetbrains.mps.openapi.model.SNodeId;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import com.intellij.ui.JBSplitter;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import com.intellij.openapi.actionSystem.ActionToolbar;
import com.intellij.openapi.diff.ex.DiffStatusBar;
import com.intellij.openapi.diff.impl.util.TextDiffType;
import com.intellij.openapi.actionSystem.DefaultActionGroup;
import jetbrains.mps.vcs.diff.ui.common.GoToNeighbourRootActions;
import java.util.Set;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.smodel.SModel;
import com.intellij.openapi.diff.DiffRequest;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.vcs.diff.ui.common.DiffTemporaryModule;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.vcs.diff.ui.MetadataUtil;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.workbench.action.ActionUtils;
import jetbrains.mps.vcs.diff.ui.common.InvokeTextDiffAction;
import com.intellij.openapi.diff.impl.mergeTool.MergeTool;
import com.intellij.openapi.actionSystem.Separator;
import org.jetbrains.annotations.Nullable;
import com.intellij.ui.ScrollPaneFactory;
import com.intellij.openapi.actionSystem.ActionManager;
import com.intellij.openapi.actionSystem.ActionPlaces;
import java.awt.Dimension;
import com.intellij.openapi.util.DimensionService;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.MetadataChange;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.annotations.NotNull;
import javax.swing.Action;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.vcs.diff.ui.common.DiffModelTree;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.util.NameUtil;
import javax.swing.event.TreeSelectionListener;
import javax.swing.event.TreeSelectionEvent;
import jetbrains.mps.workbench.action.BaseAction;
import java.util.Arrays;
import jetbrains.mps.vcs.diff.changes.ChangeType;
import com.intellij.ui.SimpleTextAttributes;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.vcs.diff.ui.common.ChangeColors;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.SModelDescriptor;

public class MergeModelsDialog extends DialogWrapper {
  public static final Icon APPLY_NON_CONFLICTS = AllIcons.Diff.ApplyNotConflicts;
  public static final Icon RESET = AllIcons.Actions.Rollback;

  private Project myProject;
  private MergeSession myMergeSession;
  private MergeSession myMetadataMergeSession;
  private MergeSessionState myInitialState;
  private MergeSessionState myMetadataInitialState;
  private SNodeId myRootId;

  private MergeModelsDialog.MergeModelsTree myMergeTree;
  private JPanel myComponent = new JPanel(new BorderLayout());
  private JBSplitter myPanel = new JBSplitter(true, 0.25f);
  private MergeRootsPane myMergeRootsPane = null;
  private final JComponent myNoRootPanel = new JLabel("Select root to merge", SwingConstants.CENTER);
  private ActionToolbar myToolbar;
  private DiffStatusBar myStatusBar = new DiffStatusBar(TextDiffType.DIFF_TYPES);

  private DefaultActionGroup myActionGroup;
  private GoToNeighbourRootActions myGoToNeighbourRootActions;

  private String[] myContentTitles;
  private boolean myApplyChanges = false;
  private Set<ModelChange> myAppliedMetadataChanges = SetSequence.fromSet(new HashSet<ModelChange>());


  public MergeModelsDialog(final SModel baseModel, final SModel mineModel, final SModel repositoryModel, DiffRequest request) {
    super(request.getProject(), true);
    setTitle("Merging " + baseModel.getModelDescriptor().getModelName());
    myProject = request.getProject();
    myContentTitles = request.getContentTitles();
    assert myContentTitles.length == 3;
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        myMergeSession = MergeSession.createMergeSession(baseModel, mineModel, repositoryModel);
      }
    });
    DiffTemporaryModule.setSModelId(myMergeSession.getResultModel(), "result");
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        myInitialState = myMergeSession.getCurrentState();
      }
    });
    if (ListSequence.fromList(myMergeSession.getMetadataChanges()).isNotEmpty()) {
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          final SModel baseMetaModel = MetadataUtil.createMetadataModel(baseModel);
          final SModel mineMetaModel = MetadataUtil.createMetadataModel(mineModel);
          final SModel repoMetaModel = MetadataUtil.createMetadataModel(repositoryModel);
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              myMetadataMergeSession = MergeSession.createMergeSession(baseMetaModel, mineMetaModel, repoMetaModel);
            }
          });
          DiffTemporaryModule.setSModelId(myMetadataMergeSession.getResultModel(), "result");
          myMetadataInitialState = myMetadataMergeSession.getCurrentState();
        }
      });
    }
    final jetbrains.mps.project.Project p = ProjectHelper.toMPSProject(myProject);
    DiffTemporaryModule.createModuleForModel(myMergeSession.getResultModel(), "result", p, true);
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        DiffTemporaryModule.registerModel(myMergeSession.getResultModel().getModelDescriptor(), p);
      }
    });

    myMergeSession.installResultModelListener();
    DiffTemporaryModule.createModuleForModel(mineModel, "mine", p);
    DiffTemporaryModule.createModuleForModel(repositoryModel, "repository", p);
    if (myMetadataMergeSession != null) {
      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getResultModel(), "result", p, true);
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          DiffTemporaryModule.registerModel(myMetadataMergeSession.getResultModel().getModelDescriptor(), p);
        }
      });
      myMetadataMergeSession.installResultModelListener();
      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getMyModel(), "mine", p);
      DiffTemporaryModule.createModuleForModel(myMetadataMergeSession.getRepositoryModel(), "repository", p);
    }

    myActionGroup = ActionUtils.groupFromActions(new InvokeTextDiffAction("Merge as Text (Use Carefully!)", "Merge models using text merge for XML contents", this, request, new MergeTool()), Separator.getInstance(), new ResetState(this), new MergeNonConflictingRoots(this), Separator.getInstance(), AcceptYoursTheirs.yoursInstance(this), AcceptYoursTheirs.theirsInstance(this));

    init();
  }



  @Nullable
  @Override
  protected JComponent createCenterPanel() {
    myPanel.setSplitterProportionKey(getClass().getName() + "ModelTreeSplitter");
    myMergeTree = new MergeModelsDialog.MergeModelsTree();
    myPanel.setFirstComponent(ScrollPaneFactory.createScrollPane(myMergeTree));
    myPanel.setSecondComponent(myNoRootPanel);

    myGoToNeighbourRootActions = new MergeModelsDialog.MyGoToNeighbourRootActions();
    myGoToNeighbourRootActions.previous().registerCustomShortcutSet(GoToNeighbourRootActions.PREV_ROOT_SHORTCUT, myComponent);
    myGoToNeighbourRootActions.next().registerCustomShortcutSet(GoToNeighbourRootActions.NEXT_ROOT_SHORTCUT, myComponent);

    myToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, myActionGroup, true);
    myToolbar.updateActionsImmediately();

    myComponent.add(myToolbar.getComponent(), BorderLayout.NORTH);
    myComponent.add(myPanel, BorderLayout.CENTER);
    myComponent.add(myStatusBar, BorderLayout.SOUTH);

    final Dimension size = DimensionService.getInstance().getSize(getDimensionServiceKey());
    if (size == null) {
      myComponent.setPreferredSize(new Dimension(500, 450));
    }

    return myComponent;
  }

  @Override
  public String getDimensionServiceKey() {
    return getClass().getName();
  }

  @Nullable
  @Override
  public JComponent getPreferredFocusedComponent() {
    return myMergeTree;
  }

  @Override
  protected void doOKAction() {
    applyMetadataChanges();

    MergeConfirmation.showMergeConfirmationAndTakeAction(this, myMergeSession, Sequence.fromIterable(myMergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(ch instanceof MetadataChange);
      }
    }), myMetadataMergeSession, (myMetadataMergeSession == null ?
      null :
      myMetadataMergeSession.getAllChanges()
    ), new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        mergeNonConflictingRoots();
      }
    }, new _FunctionTypes._void_P0_E0() {
      public void invoke() {
        myApplyChanges = true;
        close(OK_EXIT_CODE);
      }
    });
  }

  @Override
  @NotNull
  protected Action[] createActions() {
    List<Action> actions = ListSequence.fromList(new ArrayList<Action>());
    ListSequence.fromList(actions).addElement(getOKAction());
    ListSequence.fromList(actions).addElement(getCancelAction());
    return ListSequence.fromList(actions).toGenericArray(Action.class);
  }

  @Override
  protected void dispose() {
    if (myMergeRootsPane != null) {
      myMergeRootsPane.dispose();
    }
    super.dispose();
  }



  public SModel getResultModel() {
    return (myApplyChanges ?
      myMergeSession.getResultModel() :
      null
    );
  }

  public SModel getResultModelWithFixedId() {
    if (!(myApplyChanges)) {
      return null;
    }
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        DiffTemporaryModule.resetSModelId(myMergeSession.getResultModel().getModelDescriptor());
      }
    });
    return myMergeSession.getResultModel();
  }

  public void unregisterResultModel() {
    final SModel resultModel = myMergeSession.getResultModel();
    assert check_3qqb0l_a0b0kb(check_3qqb0l_a0a1a63(resultModel)) instanceof DiffTemporaryModule;
    ModelAccess.instance().runWriteAction(new Runnable() {
      public void run() {
        DiffTemporaryModule.unregisterModel(resultModel.getModelDescriptor(), ProjectHelper.toMPSProject(myProject));
      }
    });
    if (myMetadataMergeSession != null) {
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          DiffTemporaryModule.unregisterModel(myMetadataMergeSession.getResultModel().getModelDescriptor(), ProjectHelper.toMPSProject(myProject));
        }
      });
    }
  }

  /*package*/ void rebuildLater() {
    myToolbar.updateActionsImmediately();
    myMergeTree.rebuildLater();
  }

  /*package*/ Project getProject() {
    return myProject;
  }

  @Nullable
  public SNodeId getNeighbourRoot(@NotNull SNodeId rootId, boolean next) {
    return myMergeTree.getNeighbourRoot(rootId, next);
  }



  public void resetCurrentRoot() {
    if (myMergeRootsPane == null) {
      return;
    }

    myMergeRootsPane.unregisterShortcuts(myComponent);
    myPanel.setSecondComponent(myNoRootPanel);
    myMergeRootsPane.dispose();
    myMergeRootsPane = null;
    myRootId = null;
    myStatusBar.setText("");
    applyMetadataChanges();
  }

  private void changeCurrentRoot(@Nullable final SNodeId rootId) {
    if (myMergeRootsPane != null && myRootId == rootId) {
      return;
    }
    applyMetadataChanges();

    myRootId = rootId;
    final MergeSession session = (rootId == null ?
      myMetadataMergeSession :
      myMergeSession
    );
    final SNodeId nodeId = (rootId == null ?
      Sequence.fromIterable(myMetadataMergeSession.getAffectedRoots()).first() :
      rootId
    );
    ModelAccess.instance().runReadAction(new Runnable() {
      public void run() {
        if (myMergeRootsPane == null) {
          myMergeRootsPane = new MergeRootsPane(myProject, session, nodeId, myMergeTree.getNameForRoot(rootId), myContentTitles, myStatusBar);
          DefaultActionGroup actionGroup = new DefaultActionGroup();
          actionGroup.addAll(myMergeRootsPane.getActions());
          ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, actionGroup, true);
          myMergeRootsPane.registerShortcuts(myComponent);
          JPanel panel = new JPanel(new BorderLayout());
          panel.add(toolbar.getComponent(), BorderLayout.NORTH);
          panel.add(myMergeRootsPane.getPanel(), BorderLayout.CENTER);
          myPanel.setSecondComponent(panel);
        } else {
          myMergeRootsPane.setRoodId(nodeId, session);
        }
      }
    });
  }

  public void setCurrentRoot(@Nullable SNodeId rootId) {
    myMergeTree.setSelected(rootId);
    changeCurrentRoot(rootId);
  }

  @Nullable
  public SNodeId getCurrentRoot() {
    return myRootId;
  }



  public Iterable<ModelChange> getApplicableChangesInNonConflictingRoots() {
    return Sequence.fromIterable(myMergeSession.getApplicableChangesInNonConflictingRoots()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange it) {
        return !(it instanceof MetadataChange);
      }
    });
  }

  public Iterable<ModelChange> getApplicableChangesInMetadata() {
    return myMetadataMergeSession.getApplicableChangesInNonConflictingRoots();
  }



  public void mergeNonConflictingRoots() {
    myMergeSession.applyChanges(getApplicableChangesInNonConflictingRoots());
    if (myMetadataMergeSession != null) {
      myMetadataMergeSession.applyChanges(getApplicableChangesInMetadata());
      applyMetadataChanges();
    }
  }

  public boolean hasNonConflictingRoots() {
    return Sequence.fromIterable(getApplicableChangesInNonConflictingRoots()).isNotEmpty() || myMetadataMergeSession != null && Sequence.fromIterable(getApplicableChangesInMetadata()).isNotEmpty();
  }

  public boolean isAcceptYoursTheirsEnabled() {
    return Sequence.fromIterable(getModelChangesForSelection()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(myMergeSession.isChangeResolved(ch));
      }
    }).isNotEmpty() || myMetadataMergeSession != null && isMetadataSelected() && Sequence.fromIterable(myMetadataMergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(myMetadataMergeSession.isChangeResolved(ch));
      }
    }).isNotEmpty();
  }

  public void acceptVersionForSelectedRoots(boolean mine) {
    applyUnresolvedChanges(myMergeSession, getModelChangesForSelection(), mine);
    if (myMetadataMergeSession != null && isMetadataSelected()) {
      applyUnresolvedChanges(myMetadataMergeSession, myMetadataMergeSession.getAllChanges(), mine);
      applyMetadataChanges();
    }
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        myMergeTree.rebuildNow();
      }
    });
  }

  private void applyMetadataChanges() {
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        if (myMetadataMergeSession != null) {
          MetadataUtil.applyMetadataChanges(myMergeSession.getResultModel(), myMetadataMergeSession.getResultModel());
        }
      }
    });
  }

  private boolean isMetadataSelected() {
    return myMergeTree.getSelectedNodes(DiffModelTree.MetadataTreeNode.class, null).length == 1 || myMergeTree.getSelectedNodes(DiffModelTree.ModelTreeNode.class, null).length == 1;
  }

  private Iterable<ModelChange> getModelChangesForSelection() {
    if (myMergeTree.getSelectedNodes(DiffModelTree.ModelTreeNode.class, null).length == 1) {
      return Sequence.fromIterable(myMergeSession.getAllChanges()).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return !(ch instanceof MetadataChange);
        }
      });
    } else {
      return Sequence.fromIterable(Sequence.fromArray(myMergeTree.getSelectedNodes(DiffModelTree.RootTreeNode.class, null))).select(new ISelector<DiffModelTree.RootTreeNode, SNodeId>() {
        public SNodeId select(DiffModelTree.RootTreeNode rtn) {
          return rtn.getRootId();
        }
      }).where(new IWhereFilter<SNodeId>() {
        public boolean accept(SNodeId root) {
          return root != null;
        }
      }).translate(new ITranslator2<SNodeId, ModelChange>() {
        public Iterable<ModelChange> translate(SNodeId root) {
          return myMergeSession.getChangesForRoot(root);
        }
      });
    }
  }

  private void applyUnresolvedChanges(final MergeSession session, Iterable<ModelChange> changes, boolean mine) {
    final List<ModelChange> changesToApply = ListSequence.fromList(new ArrayList<ModelChange>());
    final List<ModelChange> changesToExclude = ListSequence.fromList(new ArrayList<ModelChange>());
    for (ModelChange change : Sequence.fromIterable(changes).where(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange ch) {
        return !(session.isChangeResolved(ch));
      }
    })) {
      if (mine == session.isMyChange(change)) {
        ListSequence.fromList(changesToApply).addElement(change);
      } else {
        ListSequence.fromList(changesToExclude).addElement(change);
      }
    }
    ModelAccess.instance().runWriteActionInCommand(new Runnable() {
      public void run() {
        session.applyChanges(changesToApply);
        session.excludeChanges(changesToExclude);
      }
    });
  }

  /*package*/ void markMetadataChangesAsApplied(Iterable<ModelChange> changes) {
    SetSequence.fromSet(myAppliedMetadataChanges).addSequence(Sequence.fromIterable(changes));
  }



  /*package*/ String[] getContentTitles() {
    return myContentTitles;
  }

  /*package*/ MergeSession getMergeSession() {
    return myMergeSession;
  }

  public void resetState() {
    myMergeSession.restoreState(myInitialState);
    if (myMetadataMergeSession != null) {
      myMetadataMergeSession.restoreState(myMetadataInitialState);
    }
    rebuildLater();
  }



  /*package*/ static String generateUnresolvedChangesText(int totalChanges, int conflictingChanges) {
    if (conflictingChanges != 0) {
      String text = NameUtil.formatNumericalString(conflictingChanges, "conficting change");
      if (totalChanges == conflictingChanges) {
        return text;
      } else {
        return text + " of " + totalChanges + " total";
      }
    } else {
      if (totalChanges == 0) {
        return "All changes resolved";
      } else {
        return NameUtil.formatNumericalString(totalChanges, " change");
      }
    }
  }



  private class MyGoToNeighbourRootActions extends GoToNeighbourRootActions.GoToByTree {
    public MyGoToNeighbourRootActions() {
      super(myMergeTree);
    }

    @Nullable
    @Override
    protected SNodeId getCurrentNodeId() {
      return getCurrentRoot();
    }

    @Override
    public void setCurrentNodeId(@Nullable SNodeId nodeId) {
      setCurrentRoot(nodeId);
    }
  }



  private class MergeModelsTree extends DiffModelTree {
    private MergeModelsTree() {
      super(DiffTemporaryModule.getOperationContext(myProject, myMergeSession.getResultModel()));
      addTreeSelectionListener(new TreeSelectionListener() {
        @Override
        public void valueChanged(TreeSelectionEvent event) {
          myToolbar.updateActionsImmediately();
        }
      });
    }

    @Override
    protected Iterable<BaseAction> getRootActions() {
      MergeModelsDialog md = MergeModelsDialog.this;
      return Arrays.<BaseAction>asList(AcceptYoursTheirs.yoursInstance(md), AcceptYoursTheirs.theirsInstance(md));
    }

    @Override
    protected void updateRootCustomPresentation(@NotNull DiffModelTree.RootTreeNode rootTreeNode) {
      final MergeSession session = (rootTreeNode.getRootId() == null ?
        myMetadataMergeSession :
        myMergeSession
      );
      List<ModelChange> changes = Sequence.fromIterable(((rootTreeNode.getRootId() == null ?
        myMetadataMergeSession.getAllChanges() :
        myMergeSession.getChangesForRoot(rootTreeNode.getRootId())
      ))).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return !(session.isChangeResolved(ch));
        }
      }).toListSequence();

      int conflictedCount = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return Sequence.fromIterable(session.getConflictedWith(ch)).isNotEmpty();
        }
      }).count();
      int nonConflictedCount = ListSequence.fromList(changes).count() - conflictedCount;
      ChangeType compositeChangeType = null;
      rootTreeNode.setTooltipText(generateUnresolvedChangesText(ListSequence.fromList(changes).count(), conflictedCount));
      if (conflictedCount != 0) {
        compositeChangeType = ChangeType.CONFLICTED;
        rootTreeNode.setAdditionalText("with conflicts");
      } else {
        if (nonConflictedCount == 0) {
          if (rootTreeNode.getRootId() != null && myMergeSession.getResultModel().getNode(rootTreeNode.getRootId()) == null) {
            rootTreeNode.setTextStyle(SimpleTextAttributes.STYLE_STRIKEOUT);
          } else {
            rootTreeNode.setAdditionalText(null);
          }
        } else {
          compositeChangeType = ChangeType.CHANGE;
          if (ListSequence.fromList(changes).all(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange ch) {
              return ch instanceof AddRootChange || ch instanceof DeleteRootChange;
            }
          })) {
            compositeChangeType = ListSequence.fromList(changes).first().getType();
          }

          int myChangesCount = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
            public boolean accept(ModelChange ch) {
              return session.isMyChange(ch);
            }
          }).count();
          if (myChangesCount == nonConflictedCount) {
            rootTreeNode.setAdditionalText("local");
          } else if (myChangesCount == 0) {
            rootTreeNode.setAdditionalText("remote");
          } else {
            rootTreeNode.setAdditionalText("both modified");
          }
        }
      }

      rootTreeNode.setColor((compositeChangeType == null ?
        null :
        ChangeColors.getForTree(compositeChangeType)
      ));
    }

    @Override
    protected Iterable<SModel> getModels() {
      return Arrays.asList(myMergeSession.getBaseModel(), myMergeSession.getMyModel(), myMergeSession.getRepositoryModel());
    }

    @Override
    protected Iterable<SNodeId> getAffectedRoots() {
      return myMergeSession.getAffectedRoots();
    }

    @Override
    protected boolean isMultipleRootNames() {
      return true;
    }



    @Override
    protected void onUnselect() {
      resetCurrentRoot();
    }

    @Override
    protected void onSelectRoot(@Nullable SNodeId rootId) {
      changeCurrentRoot(rootId);
    }
  }

  private static IModule check_3qqb0l_a0b0kb(SModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }

  private static SModelDescriptor check_3qqb0l_a0a1a63(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }
}
