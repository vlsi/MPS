package jetbrains.mps.vcs.diff.ui.common;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.openapi.editor.message.EditorMessageOwner;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import org.jetbrains.mps.openapi.model.SNodeId;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.vcs.diff.changes.SetPropertyChange;
import jetbrains.mps.vcs.diff.changes.NodeChange;
import jetbrains.mps.errors.messageTargets.PropertyMessageTarget;
import jetbrains.mps.vcs.diff.changes.SetReferenceChange;
import jetbrains.mps.errors.messageTargets.ReferenceMessageTarget;
import jetbrains.mps.vcs.diff.changes.NodeGroupChange;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.util.IterableUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.errors.messageTargets.DeletedNodeMessageTarget;

public class ChangeEditorMessageFactory {
  private ChangeEditorMessageFactory() {
  }

  public static List<ChangeEditorMessage> createMessages(SModel editedModel, ModelChange change, EditorMessageOwner owner, ChangeEditorMessage.ConflictChecker conflictChecker, boolean highlighted) {
    List<ChangeEditorMessage> messages = ListSequence.fromList(new LinkedList<ChangeEditorMessage>());
    SNodeId id;
    MessageTarget messageTarget;
    if (change instanceof AddRootChange || change instanceof DeleteRootChange) {
      id = change.getRootId();
      messageTarget = new NodeMessageTarget();
    } else if (change instanceof SetPropertyChange) {
      id = ((NodeChange) change).getAffectedNodeId();
      messageTarget = new PropertyMessageTarget(((SetPropertyChange) change).getPropertyName());
    } else if (change instanceof SetReferenceChange) {
      id = ((NodeChange) change).getAffectedNodeId();
      messageTarget = new ReferenceMessageTarget(((SetReferenceChange) change).getRole());
    } else if (change instanceof NodeGroupChange) {
      NodeGroupChange ngc = ((NodeGroupChange) change);
      SModel changeModel = change.getChangeSet().getNewModel();
      boolean reversed = changeModel != editedModel;
      if (reversed) {
        changeModel = change.getChangeSet().getOldModel();
      }

      String role = ngc.getRole();
      SNodeId parentId = ngc.getParentNodeId();
      SNode parentNode = changeModel.getNode(parentId);
      if (parentNode == null) {
        return null;
      }
      List<? extends SNode> changeChildren = IterableUtil.asList(parentNode.getChildren(role));

      int changeBegin = (reversed ?
        ngc.getBegin() :
        ngc.getResultBegin()
      );
      int changeEnd = (reversed ?
        ngc.getEnd() :
        ngc.getResultEnd()
      );

      // We need to check change models because current edited model can have different indices 
      // (for instance, when some changes are already applied) 
      SNodeId beginId = (changeBegin < changeChildren.size() ?
        changeChildren.get(changeBegin).getNodeId() :
        null
      );
      SNodeId endId = (changeEnd < changeChildren.size() ?
        changeChildren.get(changeEnd).getNodeId() :
        null
      );
      int currentChildrenSize = changeChildren.size();

      int beginIndex = (beginId == null ?
        currentChildrenSize :
        SNodeOperations.getIndexInParent(((SNode) editedModel.getNode(beginId)))
      );
      int endIndex = (endId == null ?
        currentChildrenSize :
        SNodeOperations.getIndexInParent(((SNode) editedModel.getNode(endId)))
      );

      if (!(0 <= beginIndex && beginIndex <= endIndex && endIndex <= currentChildrenSize)) {
        return null;
      }
      if (beginIndex == endIndex) {
        // delete nodes 
        id = parentId;
        messageTarget = new DeletedNodeMessageTarget(role, beginIndex);
      } else {
        List<? extends SNode> editedChildren = IterableUtil.asList(editedModel.getNode(parentId).getChildren(role));
        for (int i = beginIndex; i < endIndex; i++) {
          ListSequence.fromList(messages).addElement(new ChangeEditorMessage(editedChildren.get(i), new NodeMessageTarget(), owner, change, conflictChecker, highlighted));
        }
        return messages;
      }
    } else {
      return null;
    }
    SNode node = editedModel.getNode(id);
    ListSequence.fromList(messages).addElement(new ChangeEditorMessage(node, messageTarget, owner, change, conflictChecker, highlighted));
    return messages;
  }

  public static List<ChangeEditorMessage> createMessages(SModel editedModel, ModelChange change, EditorMessageOwner owner, ChangeEditorMessage.ConflictChecker conflictChecker) {
    return ChangeEditorMessageFactory.createMessages(editedModel, change, owner, conflictChecker, true);
  }
}
