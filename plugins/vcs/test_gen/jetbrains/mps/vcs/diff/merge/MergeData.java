package jetbrains.mps.vcs.diff.merge;

/*Generated by MPS */

import java.io.File;
import java.util.zip.ZipFile;
import java.io.IOException;
import java.util.Enumeration;
import java.util.zip.ZipEntry;

import jetbrains.mps.smodel.BaseSModelDescriptor;
import jetbrains.mps.smodel.persistence.def.ModelReadException;
import jetbrains.mps.smodel.persistence.RoleIdsComponent;
import jetbrains.mps.vcs.core.mergedriver.MergerRoleIdsHandler;
import jetbrains.mps.smodel.DefaultSModel;
import jetbrains.mps.smodel.persistence.def.ModelPersistence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import java.util.zip.ZipOutputStream;
import java.io.FileOutputStream;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import java.io.InputStream;
import jetbrains.mps.util.ReadUtil;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.vcs.diff.ChangeSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.util.DifflibFacade;
import jetbrains.mps.internal.collections.runtime.IVisitor;

public class MergeData {
  private static final String CHANGES_MINE_TXT = "changes.mine.txt";
  private static final String CHANGES_REPOSITORY_TXT = "changes.repository.txt";
  private final File myZipFileFile;
  private final ZipFile myZipFile;
  private String myBaseModelString;
  private String myMineModelString;
  private String myRepositoryModelString;
  private String myResultModelString;
  private String myChangesMineString;
  private String myChangesRepositoryString;
  private final String myModelMpsBase;
  private final String myModelMpsMine;
  private final String myModelMpsRepository;
  private final String myModelMpsResult;

  public MergeData(File zipFile) throws IOException {
    myZipFileFile = zipFile;
    myZipFile = new ZipFile(myZipFileFile);
    Enumeration<? extends ZipEntry> entries = myZipFile.entries();

    String modelName = null;
    while (entries.hasMoreElements()) {
      ZipEntry entry = entries.nextElement();
      String entryName = entry.getName();
      if (entryName.endsWith(".mps.base")) {
        modelName = entryName.substring(0, entryName.length() - ".mps.base".length());
      }
    }
    assert modelName != null;
    myModelMpsBase = modelName + ".mps.base";
    myModelMpsRepository = modelName + ".mps.repository";
    myModelMpsMine = modelName + ".mps.mine";
    myModelMpsResult = modelName + ".mps.result";
  }

  private void loadCommonData() throws IOException {
    myBaseModelString = loadString(myModelMpsBase);
    myMineModelString = loadString(myModelMpsMine);
    myRepositoryModelString = loadString(myModelMpsRepository);
  }

  private void loadResultData() throws IOException {
    myResultModelString = loadString(myModelMpsResult);
    myChangesMineString = loadString(CHANGES_MINE_TXT);
    myChangesRepositoryString = loadString(CHANGES_REPOSITORY_TXT);
  }

  private boolean generateAndCheckResultData() throws ModelReadException {
    RoleIdsComponent.setHandler(new MergerRoleIdsHandler());

    DefaultSModel baseModel = ModelPersistence.readModel(myBaseModelString, false);
    DefaultSModel mineModel = ModelPersistence.readModel(myMineModelString, false);
    DefaultSModel repositoryModel = ModelPersistence.readModel(myRepositoryModelString, false);

    final MergeSession session = MergeSession.createMergeSession(baseModel, mineModel, repositoryModel);
    String resultModelString = null;
    if (Sequence.fromIterable(session.getAllChanges()).all(new IWhereFilter<ModelChange>() {
      public boolean accept(ModelChange c) {
        return Sequence.fromIterable(session.getConflictedWith(c)).isEmpty();
      }
    })) {
      // no conflicts 
      session.applyChanges(Sequence.fromIterable(session.getAllChanges()).toListSequence());
      resultModelString = ModelPersistence.modelToString(((BaseSModelDescriptor) session.getResultModel()).getSModelInternal());
    }
    RoleIdsComponent.setHandler(null);

    String changesMineString = dumpChangeSet(session.getMyChangeSet(), session);
    String changesRepositoryString = dumpChangeSet(session.getRepositoryChangeSet(), session);

    if (check("result model", myResultModelString, resultModelString) & check("my change list", myChangesMineString, changesMineString) & check("my repository list", myChangesRepositoryString, changesRepositoryString)) {
      return true;
    } else {
      myResultModelString = resultModelString;
      myChangesMineString = changesMineString;
      myChangesRepositoryString = changesRepositoryString;
      return false;
    }
  }

  private void saveAndClose() throws IOException {
    myZipFile.close();
    ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(myZipFileFile));
    addFileToZos(zos, myModelMpsBase, myBaseModelString);
    addFileToZos(zos, myModelMpsMine, myMineModelString);
    addFileToZos(zos, myModelMpsRepository, myRepositoryModelString);
    if (myResultModelString != null) {
      addFileToZos(zos, myModelMpsResult, myResultModelString);
    }
    addFileToZos(zos, CHANGES_MINE_TXT, myChangesMineString);
    addFileToZos(zos, CHANGES_REPOSITORY_TXT, myChangesRepositoryString);
    zos.close();
  }

  @Nullable
  private String loadString(@NotNull String name) throws IOException {
    ZipEntry entry = myZipFile.getEntry(name);
    if (entry == null) {
      return null;
    }
    InputStream inputStream = myZipFile.getInputStream(entry);
    byte[] bytes = ReadUtil.read(inputStream);
    inputStream.close();
    return new String(bytes, FileUtil.DEFAULT_CHARSET);
  }

  public void generate() throws IOException, ModelReadException {
    loadCommonData();
    loadResultData();
    if (!(generateAndCheckResultData())) {
      saveAndClose();
    }
  }

  public boolean check() throws IOException, ModelReadException {
    loadCommonData();
    loadResultData();
    boolean result = generateAndCheckResultData();
    myZipFile.close();
    return result;
  }

  private static String dumpChangeSet(ChangeSet changeSet, MergeSession session) {
    StringBuffer buf = new StringBuffer();
    for (ModelChange change : ListSequence.fromList(changeSet.getModelChanges()).sort(new ISelector<ModelChange, String>() {
      public String select(ModelChange c) {
        return c.toString();
      }
    }, true)) {
      buf.append(change).append("\n");
      for (ModelChange conflicting : Sequence.fromIterable(session.getConflictedWith(change)).sort(new ISelector<ModelChange, String>() {
        public String select(ModelChange c) {
          return c.toString();
        }
      }, true)) {
        buf.append("    ").append(conflicting).append("\n");
      }
    }
    return buf.toString();
  }

  private static void addFileToZos(ZipOutputStream zipOutputStream, String name, String content) throws IOException {
    zipOutputStream.putNextEntry(new ZipEntry(name));
    zipOutputStream.write(content.getBytes(FileUtil.DEFAULT_CHARSET));
    zipOutputStream.closeEntry();
  }

  private static boolean check(String what, String expected, String actual) {
    if (expected == null || actual == null) {
      if (expected != null || actual != null) {
        System.err.printf("Expected %s: %s, but actual is %s\n", what, (expected == null ?
          "null" :
          "not null"
        ), (actual == null ?
          "null" :
          "not null"
        ));
        return false;
      } else {
        return true;
      }
    }
    String[] simpleDiff = DifflibFacade.getSimpleDiff(expected, actual);
    if (simpleDiff.length == 0) {
      return true;
    } else {
      System.err.println("Difference in " + what);
      Sequence.fromIterable(Sequence.fromArray(simpleDiff)).visitAll(new IVisitor<String>() {
        public void visit(String line) {
          System.err.println(line);
        }
      });
      return false;
    }
  }
}
