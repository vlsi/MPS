package jetbrains.mps.vcs;

/*Generated by MPS */

import java.io.File;
import jetbrains.mps.util.FileUtil;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.project.Project;
import jetbrains.mps.project.Solution;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.DefaultSModelDescriptor;
import org.junit.Test;
import jetbrains.mps.TestMain;
import jetbrains.mps.smodel.SModelRepository;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.CopyUtil;
import org.junit.Assert;
import jetbrains.mps.smodel.SModelDescriptor;
import java.util.Scanner;
import java.util.regex.Pattern;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.io.PrintWriter;
import java.io.FileNotFoundException;
import org.jetbrains.annotations.Nullable;
import com.intellij.openapi.ui.Messages;
import com.intellij.openapi.ui.TestDialog;
import javax.swing.SwingUtilities;
import java.lang.reflect.InvocationTargetException;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.openapi.vfs.LocalFileSystem;
import com.intellij.openapi.vfs.newvfs.RefreshSession;
import com.intellij.openapi.vfs.newvfs.RefreshQueue;
import java.io.IOException;
import jetbrains.mps.ide.ThreadUtils;

/**
 * * @author Evgeny Gerashchenko
 * * @since 3/23/11
 */
public class DiskMemoryConflictsTest {
  private static final File DESTINATION_PROJECT_DIR = new File(FileUtil.getTempDir(), "testConflicts");
  private static final File PROJECT_ARCHIVE = new File("testbench/modules/simpleProject.zip");
  private static final String PROJECT_FILE = "simpleProject.mpr";
  private static final SModelReference MODEL_REFERENCE = SModelReference.fromString("r:21cf9f47-5464-40f2-9509-d94ba20bfe82(simpleModel)");
  private static final File MODEL_FILE = getModelFile();
  private static final String FIELD_DEFAULT_NAME = "theField";
  private static final String FIELD_NAME_IN_FILE = "theFieldInFile";
  private static final String FIELD_NAME_IN_MODEL = "theFieldInModel";
  private Project myProject;
  private Solution myModule;
  private SNode myNodeBackup;
  private DefaultSModelDescriptor myModelDescriptor;

  public DiskMemoryConflictsTest() {
  }

  @Test
  public void testDiskMemoryConflicts() {
    final DiskMemoryConflictsTest.Action[] startedAction = new DiskMemoryConflictsTest.Action[1];
    final DiskMemoryConflictsTest.DiskModification[] startedDiskModification = new DiskMemoryConflictsTest.DiskModification[1];
    final DiskMemoryConflictsTest.VersionToChoose[] startedVersion = new DiskMemoryConflictsTest.VersionToChoose[1];
    final boolean result = TestMain.testOnProjectCopy(PROJECT_ARCHIVE, DESTINATION_PROJECT_DIR, PROJECT_FILE, new TestMain.ProjectRunnable() {
      public boolean execute(final Project project) {
        final boolean[] resultArr = new boolean[1];
        try {
          myProject = project;
          myModelDescriptor = (DefaultSModelDescriptor) SModelRepository.getInstance().getModelDescriptor(DiskMemoryConflictsTest.MODEL_REFERENCE);
          myModule = (Solution) myModelDescriptor.getModule();
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              myNodeBackup = CopyUtil.copyAndPreserveId(myModelDescriptor.getSModel().rootsIterator().next());
            }
          });
          checkInitialState();
          for (DiskMemoryConflictsTest.Action a : DiskMemoryConflictsTest.Action.values()) {
            for (DiskMemoryConflictsTest.DiskModification dm : DiskMemoryConflictsTest.DiskModification.values()) {
              for (DiskMemoryConflictsTest.VersionToChoose v : DiskMemoryConflictsTest.VersionToChoose.values()) {
                startedAction[0] = a;
                startedVersion[0] = v;
                startedDiskModification[0] = dm;
                provokeAndCheckConflict(a, dm, v);
                restoreAndCheckOriginalState();
              }
            }
          }
          resultArr[0] = true;
        } catch (Throwable e) {
          e.printStackTrace();
          return false;
        }
        return resultArr[0];
      }
    }, "jetbrains.mps.vcs");
    if (!(result)) {
      Assert.fail("Last started check action=" + startedAction[0] + ", disk modification=" + startedDiskModification[0] + ", version=" + startedVersion[0]);
    }
  }

  private String processFieldNameInModel(final String nameToWrite) {
    final String[] result = new String[1];
    ModelAccess.instance().runCommandInEDT(new Runnable() {
      public void run() {
        if (SModelRepository.getInstance().getModelDescriptor(myModelDescriptor.getSModelReference()) != null) {
          try {
            final SModelDescriptor modelDescriptor = myModelDescriptor;
            Assert.assertNotNull(modelDescriptor);
            SNode node = modelDescriptor.getSModel().getNodeById("6010389230754495469");
            Assert.assertNotNull(node);
            if (nameToWrite == null) {
              result[0] = node.getProperty("name");
            } else {
              node.setProperty("name", nameToWrite);
            }
          } catch (Throwable ignored) {
          }
        }
      }
    }, myProject);
    DiskMemoryConflictsTest.waitEDT();
    return result[0];
  }

  private void setFieldNameInModel(String value) {
    processFieldNameInModel(value);
  }

  private String getFieldNameFromModel() {
    return processFieldNameInModel(null);
  }

  private String processFieldNameInFile(final String nameToWrite) {
    //  File stuff 
    if (!(MODEL_FILE.exists())) {
      return null;
    }
    try {
      Scanner scanner = new Scanner(MODEL_FILE);
      String FIELD_PATTERN = "      <property name=\"name\" nameId=\"tpck.1169194664001\" value=\"%s\" />";
      Pattern fieldNamePattern = Pattern.compile(String.format(FIELD_PATTERN, "([^\"]+)"));
      boolean inField = false;
      List<String> lines = new ArrayList<String>();
      while (scanner.hasNextLine()) {
        String line = scanner.nextLine();
        if (line.contains("<node role=\"field\" roleId=\"tpee.1068390468199\" type=\"tpee.FieldDeclaration\" typeId=\"tpee.1068390468200\" id=\"6010389230754495469\">")) {
          inField = true;
        } else
        if (inField) {
          Matcher matcher = fieldNamePattern.matcher(line);
          if (matcher.matches()) {
            if (nameToWrite == null) {
              return matcher.group(1);
            } else {
              lines.add(matcher.replaceFirst(String.format(FIELD_PATTERN, nameToWrite)));
              inField = false;
              continue;
            }
          }
        }
        lines.add(line);
      }
      scanner.close();
      long lastModifiedBefore = MODEL_FILE.lastModified();
      PrintWriter w = new PrintWriter(MODEL_FILE);
      for (String line : lines) {
        w.println(line);
      }
      w.close();
      if (MODEL_FILE.lastModified() == lastModifiedBefore) {
        DiskMemoryConflictsTest.setLastModified(lastModifiedBefore + 1000);
      }
      DiskMemoryConflictsTest.setLastModified(lastModifiedBefore + 2000 + (int) (Math.random() * 100000));
    } catch (FileNotFoundException e) {
      Assert.fail();
    }
    return null;
  }

  private String getFieldNameFromFile() {
    return processFieldNameInFile(null);
  }

  private void setFieldNameInFile(String name) {
    processFieldNameInFile(name);
  }

  private void checkInitialState() {
    checkSynchronizedState(FIELD_DEFAULT_NAME);
  }

  private void checkSynchronizedState(@Nullable String fieldName) {
    Assert.assertEquals(fieldName, getFieldNameFromModel());
    Assert.assertEquals(fieldName, getFieldNameFromFile());
    if (fieldName == null) {
      Assert.assertNull(SModelRepository.getInstance().getModelDescriptor(myModelDescriptor.getSModelReference()));
    } else {
      Assert.assertFalse(myModelDescriptor.isChanged());
    }
  }

  private void provokeAndCheckConflict(DiskMemoryConflictsTest.Action action, final DiskMemoryConflictsTest.DiskModification diskModification, final DiskMemoryConflictsTest.VersionToChoose versionToChoose) {
    setFieldNameInModel(FIELD_NAME_IN_MODEL);
    if (DiskMemoryConflictsTest.DiskModification.MODIFY == diskModification) {
      setFieldNameInFile(FIELD_NAME_IN_FILE);
    } else {
      DiskMemoryConflictsTest.delete();
    }
    refreshVfs();
    final boolean[] dialogWasInvoked = new boolean[1];
    Messages.setTestDialog(new TestDialog() {
      @Override
      public int show(String message) {
        dialogWasInvoked[0] = true;
        if (DiskMemoryConflictsTest.DiskModification.DELETE == diskModification) {
          return (DiskMemoryConflictsTest.VersionToChoose.MEMORY == versionToChoose ?
            0 :
            1
          );
        } else {
          return (DiskMemoryConflictsTest.VersionToChoose.MEMORY == versionToChoose ?
            1 :
            0
          );
        }
      }
    });
    if (DiskMemoryConflictsTest.Action.SAVE == action) {
      //  save conflicting model 
      ModelAccess.instance().runCommandInEDT(new Runnable() {
        @Override
        public void run() {
          SModelRepository.getInstance().saveAll();
        }
      }, myProject);
    } else {
      //  reload conflict 
      ModelAccess.instance().runWriteInEDT(new Runnable() {
        public void run() {
          myModelDescriptor.reloadFromDiskSafe();
        }
      });
    }
    ModelAccess.instance().flushEventQueue();
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
        }
      });
    } catch (InterruptedException e) {
    } catch (InvocationTargetException e) {
    }
    Assert.assertTrue(dialogWasInvoked[0]);
    String expectedFieldName;
    if (DiskMemoryConflictsTest.VersionToChoose.MEMORY == versionToChoose) {
      expectedFieldName = FIELD_NAME_IN_MODEL;
    } else {
      if (DiskMemoryConflictsTest.DiskModification.MODIFY == diskModification) {
        expectedFieldName = FIELD_NAME_IN_FILE;
      } else {
        expectedFieldName = null;
      }
    }
    checkSynchronizedState(expectedFieldName);
  }

  private void refreshVfs() {
    VirtualFile vf = LocalFileSystem.getInstance().findFileByIoFile(MODEL_FILE);
    if (vf == null || !(vf.exists())) {
      vf = LocalFileSystem.getInstance().findFileByIoFile(MODEL_FILE.getParentFile());
    }
    RefreshSession rs = RefreshQueue.getInstance().createSession(false, true, null);
    assert vf != null;
    rs.addFile(vf);
    rs.launch();
  }

  private void restoreAndCheckOriginalState() {
    if (MODEL_FILE.exists()) {
      setFieldNameInFile(FIELD_DEFAULT_NAME);
      refreshVfs();
      ModelAccess.instance().runWriteAction(new Runnable() {
        public void run() {
          myModelDescriptor.reloadFromDisk();
        }
      });
    } else {
      //  Restore model 
      ModelAccess.instance().runCommandInEDT(new Runnable() {
        public void run() {
          myModelDescriptor = ((DefaultSModelDescriptor) myModule.createModel(DiskMemoryConflictsTest.MODEL_REFERENCE.getSModelFqName().toString(), myModule.getModelRoots().iterator().next(), null));
          myModelDescriptor.getSModel().addRoot(CopyUtil.copyAndPreserveId(myNodeBackup));
          myModelDescriptor.save();
        }
      }, myProject);
      DiskMemoryConflictsTest.waitEDT();
    }
    checkInitialState();
  }

  private static File getModelFile() {
    File modelFile = new File(DESTINATION_PROJECT_DIR, "solutions/simpleProject/simpleModel.mps");
    try {
      return modelFile.getCanonicalFile();
    } catch (IOException ex) {
      ex.printStackTrace();
    }
    return modelFile;
  }

  private static void setLastModified(long timeStamp) {
    //  this is a workaround of JRE bug #4243868 
    //  http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4243868 
    int count = 0;
    while (!(MODEL_FILE.setLastModified(timeStamp)) && count < 10) {
      count++;
      System.gc();
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        Assert.fail();
        return;
      }
    }
    Assert.assertTrue(count < 10);
  }

  private static void delete() {
    //  this is a workaround of JRE bug similar to #4243868 
    //  http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4243868 
    int count = 0;
    while (!(MODEL_FILE.delete()) && count < 10) {
      count++;
      System.gc();
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        Assert.fail();
        return;
      }
    }
    Assert.assertTrue(count < 10);
  }

  private static void waitEDT() {
    ModelAccess.instance().flushEventQueue();
    ThreadUtils.runInUIThreadAndWait(new Runnable() {
      @Override
      public void run() {
      }
    });
  }

  private static   enum Action {
    SAVE(),
    RELOAD();

    Action() {
    }
  }

  private static   enum VersionToChoose {
    MEMORY(),
    DISK();

    VersionToChoose() {
    }
  }

  private static   enum DiskModification {
    MODIFY(),
    DELETE();

    DiskModification() {
    }
  }
}
