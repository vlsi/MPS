package jetbrains.mps.vcs.diff.ui;

/*Generated by MPS */

import jetbrains.mps.ide.dialogs.BaseDialog;
import com.intellij.openapi.project.Project;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.vcs.diff.MergeContext;
import jetbrains.mps.smodel.SModel;
import com.intellij.openapi.wm.WindowManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import javax.swing.JComponent;
import javax.swing.JScrollPane;
import jetbrains.mps.ide.dialogs.DialogDimensionsSettings;
import jetbrains.mps.ide.ui.MPSTree;
import jetbrains.mps.ide.ui.MPSTreeNode;
import jetbrains.mps.smodel.SNodeId;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.ide.projectPane.Icons;
import java.util.List;
import jetbrains.mps.vcs.diff.changes.ModelChange;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.awt.Color;
import jetbrains.mps.vcs.diff.changes.AddRootChange;
import com.intellij.openapi.vcs.FileStatus;
import jetbrains.mps.vcs.diff.changes.DeleteRootChange;
import jetbrains.mps.util.NameUtil;
import java.util.ArrayList;
import javax.swing.Icon;
import jetbrains.mps.smodel.SNode;
import jetbrains.mps.ide.icons.IconManager;
import org.apache.commons.lang.StringUtils;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.smodel.ModelAccess;

public class MergeModelsDialog extends BaseDialog {
  private Project myProject;
  private IOperationContext myOperationContext;
  private MergeContext myMergeContext;
  private MergeModelsDialog.MergeModelsTree myMergeModelsTree;
  private boolean myCancelled = false;

  public MergeModelsDialog(Project project, IOperationContext operationContext, SModel baseModel, SModel mineModel, SModel repositoryModel) {
    super(WindowManager.getInstance().getFrame(project), SModelOperations.getModelName(baseModel));
    myProject = project;
    myOperationContext = operationContext;
    myMergeContext = new MergeContext(baseModel, mineModel, repositoryModel);
    myMergeModelsTree = new MergeModelsDialog.MergeModelsTree();
  }

  protected JComponent getMainComponent() {
    return new JScrollPane(myMergeModelsTree);
  }

  @Override
  public DialogDimensionsSettings.DialogDimensions getDefaultDimensionSettings() {
    return new DialogDimensionsSettings.DialogDimensions(10, 10, 500, 700);
  }

  @BaseDialog.Button(position = 0, name = "OK", mnemonic = 'O', defaultButton = true)
  public void ok() {
    dispose();
  }

  @BaseDialog.Button(position = 1, name = "Cancel", mnemonic = 'C')
  public void cancel() {
    myCancelled = true;
    dispose();
  }

  public SModel getResultModel() {
    return (myCancelled ?
      null :
      myMergeContext.getResultModel()
    );
  }

  /*package*/ void rebuildLater() {
    myMergeModelsTree.rebuildLater();
  }

  /*package*/ IOperationContext getOperationContext() {
    return myOperationContext;
  }

  public static boolean isNewMergeEnabled() {
    return "true".equals(System.getProperty("mps.newmerge"));
  }

  private class MergeModelsTree extends MPSTree {
    public MergeModelsTree() {
      rebuildNow();
      expandAll();
    }

    protected MPSTreeNode rebuild() {
      MergeModelsDialog.MyModelTreeNode modelNode = new MergeModelsDialog.MyModelTreeNode();
      for (SNodeId rootId : SetSequence.fromSet(myMergeContext.getAffectedRoots())) {
        modelNode.add(new MergeModelsDialog.MyRootTreeNode(rootId));
      }
      return modelNode;
    }
  }

  private class MyModelTreeNode extends MPSTreeNode {
    public MyModelTreeNode() {
      super(myOperationContext);
      setNodeIdentifier("model");
    }

    @Override
    protected void doUpdatePresentation() {
      setText(myMergeContext.getResultModel().getLongName());
      setIcon(Icons.MODEL_ICON);
    }
  }

  private class MyRootTreeNode extends MPSTreeNode {
    private SNodeId myRootId;
    private String myPresentations;

    public MyRootTreeNode(SNodeId rootId) {
      super(myOperationContext);
      myRootId = rootId;
      setNodeIdentifier("" + myRootId);
    }

    @Override
    protected void doUpdatePresentation() {
      List<ModelChange> changes = ListSequence.fromList(myMergeContext.getChangesForRoot(myRootId)).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return !(myMergeContext.isChangeResolved(ch));
        }
      }).toListSequence();
      Iterable<ModelChange> conflictedChanges = ListSequence.fromList(changes).where(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return Sequence.fromIterable(myMergeContext.getConflictedWith(ch)).isNotEmpty();
        }
      });

      if (Sequence.fromIterable(conflictedChanges).isNotEmpty()) {
        setColor(Color.RED);
      } else if (ListSequence.fromList(changes).isEmpty()) {
        // skip 
      } else if (ListSequence.fromList(changes).all(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return ch instanceof AddRootChange;
        }
      })) {
        setColor(FileStatus.ADDED.getColor());
      } else if (ListSequence.fromList(changes).all(new IWhereFilter<ModelChange>() {
        public boolean accept(ModelChange ch) {
          return ch instanceof DeleteRootChange;
        }
      })) {
        setColor(FileStatus.DELETED.getColor());
      } else if (ListSequence.fromList(changes).isNotEmpty()) {
        setColor(FileStatus.MODIFIED.getColor());
      }

      String changesText = (ListSequence.fromList(changes).isEmpty() ?
        null :
        NameUtil.formatNumericalString(ListSequence.fromList(changes).count(), "change")
      );
      if (Sequence.fromIterable(conflictedChanges).isEmpty()) {
        setAdditionalText(changesText);
      } else {
        setAdditionalText(changesText + ", " + NameUtil.formatNumericalString(Sequence.fromIterable(conflictedChanges).count(), "conflicted change"));
      }

      List<String> presentations = ListSequence.fromList(new ArrayList<String>());
      Icon icon = null;
      for (SModel model : Sequence.fromIterable(Sequence.fromArray(new SModel[]{myMergeContext.getBaseModel(), myMergeContext.getMyModel(), myMergeContext.getRepositoryModel()}))) {
        SNode root = model.getNodeById(myRootId);
        if (root != null) {
          String presentation = root.getPresentation();
          if (!(ListSequence.fromList(presentations).contains(presentation))) {
            ListSequence.fromList(presentations).addElement(presentation);
          }
          if (icon == null) {
            icon = IconManager.getIconFor(root);
          }
        }
      }
      myPresentations = StringUtils.join(presentations, " / ");
      setText(myPresentations);
      setIcon(icon);
    }

    @Override
    public void doubleClick() {
      final Wrappers._T<MergeRootsDialog> mergeRootsDialog = new Wrappers._T<MergeRootsDialog>();
      ModelAccess.instance().runReadAction(new Runnable() {
        public void run() {
          mergeRootsDialog.value = new MergeRootsDialog(MergeModelsDialog.this, myMergeContext, myRootId, myPresentations);
        }
      });
      mergeRootsDialog.value.showDialog();
      mergeRootsDialog.value.toFront();
    }
  }
}
