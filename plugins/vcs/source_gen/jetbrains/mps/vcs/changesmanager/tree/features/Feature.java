package jetbrains.mps.vcs.changesmanager.tree.features;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

/**
 * Feature is either node, node's property, node's reference, node's property list,
 * or node's reference list (see subclasses)
 */
public abstract class Feature {
  private final SModelReference myModelReference;
  private int myHashCode;

  protected Feature(@NotNull SModelReference modelReference) {
    myModelReference = modelReference;
  }

  @NotNull
  public final SModelReference getModelReference() {
    return myModelReference;
  }

  @Nullable
  public abstract Feature getParent();

  @Override
  public int hashCode() {
    if (myHashCode == 0) {
      myHashCode = toString().hashCode();
      if (myHashCode == 0) {
        assert false : "Feature hash code cannot be 0";
      }
    }
    return myHashCode;
  }

  @Override
  public boolean equals(Object object) {
    if (this.getClass() == object.getClass()) {
      Feature that = ((Feature) object);
      if (this.hashCode() == that.hashCode()) {
        if (this.myModelReference.equals(that.myModelReference)) {
          return true;
        }
      }
    }
    return false;
  }

  @NotNull
  @Override
  public abstract String toString();

  public Feature[] getAncestors() {
    List<Feature> features = ListSequence.fromList(new ArrayList<Feature>());
    for (Feature current = getParent(); current != null; current = current.getParent()) {
      ListSequence.fromList(features).addElement(current);
    }
    return ListSequence.fromList(features).toGenericArray(Feature.class);
  }
}
