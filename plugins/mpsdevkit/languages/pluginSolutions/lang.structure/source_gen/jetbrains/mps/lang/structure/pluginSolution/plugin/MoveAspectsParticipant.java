package jetbrains.mps.lang.structure.pluginSolution.plugin;

/*Generated by MPS */

import jetbrains.mps.refactoring.participant.RefactoringParticipantBase;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.refactoring.participant.MoveNodeRefactoringParticipant;
import jetbrains.mps.refactoring.participant.RecursiveParticipant;
import jetbrains.mps.smodel.structure.Extension;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.smodel.Language;
import java.util.List;
import jetbrains.mps.refactoring.participant.RefactoringParticipant;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Map;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.internal.collections.runtime.ILeftCombinator;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.refactoring.participant.RefactoringSession;
import jetbrains.mps.ide.platform.refactoring.NodeLocation;
import jetbrains.mps.refactoring.participant.NodeCopyTracker;

public class MoveAspectsParticipant extends RefactoringParticipantBase<SNodeReference, SNodeReference, SNode, SNode> implements MoveNodeRefactoringParticipant<SNodeReference, SNodeReference>, RecursiveParticipant<SNodeReference, SNodeReference, SNode, SNode> {

  public static class MoveAspectsParticipant_extension extends Extension.Default<MoveNodeRefactoringParticipant<?, ?>> {
    public MoveAspectsParticipant_extension() {
      super("jetbrains.mps.refactoring.participant.MoveNodeParticipantEP");
    }
    public MoveNodeRefactoringParticipant<?, ?> get() {
      return new MoveAspectsParticipant();
    }
  }

  private MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference> myDataCollector = new MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference>() {
    public SNodeReference beforeMove(SNode nodeToMove) {
      return nodeToMove.getReference();
    }
    public SNodeReference afterMove(SNode movedNode) {
      return movedNode.getReference();
    }
  };

  public MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<SNodeReference, SNodeReference> getDataCollector() {
    return myDataCollector;
  }

  public boolean isApplicable(SNodeReference initialState, SRepository repository) {
    return (SNodeOperations.as(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration")) != null) && SNodeOperations.getModel(SNodeOperations.cast(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"))).getModule() instanceof Language;
  }
  public List<RefactoringParticipant.Option> getAvailableOptions(SNodeReference initialState, SRepository repository) {
    if (isApplicable(initialState, repository)) {
      return ListSequence.fromListAndArray(new ArrayList<RefactoringParticipant.Option>(), OPTION);
    } else {
      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Option>());
    }
  }

  @Override
  public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> getChanges(final SNodeReference initialState, final SRepository repository, List<RefactoringParticipant.Option> selectedOptions, final SearchScope searchScope, ProgressMonitor progressMonitor) {
    return getChanges(initialState, repository, selectedOptions, searchScope, progressMonitor, Sequence.fromIterable(Collections.<RefactoringParticipant.ParticipantApplied>emptyList()));
  }


  @Override
  public List<List<RefactoringParticipant.Change<SNodeReference, SNodeReference>>> getChanges(List<SNodeReference> initialStates, final SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, final SearchScope searchScope, final ProgressMonitor progressMonitor, final Iterable<RefactoringParticipant.ParticipantApplied> parents) {
    return ListSequence.fromList(initialStates).select(new ISelector<SNodeReference, List<RefactoringParticipant.Change<SNodeReference, SNodeReference>>>() {
      public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> select(SNodeReference initialState) {
        return getChanges(initialState, repository, selectedOptions, searchScope, progressMonitor, parents);
      }
    }).toListSequence();
  }

  public List<RefactoringParticipant.Change<SNodeReference, SNodeReference>> getChanges(final SNodeReference initialState, final SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, final SearchScope searchScope, final ProgressMonitor progressMonitor, final Iterable<RefactoringParticipant.ParticipantApplied> parents) {
    if (!((isApplicable(initialState, repository))) || !(ListSequence.fromList(selectedOptions).contains(OPTION))) {
      return ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<SNodeReference, SNodeReference>>());
    } else {
      final SNode sourceConcept = SNodeOperations.cast(initialState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"));
      Language sourceLanguage = ((Language) SNodeOperations.getModel(sourceConcept).getModule());

      Map<LanguageAspect, List<SNode>> aspectsMap = MoveConceptUtil.getAspectNodes(sourceLanguage, Sequence.<SNode>singleton(sourceConcept));

      int participantSize = Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.refactoring.participant.MoveNodeParticipantEP").getObjects()).count();
      Iterable<SNode> aspects = Sequence.fromIterable(MapSequence.fromMap(aspectsMap).values()).translate(new ITranslator2<List<SNode>, SNode>() {
        public Iterable<SNode> translate(List<SNode> x) {
          return x;
        }
      });
      progressMonitor.start("", participantSize * Sequence.fromIterable(aspects).foldLeft(0, new ILeftCombinator<SNode, Integer>() {
        public Integer combine(Integer s, SNode it) {
          return s + ListSequence.fromList(SNodeOperations.getNodeDescendants(it, null, true, new SAbstractConcept[]{})).count();
        }
      }));

      return MapSequence.fromMap(aspectsMap).translate(new ITranslator2<IMapping<LanguageAspect, List<SNode>>, RefactoringParticipant.Change<SNodeReference, SNodeReference>>() {
        public Iterable<RefactoringParticipant.Change<SNodeReference, SNodeReference>> translate(final IMapping<LanguageAspect, List<SNode>> mapping) {
          return ListSequence.fromList(mapping.value()).select(new ISelector<SNode, RefactoringParticipant.Change<SNodeReference, SNodeReference>>() {
            public RefactoringParticipant.Change<SNodeReference, SNodeReference> select(final SNode aspect) {

              List<SNode> descendants = SNodeOperations.getNodeDescendants(aspect, null, true, new SAbstractConcept[]{});

              final List<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>>> childparticipantStates = ListSequence.fromList(descendants).translate(new ITranslator2<SNode, Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>>>() {
                public Iterable<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>>> translate(final SNode node) {
                  return Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.refactoring.participant.MoveNodeParticipantEP").getObjects()).select(new ISelector<MoveNodeRefactoringParticipant<?, ?>, Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>>>() {
                    public Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>> select(MoveNodeRefactoringParticipant<?, ?> participant) {
                      RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode> participantState = RecursiveParticipant.RecursiveParticipantApplied.create(participant, ListSequence.fromListAndArray(new ArrayList<SNode>(), node), parents);
                      participantState.findChanges(repository, selectedOptions, searchScope, progressMonitor.subTask(1));
                      return MultiTuple.<SNode,RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>>from(node, participantState);
                    }
                  });
                }
              }).toListSequence();

              final SearchResults results = new SearchResults();
              results.addAll(new SearchResults(SetSequence.fromSetAndArray(new HashSet<SNode>(), sourceConcept), ListSequence.fromListAndArray(new ArrayList<SearchResult<SNode>>(), new SearchResult<SNode>(aspect, "concept aspect"))));
              ListSequence.fromList(childparticipantStates).select(new ISelector<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>>, List<? extends RefactoringParticipant.Change<?, ?>>>() {
                public List<? extends RefactoringParticipant.Change<?, ?>> select(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>> it) {
                  return (List<? extends RefactoringParticipant.Change<?, ?>>) ListSequence.fromList(it._1().getChanges()).first();
                }
              }).visitAll(new IVisitor<List<? extends RefactoringParticipant.Change<?, ?>>>() {
                public void visit(List<? extends RefactoringParticipant.Change<?, ?>> it) {
                  ListSequence.fromList(it).select(new ISelector<RefactoringParticipant.Change<?, ?>, SearchResults>() {
                    public SearchResults select(RefactoringParticipant.Change<?, ?> it1) {
                      return it1.getSearchResults();
                    }
                  }).visitAll(new IVisitor<SearchResults>() {
                    public void visit(SearchResults it1) {
                      results.addAll(it1);
                    }
                  });
                }
              });


              // todo: do not keep nodes but only node references 

              RefactoringParticipant.Change<SNodeReference, SNodeReference> change = new MoveNodeRefactoringParticipant.ChangeBase<SNodeReference, SNodeReference>() {
                public SearchResults getSearchResults() {
                  return results;
                }
                public RefactoringParticipant.KeepOldNodes needsToPreserveOldNode() {
                  return RefactoringParticipant.KeepOldNodes.max(ListSequence.fromList(childparticipantStates).translate(new ITranslator2<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>>, RefactoringParticipant.Change<?, ?>>() {
                    public Iterable<RefactoringParticipant.Change<?, ?>> translate(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>> it) {
                      return ListSequence.fromList(ListSequence.fromList(it._1().getChanges()).first()).select(new ISelector<RefactoringParticipant.Change<?, ?>, RefactoringParticipant.Change<?, ?>>() {
                        public RefactoringParticipant.Change<?, ?> select(RefactoringParticipant.Change<?, ?> it) {
                          return (RefactoringParticipant.Change<?, ?>) it;
                        }
                      });
                    }
                  }).select(new ISelector<RefactoringParticipant.Change<?, ?>, RefactoringParticipant.KeepOldNodes>() {
                    public RefactoringParticipant.KeepOldNodes select(RefactoringParticipant.Change<?, ?> it) {
                      return ((MoveNodeRefactoringParticipant.MoveNodeChange) it).needsToPreserveOldNode();
                    }
                  }));
                }
                public void confirm(SNodeReference finalState, final SRepository repository, final RefactoringSession refactoringSession) {
                  SNode targetConcept = SNodeOperations.cast(finalState.resolve(repository), MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"));
                  Language targetLanguage = ((Language) SNodeOperations.getModel(targetConcept).getModule());
                  NodeLocation.NodeLocationRootWithAspectModelCreation newLocation = new NodeLocation.NodeLocationRootWithAspectModelCreation(targetLanguage, mapping.key());

                  List<SNode> copied = NodeCopyTracker.get(refactoringSession).copyAndTrack(ListSequence.fromListAndArray(new ArrayList<SNode>(), aspect));
                  if (needsToPreserveOldNode() == RefactoringParticipant.KeepOldNodes.REMOVE && SNodeOperations.getModel(sourceConcept) == null) {
                    SNodeOperations.deleteNode(aspect);
                  }

                  final Map<SNode, SNode> copyMap = NodeCopyTracker.get(refactoringSession).getCopyMap();
                  newLocation.insertNode(repository, ListSequence.fromList(copied).first());
                  ListSequence.fromList(childparticipantStates).visitAll(new IVisitor<Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>>>() {
                    public void visit(Tuples._2<SNode, RecursiveParticipant.RecursiveParticipantApplied<?, ?, SNode, SNode>> pis) {
                      pis._1().doRefactor(ListSequence.fromListAndArray(new ArrayList<SNode>(), MapSequence.fromMap(copyMap).get(pis._0())), repository, refactoringSession, new RefactoringParticipant.CollectingParticipantStateFactory<SNode, SNode>());
                    }
                  });

                  if (needsToPreserveOldNode() == RefactoringParticipant.KeepOldNodes.POSTPONE_REMOVE && SNodeOperations.getModel(sourceConcept) == null) {
                    SNodeOperations.deleteNode(aspect);
                  }
                }
              };
              return (RefactoringParticipant.Change<SNodeReference, SNodeReference>) change;
            }
          });
        }
      }).toListSequence();
    }
  }
  public static final RefactoringParticipant.Option OPTION = new RefactoringParticipant.Option("moveNode.options.moveConceptAspects", "Move concept aspects");
}
