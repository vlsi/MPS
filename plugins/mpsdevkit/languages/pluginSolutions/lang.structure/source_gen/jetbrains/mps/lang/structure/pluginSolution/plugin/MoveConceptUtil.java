package jetbrains.mps.lang.structure.pluginSolution.plugin;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.structure.behavior.IConceptAspect_BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Map;
import jetbrains.mps.smodel.LanguageAspect;
import jetbrains.mps.smodel.Language;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration_BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;

public class MoveConceptUtil {

  public static List<SNode> getConceptsAspects(final Iterable<SNode> concepts, SModel aspectModel) {
    return ListSequence.fromList(SModelOperations.roots(aspectModel, MetaAdapterFactory.getInterfaceConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x24614259e94f0c84L, "jetbrains.mps.lang.structure.structure.IConceptAspect"))).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        List<SNode> baseConcepts = IConceptAspect_BehaviorDescriptor.getBaseConceptCollection_id4$$3zrO3UBG.invoke(it);
        return ListSequence.fromList(baseConcepts).isNotEmpty() && Sequence.fromIterable(concepts).containsSequence(ListSequence.fromList(baseConcepts));
      }
    }).toListSequence();
  }
  public static Map<LanguageAspect, List<SNode>> getAspectNodes(Language language, Iterable<SNode> nodes) {
    // map with aspects to roots solely attached to list of given nodes 
    Map<LanguageAspect, List<SNode>> aspectNodesMap = MapSequence.fromMap(new HashMap<LanguageAspect, List<SNode>>());
    for (LanguageAspect aspect : LanguageAspect.values()) {
      List<SNode> aspectNodes = MoveConceptUtil.getConceptsAspects(nodes, aspect.get(language));
      if (ListSequence.fromList(aspectNodes).isNotEmpty()) {
        MapSequence.fromMap(aspectNodesMap).put(aspect, aspectNodes);
      }
    }
    return aspectNodesMap;
  }


  public static List<SModuleReference> calculateExtendsDependencies(Iterable<SNode> conceptsToMove) {
    Iterable<SNode> targExtends = Sequence.fromIterable(conceptsToMove).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return AbstractConceptDeclaration_BehaviorDescriptor.getImmediateSuperconcepts_idhMuxyK2.invoke(it);
      }
    }).subtract(Sequence.fromIterable(conceptsToMove));
    return Sequence.fromIterable(targExtends).select(new ISelector<SNode, SModel>() {
      public SModel select(SNode it) {
        return SNodeOperations.getModel(it);
      }
    }).distinct().select(new ISelector<SModel, SModuleReference>() {
      public SModuleReference select(SModel it) {
        return check_ce40do_a0a0a0a0b0f(Language.getLanguageFor(it));
      }
    }).where(new IWhereFilter<SModuleReference>() {
      public boolean accept(SModuleReference it) {
        return it != null;
      }
    }).toListSequence();
  }

  public static void setExtendsDependencies(Iterable<SNode> conceptsToMove, SModel sourceModel, Language sourceLanguage, final Language targetLanguage) {
    Iterable<SNode> conceptsToRest = ListSequence.fromList(SModelOperations.roots(sourceModel, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration"))).subtract(Sequence.fromIterable(conceptsToMove));
    if (Sequence.fromIterable(conceptsToRest).translate(new ITranslator2<SNode, SNode>() {
      public Iterable<SNode> translate(SNode it) {
        return AbstractConceptDeclaration_BehaviorDescriptor.getImmediateSuperconcepts_idhMuxyK2.invoke(it);
      }
    }).intersect(Sequence.fromIterable(conceptsToMove)).isNotEmpty()) {
      sourceLanguage.addExtendedLanguage(targetLanguage.getModuleReference());
    }
    for (SModuleReference ext : ListSequence.fromList(MoveConceptUtil.calculateExtendsDependencies(conceptsToMove)).where(new IWhereFilter<SModuleReference>() {
      public boolean accept(SModuleReference it) {
        return neq_ce40do_a0a0a0a0a0c0h(targetLanguage.getModuleReference(), it);
      }
    })) {
      targetLanguage.addExtendedLanguage(ext);
    }
  }

  private static SModuleReference check_ce40do_a0a0a0a0b0f(Language checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModuleReference();
    }
    return null;
  }
  private static boolean neq_ce40do_a0a0a0a0a0c0h(Object a, Object b) {
    return !(((a != null ? a.equals(b) : a == b)));
  }
}
