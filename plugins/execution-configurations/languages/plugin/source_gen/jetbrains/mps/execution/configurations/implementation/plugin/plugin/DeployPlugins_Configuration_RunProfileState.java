package jetbrains.mps.execution.configurations.implementation.plugin.plugin;

/*Generated by MPS */

import com.intellij.execution.configurations.RunProfileState;
import org.jetbrains.annotations.NotNull;
import com.intellij.execution.runners.ExecutionEnvironment;
import com.intellij.execution.Executor;
import com.intellij.execution.configurations.ConfigurationPerRunnerSettings;
import com.intellij.execution.configurations.RunnerSettings;
import org.jetbrains.annotations.Nullable;
import com.intellij.execution.ExecutionResult;
import com.intellij.execution.runners.ProgramRunner;
import com.intellij.execution.ExecutionException;
import com.intellij.openapi.project.Project;
import com.intellij.execution.ui.ConsoleView;
import jetbrains.mps.execution.api.configurations.ConsoleCreator;
import jetbrains.mps.ide.actions.StandaloneMPSStackTraceFilter;
import com.intellij.execution.process.ProcessHandler;
import jetbrains.mps.execution.api.commands.OutputRedirector;
import jetbrains.mps.ant.execution.Ant_Command;
import com.intellij.execution.process.ProcessAdapter;
import com.intellij.execution.process.ProcessEvent;
import java.io.File;
import org.jdom.Document;
import jetbrains.mps.util.JDOMUtil;
import org.jdom.JDOMException;
import java.io.IOException;
import jetbrains.mps.util.FileUtil;
import com.intellij.openapi.application.ex.ApplicationEx;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.execution.api.configurations.ConsoleProcessListener;
import jetbrains.mps.execution.api.configurations.DefaultExecutionResult;
import jetbrains.mps.execution.api.configurations.DefaultExecutionConsole;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.intellij.execution.executors.DefaultRunExecutor;

public class DeployPlugins_Configuration_RunProfileState implements RunProfileState {
  @NotNull
  private final DeployPlugins_Configuration myRunConfiguration;
  @NotNull
  private final ExecutionEnvironment myEnvironment;
  public DeployPlugins_Configuration_RunProfileState(@NotNull DeployPlugins_Configuration configuration, @NotNull Executor executor, @NotNull ExecutionEnvironment environment) {
    myRunConfiguration = configuration;
    myEnvironment = environment;
  }
  public ConfigurationPerRunnerSettings getConfigurationSettings() {
    return null;
  }
  public RunnerSettings getRunnerSettings() {
    return null;
  }
  @Nullable
  public ExecutionResult execute(Executor executor, @NotNull ProgramRunner runner) throws ExecutionException {
    Project project = myEnvironment.getProject();
    final DeployScript script = ScriptsHolder.get(myEnvironment);
    if (script == null) {
      throw new ExecutionException("Could not deploy plugins");
    }

    final Project projectFinal = project;

    String deployScriptLocation = script.getDeployScriptLocation();
    if ((deployScriptLocation == null || deployScriptLocation.length() == 0)) {
      script.dispose();
      ScriptsHolder.remove(myEnvironment);
      throw new ExecutionException("Can not generate deploy script");
    }

    ConsoleView console = ConsoleCreator.createConsoleView(project, false);
    console.addMessageFilter(new StandaloneMPSStackTraceFilter(project));

    ProcessHandler process;
    try {
      process = OutputRedirector.redirect(new Ant_Command().setTargetName_String("buildDependents assemble").createProcess(deployScriptLocation), new ProcessAdapter() {
        @Override
        public void processTerminated(ProcessEvent event) {
          if (event.getExitCode() == 0) {
            File artifacts = new File(script.getArtifactsPath());

            if (myRunConfiguration.getSkipModulesLoading()) {
              // using the same "advanced" technique we use for copying current project in mps command 

              // configuration supports only plugin construction 
              // which implies that plugin.xml can be only in PLUGIN_HOME/META-INF 
              for (File pluginDir : artifacts.listFiles()) {
                File pluginXml = new File(new File(pluginDir, "META-INF"), "plugin.xml");
                if (!(pluginXml.exists())) {
                  continue;
                }
                try {
                  Document document = JDOMUtil.loadDocument(pluginXml);
                  myRunConfiguration.removeLanguageLibraries(document.getRootElement(), projectFinal);
                  JDOMUtil.writeDocument(document, pluginXml);
                } catch (JDOMException e) {
                  // ignore and hope for the best 
                } catch (IOException e) {
                  // same as previous 
                }
              }
            }

            FileUtil.copyDir(artifacts, myRunConfiguration.getPluginsPath());
            script.dispose();
            ScriptsHolder.remove(myEnvironment);

            if (myRunConfiguration.getRestartCurrentInstance()) {
              ApplicationEx application = (ApplicationEx) ApplicationManager.getApplication();
              application.restart(true);
            }
          }
        }
      });
    } catch (ExecutionException e) {
      script.dispose();
      ScriptsHolder.remove(myEnvironment);
      throw new ExecutionException("Can not deploy plugins", e);
    }

    {
      ProcessHandler _processHandler = process;
      final ConsoleView _consoleView = console;
      _processHandler.addProcessListener(new ConsoleProcessListener(_consoleView));
      return new DefaultExecutionResult(_processHandler, new DefaultExecutionConsole(_consoleView.getComponent(), new _FunctionTypes._void_P0_E0() {
        public void invoke() {
          _consoleView.dispose();
        }
      }));
    }
  }
  public static boolean canExecute(String executorId) {
    if (DefaultRunExecutor.EXECUTOR_ID.equals(executorId)) {
      return true;
    }
    return false;
  }
}
