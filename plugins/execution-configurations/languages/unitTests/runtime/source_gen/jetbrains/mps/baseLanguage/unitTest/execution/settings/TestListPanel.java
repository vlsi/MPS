package jetbrains.mps.baseLanguage.unitTest.execution.settings;

/*Generated by MPS */

import jetbrains.mps.execution.lib.ui.ListPanel;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestNodeWrapperFactory;
import org.jetbrains.mps.openapi.model.SNodeReference;
import java.util.List;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.util.Computable;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Set;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import jetbrains.mps.project.GlobalScope;
import java.util.Collections;
import org.jetbrains.mps.openapi.util.SubProgressKind;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.ISelector;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.intellij.openapi.project.Project;

public class TestListPanel extends ListPanel<ITestNodeWrapper> {
  private boolean myIsTestMethods;

  @Nullable
  @Override
  protected ITestNodeWrapper wrap(SNode node) {
    return TestNodeWrapperFactory.tryToWrap(node);
  }

  @Override
  protected SNodeReference unwrap(ITestNodeWrapper element) {
    return element.getNodePointer();
  }

  @Override
  protected String getFqName(ITestNodeWrapper element) {
    return element.getCachedFqName();
  }

  @Override
  protected List<ITestNodeWrapper> collectCandidates(final ProgressMonitor progress) {
    final SRepository repo = ProjectHelper.fromIdeaProject(myProject).getRepository();
    return new ModelAccessHelper(repo).runReadAction(new Computable<List<ITestNodeWrapper>>() {
      public List<ITestNodeWrapper> compute() {
        List<SNode> nodesList = new ArrayList<SNode>();
        Iterable<SAbstractConcept> wrappedRootConcepts = TestNodeWrapperFactory.getWrappedRootConcepts();
        progress.start("Looking up...", Sequence.fromIterable(wrappedRootConcepts).count());
        for (SAbstractConcept c : Sequence.fromIterable(wrappedRootConcepts)) {
          Set<SNode> usages = FindUsagesFacade.getInstance().findInstances(GlobalScope.getInstance(), Collections.singleton(c), false, progress.subTask(1, SubProgressKind.REPLACING));
          ListSequence.fromList(nodesList).addSequence(SetSequence.fromSet(usages));
        }
        progress.done();
        if (myIsTestMethods) {
          List<ITestNodeWrapper> methodsList = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
          for (SNode testCase : nodesList) {
            ITestNodeWrapper wrapper = TestNodeWrapperFactory.tryToWrap(testCase);
            if (wrapper == null) {
              continue;
            }
            ListSequence.fromList(methodsList).addSequence(Sequence.fromIterable(wrapper.getTestMethods()));
          }
          return methodsList;
        } else {
          return ListSequence.fromList(nodesList).select(new ISelector<SNode, ITestNodeWrapper>() {
            public ITestNodeWrapper select(SNode it) {
              return wrap(it);
            }
          }).where(new IWhereFilter<ITestNodeWrapper>() {
            public boolean accept(ITestNodeWrapper it) {
              return it != null;
            }
          }).toListSequence();
        }
      }
    });
  }

  public TestListPanel(Project project, boolean isTestMethods) {
    super(project, "Tests");
    myIsTestMethods = isTestMethods;
    super.setData(ListSequence.fromList(new ArrayList<ITestNodeWrapper>()));
  }
}
