package jetbrains.mps.baseLanguage.unitTest.execution.tool;

/*Generated by MPS */

import jetbrains.mps.ide.ui.MPSTree;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestView;
import com.intellij.openapi.Disposable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestRunState;
import com.intellij.openapi.util.Disposer;
import java.util.List;
import java.util.Arrays;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.ide.ui.MPSTreeNode;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.baseLanguage.unitTest.execution.TestEvent;
import javax.swing.SwingUtilities;
import jetbrains.mps.ide.ui.TextTreeNode;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.smodel.ModelAccess;
import java.util.ArrayList;

public class TestTree extends MPSTree implements TestView, Disposable {
  @NotNull
  private final IOperationContext myOperationContext;
  private final TestRunState myState;
  private TestNameMap<TestCaseTreeNode, TestMethodTreeNode> myMap;
  private boolean isAllTree = true;
  private final TestTreeIconAnimator myAnimator;

  public TestTree(TestRunState state, @NotNull IOperationContext context, Disposable disposable) {
    Disposer.register(disposable, this);
    myState = state;
    myOperationContext = context;
    myMap = new TestNameMap<TestCaseTreeNode, TestMethodTreeNode>();
    isAllTree = !(UnitTestOptions.isHidePased());
    myAnimator = new TestTreeIconAnimator(this);
    myAnimator.init(state);
  }

  private void updateState(TestMethodTreeNode methodNode, TestCaseTreeNode testCaseNode, TestState testState) {
    methodNode.setState(testState);
    List<TestState> priorityList = Arrays.asList(TestState.IN_PROGRESS, TestState.PASSED, TestState.FAILED, TestState.ERROR, TestState.TERMINATED);
    TestState oldState = testCaseNode.getState();
    if (ListSequence.fromList(priorityList).indexOf(oldState) < ListSequence.fromList(priorityList).indexOf(testState)) {
      if (TestState.PASSED.equals(testState)) {
        for (MPSTreeNode method : testCaseNode) {
          if (!(TestState.PASSED.equals(((TestMethodTreeNode) method).getState()))) {
            return;
          }
        }
      }
      testCaseNode.setState(testState);
    }
  }

  @Override
  public void update() {
    if (myState.getAvailableText() != null) {
      return;
    }
    String loseTest = myState.getLostClass();
    String loseMethod = myState.getLostMethod();
    String test = myState.getCurrentClass();
    String method = myState.getCurrentMethod();
    final Wrappers._T<TestMethodTreeNode> methodNode = new Wrappers._T<TestMethodTreeNode>();
    if (loseTest != null && loseMethod != null) {
      methodNode.value = get(loseTest, loseMethod);
      TestCaseTreeNode testCaseNode = get(loseTest);
      if (methodNode.value != null && testCaseNode != null) {
        updateState(methodNode.value, testCaseNode, TestState.ERROR);
      }
    } else {
      TestCaseTreeNode testCaseNode = get(test);
      methodNode.value = get(test, method);
      if (methodNode.value != null && testCaseNode != null) {
        if (myState.isTerminated()) {
          updateState(methodNode.value, testCaseNode, TestState.TERMINATED);
          myAnimator.stopMovie();
        } else if (TestEvent.START_TEST_PREFIX.equals(myState.getToken())) {
          updateState(methodNode.value, testCaseNode, TestState.IN_PROGRESS);
          SwingUtilities.invokeLater(new Runnable() {
            public void run() {
              myAnimator.scheduleRepaint();
            }
          });
          if (UnitTestOptions.isTrackRunning()) {
            SwingUtilities.invokeLater(new Runnable() {
              public void run() {
                setCurrentNode(methodNode.value);
              }
            });
          }
        } else if (TestEvent.END_TEST_PREFIX.equals(myState.getToken())) {
          if (TestState.IN_PROGRESS.equals(methodNode.value.getState())) {
            updateState(methodNode.value, testCaseNode, TestState.PASSED);
          }
        } else if (TestEvent.FAILURE_TEST_PREFIX.equals(myState.getToken())) {
          updateState(methodNode.value, testCaseNode, TestState.FAILED);
        } else if (TestEvent.ERROR_TEST_PREFIX.equals(myState.getToken())) {
          methodNode.value.setState(TestState.ERROR);
          updateState(methodNode.value, testCaseNode, TestState.ERROR);
        }
      }
    }
    if (isFailed(methodNode.value) && UnitTestOptions.isSelectFirstFailded()) {
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          selectFirstDefectNode();
        }
      });
    }
    if (UnitTestOptions.isHidePased()) {
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          hidePassed(true);
        }
      });
    }
  }

  @Override
  public void dispose() {
    if (!(isDisposed())) {
      super.dispose();
    }
    myAnimator.dispose();
  }

  @Override
  public void init() {
    rebuildNow();
    expandAll();
  }

  @Override
  public MPSTreeNode rebuild() {
    MPSTreeNode root = new TextTreeNode("Tests");
    setRootVisible(false);
    TestNameMap<TestCaseTreeNode, TestMethodTreeNode> temp = new TestNameMap<TestCaseTreeNode, TestMethodTreeNode>();
    for (ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(myState.getTestsMap()).keySet())) {
      if (testCase == null) {
        continue;
      }
      TestCaseTreeNode testCaseTreeNode = myMap.get(testCase.getFqName());
      if (testCaseTreeNode == null) {
        testCaseTreeNode = new TestCaseTreeNode(myOperationContext, testCase);
      }
      testCaseTreeNode.removeAllChildren();
      boolean hasFailedTest = false;
      for (ITestNodeWrapper method : ListSequence.fromList(MapSequence.fromMap(myState.getTestsMap()).get(testCase))) {
        TestMethodTreeNode oldMethodTreeNode = myMap.get(testCase.getFqName(), method.getName());
        TestMethodTreeNode newMethodTreeNode = new TestMethodTreeNode(myOperationContext, method);
        TestMethodTreeNode methodTreeNode = (oldMethodTreeNode == null ?
          newMethodTreeNode :
          oldMethodTreeNode
        );
        boolean isFailedMethod = isFailed(methodTreeNode);
        hasFailedTest = hasFailedTest || isFailedMethod;
        if (isAllTree || isFailedMethod) {
          if (methodTreeNode == null) {
            continue;
          }
          testCaseTreeNode.add(methodTreeNode);
          temp.put(testCase, method, methodTreeNode);
        } else {
          temp.put(testCase, method, methodTreeNode);
        }
      }
      if (isAllTree || hasFailedTest) {
        root.add(testCaseTreeNode);
        temp.put(testCase, testCaseTreeNode);
      } else {
        temp.put(testCase, testCaseTreeNode);
      }
    }
    myMap = temp;
    return root;
  }

  public boolean hasFailedTests() {
    for (final ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(myState.getTestsMap()).keySet())) {
      if (testCase == null) {
        continue;
      }
      for (final ITestNodeWrapper method : ListSequence.fromList(MapSequence.fromMap(myState.getTestsMap()).get(testCase))) {
        final Wrappers._T<String> className = new Wrappers._T<String>();
        final Wrappers._T<String> methodName = new Wrappers._T<String>();
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            className.value = testCase.getFqName();
            methodName.value = method.getName();
          }
        });
        TestMethodTreeNode treeNode = myMap.get(className.value, methodName.value);
        if (method == null) {
          continue;
        }
        if (!(isPassed(treeNode))) {
          return true;
        }
      }
    }
    return false;
  }

  public void hidePassed(boolean hide) {
    isAllTree = !(hide);
    rebuildNow();
    expandAll();
  }

  public void buildFailedTestTree() {
    isAllTree = false;
    rebuildNow();
  }

  public List<String> getMethodName() {
    List<String> result = ListSequence.fromList(new ArrayList<String>());
    for (List<ITestNodeWrapper> values : MapSequence.fromMap(myState.getTestsMap()).values()) {
      for (ITestNodeWrapper value : values) {
        ListSequence.fromList(result).addElement(value.getName());
      }
    }
    return result;
  }

  public TestCaseTreeNode get(String className) {
    return myMap.get(className);
  }

  public TestMethodTreeNode get(String className, String methodName) {
    return myMap.get(className, methodName);
  }

  public void selectFirstDefectNode() {
    for (final ITestNodeWrapper testCase : SetSequence.fromSet(MapSequence.fromMap(myState.getTestsMap()).keySet())) {
      for (final ITestNodeWrapper method : ListSequence.fromList(MapSequence.fromMap(myState.getTestsMap()).get(testCase))) {
        final Wrappers._T<String> className = new Wrappers._T<String>();
        final Wrappers._T<String> methodName = new Wrappers._T<String>();
        ModelAccess.instance().runReadAction(new Runnable() {
          public void run() {
            className.value = testCase.getFqName();
            methodName.value = method.getName();
          }
        });
        TestMethodTreeNode testMethodTreeNode = myMap.get(className.value, methodName.value);
        if (isFailed(testMethodTreeNode)) {
          setCurrentNode(testMethodTreeNode);
          return;
        }
      }
    }
  }

  public static boolean isFailed(MPSTreeNode node) {
    if (node == null || !(node.isLeaf())) {
      return false;
    }
    TestMethodTreeNode leaf = (TestMethodTreeNode) node;
    TestState state = leaf.getState();
    return state.equals(TestState.ERROR) || state.equals(TestState.FAILED);
  }

  public static boolean isPassed(TestMethodTreeNode method) {
    if (method == null) {
      return true;
    }
    return method.getState() != null && method.getState().equals(TestState.PASSED);
  }
}
