package jetbrains.mps.baseLanguage.unitTest.execution.settings;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.progress.EmptyProgressMonitor;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.execution.lib.PointerUtils;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.smodel.MPSModuleRepository;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestNodeWrapperFactory;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import jetbrains.mps.ide.project.ProjectHelper;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import jetbrains.mps.smodel.ModelAccess;

public enum JUnitRunTypes {
  PROJECT() {
    @Override
    protected Iterable<ITestNodeWrapper> doCollect(JUnitSettings_Configuration configuration, Project project, ProgressMonitor monitor) {
      if (project == null) {
        return Sequence.fromIterable(Collections.<ITestNodeWrapper>emptyList());
      }
      return TestUtils.getProjectTests(project, monitor, false);
    }
    @Override
    public String check(JUnitSettings_Configuration configuration, Project project) {
      // @check is used nowhere 
      // TODO: use it 
      if (project == null) {
        return null;
      }
      if (!(this.hasTests(configuration, project))) {
        return "Project does not contain tests.";
      }
      return null;
    }
    public boolean hasTests(JUnitSettings_Configuration configuration, Project project) {
      // kinda hoping it takes no time 
      if (project == null) {
        return false;
      }
      return Sequence.fromIterable(TestUtils.getProjectTests(project, new EmptyProgressMonitor(), true)).isNotEmpty();
    }

  },
  MODULE() {
    @Override
    protected Iterable<ITestNodeWrapper> doCollect(JUnitSettings_Configuration configuration, Project project, ProgressMonitor monitor) {
      SModule module = TestUtils.getModule(configuration.getModule());
      if (module == null) {
        return Sequence.fromIterable(Collections.<ITestNodeWrapper>emptyList());
      }
      return TestUtils.getModuleTests(module, monitor, false);
    }
    public String check(JUnitSettings_Configuration configuration, Project project) {
      if (isEmptyString(configuration.getModule())) {
        return "Module is not selected.";
      }
      SModule module = TestUtils.getModule(configuration.getModule());
      if (module == null) {
        return "Module " + configuration.getModule() + " does not exist.";
      }
      if (!(this.hasTests(configuration, project))) {
        return "No tests found in module " + configuration.getModule() + "";
      }
      return null;
    }
    public boolean hasTests(JUnitSettings_Configuration configuration, Project project) {
      SModule module = TestUtils.getModule(configuration.getModule());
      if (module == null) {
        return false;
      }
      return Sequence.fromIterable(TestUtils.getModuleTests(module, new EmptyProgressMonitor(), true)).isNotEmpty();
    }

  },
  MODEL() {
    @Override
    protected Iterable<ITestNodeWrapper> doCollect(JUnitSettings_Configuration configuration, Project project, ProgressMonitor monitor) {
      SModel model = TestUtils.getModel(configuration.getModel());
      if (model == null) {
        return Sequence.fromIterable(Collections.<ITestNodeWrapper>emptyList());
      }
      return TestUtils.getModelTests(model, monitor, false);
    }
    public String check(JUnitSettings_Configuration configuration, Project project) {
      if (configuration.getModel() == null) {
        return "Model is not selected.";
      }
      SModel model = TestUtils.getModel(configuration.getModel());
      if (model == null) {
        return "Could not find model " + configuration.getModel();
      }
      if (!(this.hasTests(configuration, project))) {
        return "No tests found in model " + configuration.getModel() + ".";
      }
      return null;
    }
    public boolean hasTests(JUnitSettings_Configuration configuration, Project project) {
      SModel model = TestUtils.getModel(configuration.getModel());
      if (model == null) {
        return false;
      }
      return Sequence.fromIterable(TestUtils.getModelTests(model, new EmptyProgressMonitor(), true)).isNotEmpty();
    }

  },
  NODE() {
    @Override
    protected Iterable<ITestNodeWrapper> doCollect(JUnitSettings_Configuration configuration, Project project, ProgressMonitor monitor) {
      return TestUtils.wrapPointerStrings(configuration.getTestCases());
    }
    public String check(JUnitSettings_Configuration configuration, Project project) {
      if ((configuration.getTestCases() == null || configuration.getTestCases().isEmpty())) {
        return "Classes list is empty.";
      }
      if (configuration.getTestCases() != null) {
        for (String testCase : configuration.getTestCases()) {
          SNodeReference pointer = PointerUtils.stringToPointer(testCase);
          if (pointer == null || ((SNodePointer) pointer).resolve(MPSModuleRepository.getInstance()) == null || TestNodeWrapperFactory.tryToWrap(((SNodePointer) pointer).resolve(MPSModuleRepository.getInstance())) == null) {
            return "Could not find test case for id " + testCase + ".";
          }
        }
      }
      return null;
    }
    public boolean hasTests(JUnitSettings_Configuration configuration, Project project) {
      return Sequence.fromIterable(this.doCollect(configuration, project, new EmptyProgressMonitor())).isNotEmpty();
    }

  },
  METHOD() {
    @Override
    protected Iterable<ITestNodeWrapper> doCollect(JUnitSettings_Configuration configuration, Project project, ProgressMonitor monitor) {
      return TestUtils.wrapPointerStrings(configuration.getTestMethods());
    }
    @Override
    public String check(JUnitSettings_Configuration configuration, Project project) {
      if ((configuration.getTestMethods() == null || configuration.getTestMethods().isEmpty())) {
        return "Methods list is empty.";
      }
      if (configuration.getTestMethods() != null) {
        for (String method : configuration.getTestMethods()) {
          SNodeReference pointer = PointerUtils.stringToPointer(method);
          if (pointer == null || ((SNodePointer) pointer).resolve(MPSModuleRepository.getInstance()) == null || TestNodeWrapperFactory.tryToWrap(((SNodePointer) pointer).resolve(MPSModuleRepository.getInstance())) == null) {
            return "Could not find test method for id " + method + ".";
          }
        }
      }
      return null;
    }
    @Override
    public boolean hasTests(JUnitSettings_Configuration configuration, Project project) {
      return Sequence.fromIterable(this.doCollect(configuration, project, new EmptyProgressMonitor())).isNotEmpty();
    }

  };

  JUnitRunTypes() {
  }



  public Iterable<ITestNodeWrapper> collect(JUnitSettings_Configuration configuration, Project project) {
    return collect(configuration, project, false);
  }



  public final Iterable<ITestNodeWrapper> collect(final JUnitSettings_Configuration configuration, final Project project, boolean recollect) {
    if (recollect || cachedTests == null) {
      ProgressManager.getInstance().run(new Task.Backgroundable(ProjectHelper.toIdeaProject(project), "Collecting Tests to Run", true) {
        @Override
        public void run(@NotNull ProgressIndicator indicator) {
          final ProgressMonitor monitor = new ProgressMonitorAdapter(indicator);
          ModelAccess.instance().runReadAction(new Runnable() {
            public void run() {
              cachedTests = Sequence.fromIterable(doCollect(configuration, project, monitor)).toListSequence();
            }
          });
        }
      });
    }
    return cachedTests;
  }



  protected abstract Iterable<ITestNodeWrapper> doCollect(JUnitSettings_Configuration configuration, Project project, ProgressMonitor monitor);



  public abstract boolean hasTests(JUnitSettings_Configuration configuration, Project project);


  private Iterable<ITestNodeWrapper> cachedTests = null;


  public abstract String check(JUnitSettings_Configuration configuration, Project project);

  private static boolean isEmptyString(String str) {
    return str == null || str.length() == 0;
  }
}
