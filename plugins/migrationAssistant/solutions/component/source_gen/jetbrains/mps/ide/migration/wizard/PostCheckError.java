package jetbrains.mps.ide.migration.wizard;

/*Generated by MPS */

import jetbrains.mps.project.Project;
import jetbrains.mps.ide.migration.ScriptApplied;
import jetbrains.mps.lang.migration.runtime.base.Problem;
import com.intellij.openapi.progress.ProgressIndicator;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.migration.component.util.MigrationsUtil;
import jetbrains.mps.ide.migration.check.MigrationCheckUtil;

public class PostCheckError extends MigrationErrorDescriptor {
  private Project myProject;
  private boolean myHaveBadCode;
  private Iterable<ScriptApplied> myMigrationsToCheck;

  public PostCheckError(Project p, Iterable<ScriptApplied> migrationsToCheck, boolean haveBadCode) {
    myProject = p;
    myHaveBadCode = haveBadCode;
    myMigrationsToCheck = migrationsToCheck;
  }
  public String getMessage() {
    String res = "Migration Assistant was unable to migrate some nodes in this project.<br><br>";
    if (myHaveBadCode) {
      res += "Problems will be shown in Model Checker tool when the project is loaded.";
    } else {
      res += "Some code can't be migrated automatically and should be changed manually.<br>" + "Places to be changed manually will be shown in Model Checker tool after the project is loaded.<br>";
      res += "You can re-run search for not migrated code at any time by choosing MainMenu->Migrations->Run Pre-Update Check";
    }
    return res;
  }
  public Iterable<Problem> getProblems(ProgressIndicator progressIndicator) {
    Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(myProject);
    return MigrationCheckUtil.getNotMigrated(modules, myMigrationsToCheck, MigrationCheckUtil.progressIndicatorToCallback(progressIndicator, 0, 1.0), 100);
  }
  @Override
  public boolean canIgnore() {
    return false;
  }
}
