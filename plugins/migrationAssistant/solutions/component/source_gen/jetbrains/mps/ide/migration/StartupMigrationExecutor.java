package jetbrains.mps.ide.migration;

/*Generated by MPS */

import com.intellij.openapi.components.State;
import com.intellij.openapi.components.Storage;
import com.intellij.openapi.components.StoragePathMacros;
import com.intellij.openapi.components.AbstractProjectComponent;
import com.intellij.openapi.components.PersistentStateComponent;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.startup.StartupManager;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.vfs.VirtualFileManager;
import com.intellij.openapi.project.ex.ProjectManagerEx;
import com.intellij.util.Consumer;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.annotations.Nullable;

@State(name = "StartupMigrationExecutor", storages = {@Storage(file = StoragePathMacros.WORKSPACE_FILE)
})
public class StartupMigrationExecutor extends AbstractProjectComponent implements PersistentStateComponent<StartupMigrationExecutor.MyState> {
  private final MigrationManager myMigrationManager;
  private StartupMigrationExecutor.MyState myState = new StartupMigrationExecutor.MyState();
  protected StartupMigrationExecutor(Project project, MigrationManager migrationManager) {
    super(project);
    myMigrationManager = migrationManager;
  }
  @Override
  public void projectOpened() {
    if (!(myMigrationManager.isMigrationRequired())) {
      return;
    }
    StartupManager.getInstance(myProject).registerPostStartupActivity(new Runnable() {
      public void run() {
        if (!(myState.reloadFinished)) {
          ApplicationManager.getApplication().runWriteAction(new Runnable() {
            @Override
            public void run() {
              VirtualFileManager.getInstance().syncRefresh();
              myState.reloadFinished = true;
              ProjectManagerEx.getInstance().reloadProject(myProject);
            }
          });
        } else {
          myState.reloadFinished = false;
          final boolean[] success = new boolean[1];
          MigrationAssistantWizard wizard = new MigrationAssistantWizard(myProject, myMigrationManager, success);
          // final reload is needed to cleanup memory (unload models) and do possible switches (e.g. to a new persistence) 
          wizard.showAndGetOk().doWhenDone(new Consumer<Boolean>() {
            @Override
            public void consume(Boolean finished) {
              if (!(finished)) {
                return;
              }
              if (!(success[0])) {
                return;
              }
              ModelAccess.instance().runWriteAction(new Runnable() {
                public void run() {
                  MPSModuleRepository.getInstance().saveAll();
                }
              });
              ApplicationManager.getApplication().runWriteAction(new Runnable() {
                @Override
                public void run() {
                  ProjectManagerEx.getInstance().reloadProject(myProject);
                }
              });
            }
          });
        }
      }
    });
  }
  @Nullable
  @Override
  public StartupMigrationExecutor.MyState getState() {
    return myState;
  }
  @Override
  public void loadState(StartupMigrationExecutor.MyState state) {
    myState = state;
  }
  public static class MyState {
    public boolean reloadFinished = false;
  }
}
