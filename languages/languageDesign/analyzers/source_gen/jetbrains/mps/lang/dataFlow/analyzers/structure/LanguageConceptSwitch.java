package jetbrains.mps.lang.dataFlow.analyzers.structure;

/*Generated by MPS */

import jetbrains.mps.lang.smodel.LanguageConceptIndex;
import jetbrains.mps.lang.smodel.LanguageConceptIndexBuilder;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public final class LanguageConceptSwitch {
  private final LanguageConceptIndex myIndex;
  public static final int AnalysisDirection = 0;
  public static final int Analyzer = 1;
  public static final int AnalyzerConstructorParameter = 2;
  public static final int AnalyzerConstructorParameterReference = 3;
  public static final int AnalyzerFunFunction = 4;
  public static final int AnalyzerFunParameterInput = 5;
  public static final int AnalyzerFunParameterProgramState = 6;
  public static final int AnalyzerFunParameterStateValues = 7;
  public static final int AnalyzerFunctionResultType = 8;
  public static final int AnalyzerInitialFunction = 9;
  public static final int AnalyzerMergeFunction = 10;
  public static final int AnalyzerMergeParameterInput = 11;
  public static final int AnalyzerParameterProgram = 12;
  public static final int AnalyzerRunnerAnalyzeOperation = 13;
  public static final int AnalyzerRunnerClassKeeper = 14;
  public static final int AnalyzerRunnerCreator = 15;
  public static final int AnalyzerRunnerType = 16;
  public static final int ApplicableCondition = 17;
  public static final int ApplicableNodeReference = 18;
  public static final int BackwardDirection = 19;
  public static final int ConceptCondition = 20;
  public static final int CustomInstructionsContainer = 21;
  public static final int CustomInstructionsContainerReference = 22;
  public static final int EmitInstruction = 23;
  public static final int ForwardDirection = 24;
  public static final int InsertAfterPosition = 25;
  public static final int InsertBeforePosition = 26;
  public static final int InsertPosition = 27;
  public static final int Instruction = 28;
  public static final int InstructionClassKeeper = 29;
  public static final int InstructionParameter = 30;
  public static final int InstructionReference = 31;
  public static final int IsOperation = 32;
  public static final int PatternCondition = 33;
  public static final int ProgramParameter = 34;
  public static final int Rule = 35;
  public static final int RuleReference = 36;

  public LanguageConceptSwitch() {
    LanguageConceptIndexBuilder builder = new LanguageConceptIndexBuilder(0x97a52717898f4598L, 0x8150573d9fd03868L);
    builder.put(0x7f5b799a00c2fb86L, AnalysisDirection);
    builder.put(0x5bd9e43c93f46789L, Analyzer);
    builder.put(0x376a4d52f8c420b0L, AnalyzerConstructorParameter);
    builder.put(0x376a4d52f8c421f8L, AnalyzerConstructorParameterReference);
    builder.put(0x41dd50940e1dd4c9L, AnalyzerFunFunction);
    builder.put(0x41dd50940e1dd4d4L, AnalyzerFunParameterInput);
    builder.put(0x41dd50940e1dd4d2L, AnalyzerFunParameterProgramState);
    builder.put(0x7e9442f75769ab4eL, AnalyzerFunParameterStateValues);
    builder.put(0x7f5b799a00c52fa7L, AnalyzerFunctionResultType);
    builder.put(0x41dd50940e1dd4c8L, AnalyzerInitialFunction);
    builder.put(0x58ba0a6689e9c309L, AnalyzerMergeFunction);
    builder.put(0x41dd50940e1d7ec5L, AnalyzerMergeParameterInput);
    builder.put(0x41dd50940e1d7ebcL, AnalyzerParameterProgram);
    builder.put(0x151c4f99e489a11L, AnalyzerRunnerAnalyzeOperation);
    builder.put(0x13ac225cc9e9f5bfL, AnalyzerRunnerClassKeeper);
    builder.put(0x151c4f99e489a16L, AnalyzerRunnerCreator);
    builder.put(0x1c63af9d2f3a7f23L, AnalyzerRunnerType);
    builder.put(0x2e25b6b7919dd6d8L, ApplicableCondition);
    builder.put(0x449938e788f30110L, ApplicableNodeReference);
    builder.put(0x7f5b799a00c2fb96L, BackwardDirection);
    builder.put(0x449938e788e9b9deL, ConceptCondition);
    builder.put(0x73e1fea9c172b8b1L, CustomInstructionsContainer);
    builder.put(0x73e1fea9c1738798L, CustomInstructionsContainerReference);
    builder.put(0x3a887e9da0b3e894L, EmitInstruction);
    builder.put(0x7f5b799a00c2fb88L, ForwardDirection);
    builder.put(0x74ea0fbaafcebf24L, InsertAfterPosition);
    builder.put(0x74ea0fbaafce9c9fL, InsertBeforePosition);
    builder.put(0x74ea0fbaafcebf23L, InsertPosition);
    builder.put(0x5bd9e43c93f4678aL, Instruction);
    builder.put(0x57e18a43f31d0ef6L, InstructionClassKeeper);
    builder.put(0x5faaa6bbd583aa0L, InstructionParameter);
    builder.put(0x3a887e9da0b4cedcL, InstructionReference);
    builder.put(0x6ed2c546d46ea462L, IsOperation);
    builder.put(0x2e25b6b7919e0b63L, PatternCondition);
    builder.put(0x33bb3f8bce3bc61cL, ProgramParameter);
    builder.put(0x5faaa6bbd57b6c8L, Rule);
    builder.put(0xa72ff3b2ca7c5b0L, RuleReference);
    myIndex = builder.seal();
  }

  /*package*/ int index(SConceptId cid) {
    return myIndex.index(cid);
  }

  public int index(SAbstractConcept concept) {
    return myIndex.index(concept);
  }
}
