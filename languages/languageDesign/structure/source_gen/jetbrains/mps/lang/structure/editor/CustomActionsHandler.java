package jetbrains.mps.lang.structure.editor;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import jetbrains.mps.openapi.editor.cells.EditorCell;
import jetbrains.mps.editor.runtime.cells.ReadOnlyUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import jetbrains.mps.openapi.editor.selection.SelectionManager;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class CustomActionsHandler {
  /*package*/ static boolean canHandleAbstractConceptDeclarationMemberActions(SNode node, EditorContext editorContext) {
    EditorCell nodeCell = editorContext.getEditorComponent().findNodeCell(node);
    return nodeCell != null && !(ReadOnlyUtil.isCellOrSelectionReadOnlyInEditor(editorContext.getEditorComponent(), nodeCell)) && SNodeOperations.isInstanceOf(SNodeOperations.getParent(node), "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration");
  }



  /*package*/ static boolean backspaceElementFromCollectionAndSetSelection(SNode node, Iterable<SNode> nodes, EditorContext editorContext) {
    Tuples._2<SNode, SNode> prevNextTuple = getPrevNext(node, nodes);
    SNodeOperations.deleteNode(node);
    if (prevNextTuple._0() != null) {
      SelectionUtil.selectLabelCellAnSetCaret(editorContext, prevNextTuple._0(), SelectionManager.LAST_CELL, -1);
      return true;
    } else if (prevNextTuple._1() != null) {
      SelectionUtil.selectLabelCellAnSetCaret(editorContext, prevNextTuple._1(), SelectionManager.FIRST_CELL, 0);
      return true;
    }
    return false;
  }



  /*package*/ static boolean deleteElementFromCollectionAndSetSelection(SNode node, Iterable<SNode> nodes, EditorContext editorContext) {
    Tuples._2<SNode, SNode> prevNextTuple = getPrevNext(node, nodes);
    SNodeOperations.deleteNode(node);
    if (prevNextTuple._1() != null) {
      SelectionUtil.selectLabelCellAnSetCaret(editorContext, prevNextTuple._1(), SelectionManager.FIRST_CELL, 0);
      return true;
    } else if (prevNextTuple._0() != null) {
      SelectionUtil.selectLabelCellAnSetCaret(editorContext, prevNextTuple._0(), SelectionManager.LAST_CELL, -1);
      return true;
    }
    return false;
  }

  private static Tuples._2<SNode, SNode> getPrevNext(SNode node, Iterable<SNode> nodes) {
    SNode prevNode = null;
    SNode nextNode = null;
    boolean nodeVisited = false;
    for (SNode n : Sequence.fromIterable(nodes)) {
      if (n == node) {
        nodeVisited = true;
        continue;
      }
      if (!(nodeVisited)) {
        prevNode = n;
      } else {
        nextNode = n;
        break;
      }
    }
    return MultiTuple.<SNode,SNode>from(prevNode, nextNode);
  }
}
