package jetbrains.mps.baseLanguage.closures.helper;

/*Generated by MPS */

import jetbrains.mps.generator.template.TemplateQueryContext;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.core.behavior.INamedConcept_BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.baseLanguage.closures.behavior.FunctionType_BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.typesystem.runtime.HUtil;

public class AdaptableClassifierTarget {
  private TemplateQueryContext genContext;
  public AdaptableClassifierTarget(TemplateQueryContext genContext) {
    this.genContext = genContext;
  }
  public void setTarget(SNode adaptable, final SNode target) {
    List<SNode> allAdaptable = (List<SNode>) genContext.getStepObject(Keys.ALL_NEEDS_ADAPTED);
    if (allAdaptable == null) {
      allAdaptable = ListSequence.fromList(new ArrayList<SNode>());
      genContext.putStepObject(Keys.ALL_NEEDS_ADAPTED, allAdaptable);
    }
    if (!(ListSequence.fromList(allAdaptable).contains(SLinkOperations.getTarget(adaptable, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"))))) {
      ListSequence.fromList(allAdaptable).addElement(SLinkOperations.getTarget(adaptable, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")));
    }
    List<SNode> trgList = getOrCreateTargets(adaptable);
    if (!(ListSequence.fromList(trgList).any(new IWhereFilter<SNode>() {
      @Override
      public boolean accept(SNode cr) {
        return INamedConcept_BehaviorDescriptor.getFqName_idhEwIO9y.invoke(SLinkOperations.getTarget(target, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier"))).equals(INamedConcept_BehaviorDescriptor.getFqName_idhEwIO9y.invoke(cr));
      }
    }))) {
      ListSequence.fromList(trgList).addElement(SLinkOperations.getTarget(target, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")));
      Values.ADAPTABLE.set(genContext, SLinkOperations.getTarget(target, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")), SLinkOperations.getTarget(adaptable, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")));
    }
  }
  private List<SNode> getOrCreateTargets(SNode adaptable) {
    List<SNode> trgList = (List<SNode>) genContext.getStepObject(Keys.NEEDS_ADAPTER.compose(INamedConcept_BehaviorDescriptor.getFqName_idhEwIO9y.invoke(SLinkOperations.getTarget(adaptable, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")))));
    if (trgList == null) {
      trgList = ListSequence.fromList(new ArrayList<SNode>());
      genContext.putStepObject(Keys.NEEDS_ADAPTER.compose(INamedConcept_BehaviorDescriptor.getFqName_idhEwIO9y.invoke(SLinkOperations.getTarget(adaptable, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")))), trgList);
    }
    return trgList;
  }
  public String getTargetName(SNode target) {
    SNode adaptable = (SNode) Values.ADAPTABLE.get(genContext, target);
    String aname = SPropertyOperations.getString(adaptable, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"));
    int aldidx = aname.lastIndexOf(".");
    aname = (aldidx >= 0 ? aname.substring(aldidx + 1) : aname);
    String tname = SPropertyOperations.getString(target, MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name"));
    int tldidx = tname.lastIndexOf(".");
    tname = (tldidx >= 0 ? tname.substring(tldidx + 1) : tname);
    return aname + "_to_" + tname + "_adapter";
  }
  public SNode getTarget(SNode expr) {
    SNode ntype = FunctionType_BehaviorDescriptor.getDeclarationRuntimeType_idhTOKQzf.invoke(SNodeOperations.as(TypeChecker.getInstance().getTypeOf(expr), MetaAdapterFactory.getConcept(0xfd3920347849419dL, 0x907112563d152375L, 0x1174a4d19ffL, "jetbrains.mps.baseLanguage.closures.structure.FunctionType")));
    ntype = (ntype == null ? TypeChecker.getInstance().getRuntimeSupport().coerce_(TypeChecker.getInstance().getTypeOf(expr), HUtil.createMatchingPatternByConcept(MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, "jetbrains.mps.baseLanguage.structure.ClassifierType")), true) : ntype);
    assert ntype != null;
    final String trgFQname = (String) Values.PREP_DATA.get(genContext, expr);
    SNode target = ListSequence.fromList(getTargets(SLinkOperations.getTarget(ntype, MetaAdapterFactory.getReferenceLink(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101de48bf9eL, 0x101de490babL, "classifier")))).findFirst(new IWhereFilter<SNode>() {
      @Override
      public boolean accept(SNode cr) {
        return trgFQname.equals(INamedConcept_BehaviorDescriptor.getFqName_idhEwIO9y.invoke(cr));
      }
    });
    assert Values.ADAPTABLE.get(genContext, target) != null;
    return target;
  }
  public List<SNode> getTargets(SNode adaptable) {
    return (List<SNode>) genContext.getStepObject(Keys.NEEDS_ADAPTER.compose(INamedConcept_BehaviorDescriptor.getFqName_idhEwIO9y.invoke(adaptable)));
  }
  public List<SNode> getAllAdaptable() {
    return (List<SNode>) genContext.getStepObject(Keys.ALL_NEEDS_ADAPTED);
  }
  public boolean hasAdaptable() {
    return ListSequence.fromList(getAllAdaptable()).isNotEmpty();
  }
}
