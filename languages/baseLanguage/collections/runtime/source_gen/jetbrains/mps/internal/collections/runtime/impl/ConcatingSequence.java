package jetbrains.mps.internal.collections.runtime.impl;

/*Generated by MPS */

import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ISequence;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class ConcatingSequence<U> extends Sequence<U> {
  private final ISequence<? extends U> left;
  private final ISequence<? extends U> right;

  public ConcatingSequence(ISequence<? extends U> left, ISequence<? extends U> right) {
    if (left == null || right == null) {
      throw new NullPointerException();
    }
    this.left = left;
    this.right = right;
  }

  @Override
  public Iterator<U> iterator() {
    return new ConcatingSequence.ConcatingIterator();
  }

  private class ConcatingIterator implements Iterator<U> {
    private U next;
    private HasNextState hasNext = HasNextState.UNKNOWN;
    private Iterator<? extends U> leftIt;
    private Iterator<? extends U> rightIt;

    private ConcatingIterator() {
    }

    @Override
    public boolean hasNext() {
      if (leftIt == null || rightIt == null) {
        init();
      }
      if (hasNext.unknown()) {
        moveToNext();
      }
      return hasNext.hasNext();
    }

    @Override
    public U next() {
      if (leftIt == null || rightIt == null) {
        init();
      }
      if (hasNext.unknown()) {
        moveToNext();
      }
      if (!((hasNext.hasNext()))) {
        throw new NoSuchElementException();
      }
      return clearNext();
    }

    @Override
    public void remove() {
      throw new UnsupportedOperationException();
    }

    private void init() {
      leftIt = left.toIterable().iterator();
      rightIt = right.toIterable().iterator();
    }

    private void moveToNext() {
      next = null;
      hasNext = HasNextState.AT_END;
      if (leftIt.hasNext()) {
        setNext(leftIt.next());
      } else
      if (rightIt.hasNext()) {
        setNext(rightIt.next());
      }
    }

    private U clearNext() {
      U tmp = next;
      next = null;
      hasNext = HasNextState.UNKNOWN;
      return tmp;
    }

    private void setNext(U next) {
      this.next = next;
      hasNext = HasNextState.HAS_NEXT;
    }
  }
}
