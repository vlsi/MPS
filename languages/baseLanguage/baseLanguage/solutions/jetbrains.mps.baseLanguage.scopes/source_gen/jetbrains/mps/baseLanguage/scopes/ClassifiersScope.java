package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import jetbrains.mps.scope.FilteringScope;
import jetbrains.mps.logging.Logger;
import jetbrains.mps.smodel.SModel;
import jetbrains.mps.smodel.IScope;
import jetbrains.mps.scope.ModelPlusImportedScope;
import java.util.List;
import jetbrains.mps.smodel.SNode;
import org.jetbrains.annotations.NotNull;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.smodel.SModelReference;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.smodel.LanguageID;
import jetbrains.mps.project.IModule;
import jetbrains.mps.smodel.SModelId;
import jetbrains.mps.smodel.StubMigrationHelper;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ITranslator2;
import jetbrains.mps.smodel.SModelDescriptor;
import jetbrains.mps.smodel.SModelFqName;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import java.util.Collection;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.ISelector;

public class ClassifiersScope extends FilteringScope {
  private static Logger LOG = Logger.getLogger(ClassifiersScope.class);
  private final SModel model;
  private final IScope scope;

  public ClassifiersScope(SModel model, IScope scope, String conceptFqName) {
    super(new ModelPlusImportedScope(model, false, scope, conceptFqName));
    // todo: not use delegating, use just getClassifiersByModel 
    this.model = model;
    this.scope = scope;
  }

  public List<SNode> getClassifiersByRefName(SModel model, @NotNull String refName) {
    List<SNode> result = new ArrayList<SNode>();

    String simpleName = refName.substring(Math.max(refName.lastIndexOf("$"), refName.lastIndexOf(".")) + 1);
    for (SNode classifier : getClassifiersByModelAndSimpleNamePrefix(model, scope, SConceptOperations.findConceptDeclaration("jetbrains.mps.baseLanguage.structure.Classifier"), simpleName)) {
      if (refName.equals(getRefName(classifier))) {
        ListSequence.fromList(result).addElement(classifier);
      }
    }
    return result;
  }

  @Override
  public boolean isExcluded(SNode node) {
    return SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.AnonymousClass");
  }

  @Override
  public SNode resolve(SNode contextNode, String refText) {
    SModelReference targetModelReference = null;
    // hack for [model]node construction, remove it 
    if (refText.startsWith("[")) {
      String[] modelNameAndTheRest = refText.split("]");
      if (modelNameAndTheRest.length > 1 || (modelNameAndTheRest.length == 1 && refText.endsWith("]"))) {
        refText = refText.substring(refText.indexOf("]") + 1).trim();
        String modelName = modelNameAndTheRest[0].substring(1).trim();
        if (modelName.length() > 0) {
          //  model: either current output or java_stub 
          if (!(modelName.equals(model.getLongName()))) {
            //  external java_stub 
            String stereo = SModelStereotype.getStubStereotypeForId(LanguageID.JAVA);
            Iterable<IModule> modules = model.getModelDescriptor().getModule().getScope().getVisibleModules();
            SModelId id = StubMigrationHelper.convertModelUIDInScope(stereo + "#" + modelName, Sequence.fromIterable(modules).translate(new ITranslator2<IModule, SModelDescriptor>() {
              public Iterable<SModelDescriptor> translate(IModule it) {
                return it.getOwnModelDescriptors();
              }
            }));
            targetModelReference = new SModelReference(new SModelFqName(modelName, stereo), id);
          }
        }
      }
    }
    // end of hack 

    SModel targetModel = null;
    if (targetModelReference != null && targetModelReference.getSModelId() != null) {
      targetModel = check_npo0wh_a0a0g0c(scope.getModelDescriptor(targetModelReference));
    }

    // todo: CRAP, rewrite it! 
    String classname = refText;
    int dotIndex = classname.lastIndexOf(".");
    if (dotIndex >= 0) {
      // try local nested classes 
      List<SNode> localClassifiers = getClassifiersByRefName((targetModel != null ?
        targetModel :
        model
      ), classname);
      if (ListSequence.fromList(localClassifiers).count() >= 1) {
        return ListSequence.fromList(localClassifiers).first();
      }

      if (classname.contains("$")) {
        // search everywhere 
        String package_ = classname.substring(0, dotIndex);
        classname = classname.substring(dotIndex + 1).replace('$', '.');
        return resolveClass(package_, null, classname);
      } else {
        String[] parts = classname.split("\\.");
        for (int sizeOfClassifier = 1; sizeOfClassifier <= parts.length; sizeOfClassifier++) {
          String packageName = IterableUtils.join(Sequence.fromIterable(Sequence.fromArray(parts)).take(parts.length - sizeOfClassifier), ".");
          String className = IterableUtils.join(Sequence.fromIterable(Sequence.fromArray(parts)).skip(parts.length - sizeOfClassifier), ".");
          SNode resolved = resolveClass(packageName, null, className);
          if (resolved != null) {
            return resolved;
          }
        }
      }
      // search everywhere 
      String package_ = classname.substring(0, dotIndex);
      classname = classname.substring(dotIndex + 1).replace('$', '.');

      return resolveClass(package_, null, classname);
    }

    if (targetModel != null) {
      return ListSequence.fromList(getClassifiersByRefName(targetModel, classname)).first();
    }
    SModelFqName modelname = (targetModelReference == null ?
      model.getSModelFqName() :
      targetModelReference.getSModelFqName()
    );
    return resolveClass(modelname.getLongName(), modelname.getStereotype(), classname);
  }

  public SNode resolveClass(String modelname, String stereotype, String nestedClassName) {
    List<SNode> classifiers = new ArrayList<SNode>();
    for (SModelDescriptor model : Sequence.fromIterable(getVisibleModels())) {
      SModelFqName modelFqName = model.getSModelReference().getSModelFqName();
      if (!(modelFqName.getLongName().equals(modelname))) {
        continue;
      }
      if (stereotype != null && !(modelFqName.getStereotype().equals(stereotype))) {
        continue;
      }

      ListSequence.fromList(classifiers).addSequence(ListSequence.fromList(getClassifiersByRefName(model.getSModel(), nestedClassName)));
    }

    if (ListSequence.fromList(classifiers).isEmpty()) {
      return null;
    }
    if (ListSequence.fromList(classifiers).count() > 1) {
      for (SNode cls : ListSequence.fromList(classifiers)) {
        if (SNodeOperations.getModel(cls) == model) {
          return cls;
        }
        if (check_npo0wh_a0b0a0e0d_0(check_npo0wh_a0a1a0a4a3_0(model)) == check_npo0wh_a0b0a0e0d(check_npo0wh_a0a1a0a4a3(SNodeOperations.getModel(cls)))) {
          return cls;
        }
      }
      Iterable<SNode> userClassifiers = ListSequence.fromList(classifiers).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SModelStereotype.isUserModel(SNodeOperations.getModel(it));
        }
      });
      if ((int) Sequence.fromIterable(userClassifiers).count() == 1) {
        return Sequence.fromIterable(userClassifiers).first();
      }

      // trying stubs 
      SModelDescriptor stub = getStubModelByName(modelname);
      if (stub != null) {
        Iterable<SNode> stubClassifiers = getClassifiersByRefName(stub.getSModel(), nestedClassName);
        if ((int) Sequence.fromIterable(stubClassifiers).count() == 1) {
          return Sequence.fromIterable(stubClassifiers).first();
        }
      }

      final StringBuilder warning = new StringBuilder();
      warning.append("reference can't be resolved: ");
      warning.append(nestedClassName);
      warning.append(" in ");
      warning.append(model.getLongName());
      warning.append(" can reference nodes from models: ");
      ListSequence.fromList(classifiers).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          warning.append(SNodeOperations.getModel(it).getSModelReference()).append("; ");
        }
      });

      LOG.warning(warning.toString());
      return null;
    }
    return ListSequence.fromList(classifiers).getElement(0);
  }

  private Iterable<SModelDescriptor> getVisibleModels() {
    Set<SModelDescriptor> visibleModels = SetSequence.fromSet(new HashSet<SModelDescriptor>());
    SetSequence.fromSet(visibleModels).addElement(model.getModelDescriptor());
    SetSequence.fromSet(visibleModels).addSequence(Sequence.fromIterable(((Iterable<IModule>) scope.getVisibleModules())).translate(new ITranslator2<IModule, SModelDescriptor>() {
      public Iterable<SModelDescriptor> translate(IModule it) {
        return it.getOwnModelDescriptors();
      }
    }).where(new IWhereFilter<SModelDescriptor>() {
      public boolean accept(SModelDescriptor it) {
        return it.isRegistered();
      }
    }));
    return visibleModels;
  }

  @Nullable
  private SModelDescriptor getStubModelByName(String packageName) {
    String stereo = SModelStereotype.getStubStereotypeForId(LanguageID.JAVA);
    SModelId id = StubMigrationHelper.convertModelUIDInScope(stereo + "#" + packageName, getVisibleModels());
    return scope.getModelDescriptor(new SModelReference(new SModelFqName(packageName, stereo), id));
  }

  @Override
  public String getReferenceText(SNode contextNode, SNode node) {
    // <node> 
    // todo: should use fqName 
    return getRefName(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier"));
  }

  private static String getRefName(SNode classifier) {
    String name = SPropertyOperations.getString(classifier, "name");
    if (name == null) {
      name = "";
    }
    SNode parent = SNodeOperations.getParent(classifier);
    if (SNodeOperations.isInstanceOf(parent, "jetbrains.mps.baseLanguage.structure.Classifier")) {
      return getRefName(SNodeOperations.cast(parent, "jetbrains.mps.baseLanguage.structure.Classifier")) + "." + name;
    }
    return name;
  }

  public static Iterable<SNode> getClassifiersByModelAndSimpleNamePrefix(final SModel model, IScope scope, SNode concreteConcept, @Nullable String prefix) {
    // for simplicity - prefix is prefix for simple name 
    // todo: use FastNodeFinder directly 
    return Sequence.fromIterable(new ModelPlusImportedScope(model, false, scope, BehaviorReflection.invokeVirtual(String.class, concreteConcept, "virtual_getFqName_1213877404258", new Object[]{})) {
      @Override
      public String getReferenceText(SNode contextNode, SNode node) {
        if (SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.AnonymousClass")) {
          // todo: why???, now it's fix for bug with jetbrains.mps.ui.sandbox 
          return null;
        }
        return SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.Classifier"), "name");
      }

      @Override
      public Collection<SModelDescriptor> getModels() {
        return Collections.singletonList(model.getModelDescriptor());
      }
    }.getAvailableElements(prefix)).select(new ISelector<SNode, SNode>() {
      public SNode select(SNode it) {
        return SNodeOperations.cast(it, "jetbrains.mps.baseLanguage.structure.Classifier");
      }
    });
  }

  private static SModel check_npo0wh_a0a0g0c(SModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getSModel();
    }
    return null;
  }

  private static IModule check_npo0wh_a0b0a0e0d(SModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }

  private static SModelDescriptor check_npo0wh_a0a1a0a4a3(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }

  private static IModule check_npo0wh_a0b0a0e0d_0(SModelDescriptor checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModule();
    }
    return null;
  }

  private static SModelDescriptor check_npo0wh_a0a1a0a4a3_0(SModel checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.getModelDescriptor();
    }
    return null;
  }
}
