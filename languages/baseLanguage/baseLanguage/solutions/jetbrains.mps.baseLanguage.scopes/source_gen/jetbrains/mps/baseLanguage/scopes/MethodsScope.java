package jetbrains.mps.baseLanguage.scopes;

/*Generated by MPS */

import jetbrains.mps.scope.Scope;
import java.util.Map;
import jetbrains.mps.smodel.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Collections;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.util.Pair;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;

public class MethodsScope extends Scope {
  private final Map<SNode, SNode> typeBindings;
  private final Map<String, List<SNode>> nameToMethods;

  public MethodsScope(Iterable<SNode> methods, Map<SNode, SNode> typeByTypeVariable) {
    nameToMethods = MapSequence.fromMap(new HashMap<String, List<SNode>>());
    for (SNode method : Sequence.fromIterable(methods)) {
      String name = SPropertyOperations.getString(method, "name");
      if (name != null) {
        if (MapSequence.fromMap(nameToMethods).containsKey(name)) {
          ListSequence.fromList(MapSequence.fromMap(nameToMethods).get(name)).addElement(method);
        } else {
          MapSequence.fromMap(nameToMethods).put(name, ListSequence.fromListAndArray(new ArrayList(), method));
        }
      }
    }

    this.typeBindings = typeByTypeVariable;
  }

  public MethodsScope(SNode classifierType, Iterable<SNode> methods) {
    this(methods, calcTypeBindings(classifierType));
  }

  public MethodsScope(Iterable<SNode> methods) {
    this(methods, Collections.<SNode,SNode>emptyMap());
  }

  public Iterable<SNode> getAvailableElements(@Nullable String prefix) {
    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());
    for (String methodName : MapSequence.fromMap(nameToMethods).keySet()) {
      if (prefix == null || methodName.startsWith(prefix)) {
        ListSequence.fromList(result).addSequence(ListSequence.fromList(MapSequence.fromMap(nameToMethods).get(methodName)));
      }
    }
    return result;
  }

  @Nullable
  public String getReferenceText(SNode contextNode, @NotNull SNode node) {
    return SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "name");
  }

  @Override
  public boolean contains(SNode node) {
    if (!(SNodeOperations.isInstanceOf(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"))) {
      return false;
    }
    String name = SPropertyOperations.getString(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"), "name");
    return MapSequence.fromMap(nameToMethods).containsKey(name) && ListSequence.fromList(MapSequence.fromMap(nameToMethods).get(name)).contains(SNodeOperations.cast(node, "jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration"));
  }

  @Nullable
  public SNode resolve(SNode contextNode, @NotNull String refText) {
    List<SNode> methods = (MapSequence.fromMap(nameToMethods).containsKey(refText) ?
      MapSequence.fromMap(nameToMethods).get(refText) :
      new ArrayList<SNode>()
    );
    if (methods.isEmpty()) {
      return null;
    }
    if (methods.size() == 1) {
      return ListSequence.fromList(methods).first();
    }
    if (!(SNodeOperations.isInstanceOf(contextNode, "jetbrains.mps.baseLanguage.structure.IMethodCall"))) {
      return null;
    }
    List<SNode> actualArguments = SLinkOperations.getTargets((SNodeOperations.cast(contextNode, "jetbrains.mps.baseLanguage.structure.IMethodCall")), "actualArgument", true);

    methods = MethodResolveUtil.selectByParmCount(methods, actualArguments);
    if (methods.size() == 1) {
      return ListSequence.fromList(methods).first();
    }

    Pair<SNode, Boolean> resolveByTypes = MethodResolveUtil.chooseByParameterTypeReportNoGoodMethodNode(null, methods, actualArguments, typeBindings);

    if (resolveByTypes.o2) {
      return resolveByTypes.o1;
    } else {
      return null;
    }
  }

  private static Map<SNode, SNode> calcTypeBindings(SNode classifierType) {
    SNode classifier = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), classifierType, "virtual_getClassifier_7405920559687237513", new Object[]{});
    return ((classifier != null) ?
      MethodResolveUtil.getTypesByTypeVars(SNodeOperations.cast(classifier, "jetbrains.mps.baseLanguage.structure.Classifier"), BehaviorReflection.invokeVirtual((Class<Iterable<SNode>>) ((Class) Object.class), classifierType, "virtual_getTypeParameters_7405920559687237518", new Object[]{})) :
      Collections.<SNode,SNode>emptyMap()
    );
  }
}
