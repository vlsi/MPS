package jetbrains.mps.lang.core.plugin;

/*Generated by MPS */

import jetbrains.mps.smodel.SNode;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.lang.core.behavior.BaseConcept_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Set;
import jetbrains.mps.smodel.SReference;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.kernel.model.SModelUtil;
import jetbrains.mps.smodel.constraints.INodeReferentSearchScopeProvider;
import jetbrains.mps.smodel.constraints.ModelConstraintsUtil;
import jetbrains.mps.smodel.constraints.SearchScopeStatus;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.errors.messageTargets.ReferenceMessageTarget;
import jetbrains.mps.lang.core.behavior.INamedConcept_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.project.IModule;
import java.util.HashSet;

public class RefScopeChecker extends AbstractConstraintsChecker {
  public RefScopeChecker() {
  }

  public void checkNode(final SNode node, LanguageErrorsComponent component, final IOperationContext operationContext) {
    if (operationContext == null) {
      return;
    }
    if (BaseConcept_Behavior.call_getMetaLevel_3981318653438234726(SNodeOperations.cast(node, "jetbrains.mps.lang.core.structure.BaseConcept")) != 0) {
      return;
    }
    Set<String> allVisibleModuleNames = getAllVisibleModuleNames(SNodeOperations.getModel(node).getModelDescriptor().getModule());
    SNode concept = SNodeOperations.getConceptDeclaration(node);
    for (SReference ref : SNodeOperations.getReferences(node)) {
      SNode target = SLinkOperations.getTargetNode(ref);
      SNode ld = SLinkOperations.findLinkDeclaration(ref);
      // don't check unresolved and broken references, they should already have an error message 
      if ((target == null) || ld == null) {
        continue;
      }
      component.addDependency(target);
      component.addDependency(ld);
      String linkRole = SModelUtil.getGenuineLinkRole(ld);
      final SNode linkTarget = SLinkOperations.getTarget(ld, "target", false);
      final INodeReferentSearchScopeProvider scopeProvider = ModelConstraintsUtil.getSearchScopeProvider(concept, linkRole);
      SearchScopeStatus searchScopeStatus = component.runCheckingAction(new _FunctionTypes._return_P0_E0<SearchScopeStatus>() {
        public SearchScopeStatus invoke() {
          return ModelConstraintsUtil.createSearchScope(scopeProvider, SNodeOperations.getModel(node), SNodeOperations.getParent(node), node, linkTarget, operationContext);
        }
      });
      if (searchScopeStatus.isError()) {
        component.addError(node, searchScopeStatus.getMessage(), (SNode) null, new ReferenceMessageTarget(SLinkOperations.getRole(ref)));
      } else if (!(searchScopeStatus.isDefault() || searchScopeStatus.getSearchScope().isInScope(target))) {
        String name = target.getName();
        component.addError(node, "reference" + ((name == null ?
          "" :
          " " + name
        )) + " (" + SLinkOperations.getRole(ref) + ") is out of search scope", searchScopeStatus.getReferenceValidatorNode(), new ReferenceMessageTarget(SLinkOperations.getRole(ref)));
      }
      String refModuleName = INamedConcept_Behavior.call_getFqName_1213877404258(SModelOperations.getModuleStub(SNodeOperations.getModel(target)));
      if (refModuleName != null && !(allVisibleModuleNames.contains(refModuleName))) {
        component.addError(node, "Target module " + refModuleName + " should be imported", null);
      }
    }
  }

  public Set<String> getAllVisibleModuleNames(IModule module) {
    Set<IModule> allVisibleModules = module.getDependenciesManager().getAllVisibleModules();
    Set<String> result = new HashSet<String>();
    for (IModule m : allVisibleModules) {
      result.add(m.getModuleFqName());
    }
    result.add(module.getModuleFqName());
    return result;
  }
}
