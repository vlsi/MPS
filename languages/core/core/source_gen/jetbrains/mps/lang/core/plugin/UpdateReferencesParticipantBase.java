package jetbrains.mps.lang.core.plugin;

/*Generated by MPS */

import jetbrains.mps.refactoring.participant.RefactoringParticipantBase;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.refactoring.participant.MoveNodeRefactoringParticipant;
import jetbrains.mps.refactoring.participant.RefactoringParticipant;
import jetbrains.mps.smodel.structure.Extension;
import jetbrains.mps.lang.migration.util.NodeReferenceUtil;
import jetbrains.mps.lang.migration.behavior.AbstractNodeReference__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import java.util.List;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.refactoring.participant.RefactoringSession;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.module.SearchScope;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.internal.collections.runtime.ISelector;
import java.util.Collections;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Collection;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.lang.smodel.query.runtime.CommandUtil;
import jetbrains.mps.lang.smodel.query.runtime.QueryExecutionContext;
import java.util.Set;
import org.jetbrains.mps.openapi.module.FindUsagesFacade;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.model.SearchResult;
import jetbrains.mps.refactoring.participant.NodeCopyTracker;
import jetbrains.mps.util.annotation.ToRemove;

public abstract class UpdateReferencesParticipantBase<T> extends RefactoringParticipantBase<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>, SNode, SNode> implements MoveNodeRefactoringParticipant<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>, RefactoringParticipant.PersistentRefactoringParticipant<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>, SNode, SNode> {

  public static class UpdateReferencesParticipant_extension extends Extension.Default<MoveNodeRefactoringParticipant<?, ?>> {
    public UpdateReferencesParticipant_extension() {
      super("jetbrains.mps.refactoring.participant.MoveNodeParticipantEP");
    }
    public MoveNodeRefactoringParticipant<?, ?> get() {
      return new UpdateReferencesParticipantBase.UpdateReferencesParticipant();
    }
  }

  public static class UpdateReferencesParticipant extends UpdateReferencesParticipantBase<Void> {
    public MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<UpdateReferencesParticipantBase.NodeData<Void>, UpdateReferencesParticipantBase.NodeData<Void>> getDataCollector() {
      final UpdateReferencesParticipantBase.MyMoveNodeRefactoringDataCollector dataCollector = new UpdateReferencesParticipantBase.MyMoveNodeRefactoringDataCollector();
      return new MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<UpdateReferencesParticipantBase.NodeData<Void>, UpdateReferencesParticipantBase.NodeData<Void>>() {
        public UpdateReferencesParticipantBase.NodeData<Void> beforeMove(SNode nodeToMove) {
          return new NodeData<Void>(dataCollector.beforeMove(nodeToMove), ((Void) null));
        }
        public UpdateReferencesParticipantBase.NodeData<Void> afterMove(SNode movedNode) {
          return new NodeData<Void>(dataCollector.afterMove(movedNode), ((Void) null));
        }
      };
    }
    public SNode serializeInitialState(UpdateReferencesParticipantBase.NodeData<Void> initialState) {
      return NodeReferenceUtil.makeReflection(initialState.baseData().reference(), initialState.baseData().name());
    }
    public SNode serializeFinalState(UpdateReferencesParticipantBase.NodeData<Void> finalState) {
      return NodeReferenceUtil.makeReflection(finalState.baseData().reference(), finalState.baseData().name());
    }
    public UpdateReferencesParticipantBase.NodeData<Void> deserializeFinalState(SNode serialized) {
      return new NodeData<Void>(new NamedNodeReference(AbstractNodeReference__BehaviorDescriptor.getNodeReference_id4uVwhQyQbdz.invoke(serialized), SPropertyOperations.getString(serialized, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x27bf3263be23f0dfL, 0x27bf3263be23f299L, "nodeName"))), ((Void) null));
    }
    public UpdateReferencesParticipantBase.NodeData<Void> deserializeInitialState(SNode serialized) {
      return new NodeData<Void>(new NamedNodeReference(AbstractNodeReference__BehaviorDescriptor.getNodeReference_id4uVwhQyQbdz.invoke(serialized), SPropertyOperations.getString(serialized, MetaAdapterFactory.getProperty(0x9074634404fd4286L, 0x97d5b46ae6a81709L, 0x27bf3263be23f0dfL, 0x27bf3263be23f299L, "nodeName"))), ((Void) null));
    }
    @Override
    protected boolean shouldUpdateReference(final List<RefactoringParticipant.Option> selectedOptions, final SRepository repository, final SNode containingNode, final SReferenceLink role, final SNode movingNode, final RefactoringSession refactoringSession) {
      // check other references participants 
      if (Sequence.fromIterable(new ExtensionPoint<MoveNodeRefactoringParticipant<?, ?>>("jetbrains.mps.refactoring.participant.MoveNodeParticipantEP").getObjects()).ofType(UpdateReferencesParticipantBase.UpdateReferencesParticipant.class).where(new IWhereFilter<UpdateReferencesParticipantBase.UpdateReferencesParticipant>() {
        public boolean accept(UpdateReferencesParticipantBase.UpdateReferencesParticipant it) {
          return UpdateReferencesParticipant.this.getClass().isAssignableFrom(it.getClass()) && neq_82eo7d_a0a0a0a0a0a0b0f3(UpdateReferencesParticipant.this.getClass(), it.getClass());
        }
      }).any(new IWhereFilter<UpdateReferencesParticipantBase.UpdateReferencesParticipant>() {
        public boolean accept(UpdateReferencesParticipantBase.UpdateReferencesParticipant it) {
          return it.shouldUpdateReference(selectedOptions, repository, containingNode, role, movingNode, refactoringSession);
        }
      })) {
        return false;
      }
      return super.shouldUpdateReference(selectedOptions, repository, containingNode, role, movingNode, refactoringSession);
    }
    private static boolean neq_82eo7d_a0a0a0a0a0a0b0f3(Object a, Object b) {
      return !(((a != null ? a.equals(b) : a == b)));
    }
  }

  public static class NamedNodeReference extends MultiTuple._2<SNodeReference, String> {
    public NamedNodeReference() {
      super();
    }
    public NamedNodeReference(SNodeReference reference, String name) {
      super(reference, name);
    }
    public SNodeReference reference(SNodeReference value) {
      return super._0(value);
    }
    public String name(String value) {
      return super._1(value);
    }
    public SNodeReference reference() {
      return super._0();
    }
    public String name() {
      return super._1();
    }
  }

  public static class NodeData<T> extends MultiTuple._2<UpdateReferencesParticipantBase.NamedNodeReference, T> {
    public NodeData() {
      super();
    }
    public NodeData(UpdateReferencesParticipantBase.NamedNodeReference baseData, T other) {
      super(baseData, other);
    }
    public UpdateReferencesParticipantBase.NamedNodeReference baseData(UpdateReferencesParticipantBase.NamedNodeReference value) {
      return super._0(value);
    }
    public T other(T value) {
      return super._1(value);
    }
    public UpdateReferencesParticipantBase.NamedNodeReference baseData() {
      return super._0();
    }
    public T other() {
      return super._1();
    }
  }


  public String getId() {
    return "moveNode.updateReferences";
  }
  public static final RefactoringParticipant.Option OPTION = new RefactoringParticipant.Option("moveNode.options.updateReferencesParticipant", "Update references");

  public static class MyMoveNodeRefactoringDataCollector implements MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<UpdateReferencesParticipantBase.NamedNodeReference, UpdateReferencesParticipantBase.NamedNodeReference> {
    public UpdateReferencesParticipantBase.NamedNodeReference beforeMove(SNode nodeToMove) {
      return new NamedNodeReference(nodeToMove.getReference(), NodeReferenceUtil.getNodePresentation(nodeToMove));
    }
    public UpdateReferencesParticipantBase.NamedNodeReference afterMove(SNode movedNode) {
      return new NamedNodeReference(movedNode.getReference(), NodeReferenceUtil.getNodePresentation(movedNode));
    }
  }


  public List<RefactoringParticipant.Option> getAvailableOptions(UpdateReferencesParticipantBase.NodeData<T> initialState, SRepository repository) {
    return ListSequence.fromListAndArray(new ArrayList<RefactoringParticipant.Option>(), OPTION);
  }

  public List<List<RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>>> getChanges(List<UpdateReferencesParticipantBase.NodeData<T>> initialStates, final SRepository repository, final List<RefactoringParticipant.Option> selectedOptions, SearchScope searchScope, ProgressMonitor progressMonitor) {
    if (!(ListSequence.fromList(selectedOptions).contains(OPTION))) {
      return ListSequence.fromList(initialStates).select(new ISelector<UpdateReferencesParticipantBase.NodeData<T>, List<RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>>>() {
        public List<RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>> select(UpdateReferencesParticipantBase.NodeData<T> it) {
          return (List<RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>>) Collections.<RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>>emptyList();
        }
      }).toListSequence();
    }
    Map<SNodeReference, UpdateReferencesParticipantBase.NodeData<T>> initialStatesMap = MapSequence.fromMap(new HashMap<SNodeReference, UpdateReferencesParticipantBase.NodeData<T>>());
    for (UpdateReferencesParticipantBase.NodeData<T> initialState : ListSequence.fromList(initialStates)) {
      MapSequence.fromMap(initialStatesMap).put(initialState.baseData().reference(), initialState);
    }
    Collection<SReference> usages;
    List<SNode> movedNodes = ListSequence.fromList(initialStates).select(new ISelector<UpdateReferencesParticipantBase.NodeData<T>, SNode>() {
      public SNode select(UpdateReferencesParticipantBase.NodeData<T> it) {
        return it.baseData().reference().resolve(repository);
      }
    }).toListSequence();
    {
      final SearchScope scope = CommandUtil.createScope(searchScope);
      QueryExecutionContext context = new QueryExecutionContext() {
        public SearchScope getDefaultSearchScope() {
          return scope;
        }
      };
      if (movedNodes != null) {
        progressMonitor.start("References in current project", 1);
        usages = (Set<SReference>) FindUsagesFacade.getInstance().findUsages(searchScope, SetSequence.fromSetWithValues(new HashSet<SNode>(), movedNodes), progressMonitor.subTask(1));
      } else {
        progressMonitor.start("References in current project", Sequence.fromIterable(CommandUtil.references(CommandUtil.createConsoleScope(null, false, context))).count());
        usages = CollectionSequence.fromCollection(new ArrayList<SReference>());
        for (SReference ref : Sequence.fromIterable(CommandUtil.references(CommandUtil.createConsoleScope(null, false, context)))) {
          if (ListSequence.fromList(initialStates).select(new ISelector<UpdateReferencesParticipantBase.NodeData<T>, SNodeReference>() {
            public SNodeReference select(UpdateReferencesParticipantBase.NodeData<T> it) {
              return it.baseData().reference();
            }
          }).contains(ref.getTargetNodeReference())) {
            CollectionSequence.fromCollection(usages).addElement(ref);
          }
          progressMonitor.advance(1);
          if (progressMonitor.isCanceled()) {
            return null;
          }
        }
      }
    }
    final Map<SNodeReference, List<RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>>> result = MapSequence.fromMap(new HashMap<SNodeReference, List<RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>>>());
    for (SReference ref : CollectionSequence.fromCollection(usages)) {
      final SNodeReference containingNode = ref.getSourceNode().getReference();
      @Nullable final SNode movingNode = ref.getTargetNode();
      final UpdateReferencesParticipantBase.NodeData<T> initialState = MapSequence.fromMap(initialStatesMap).get(ref.getTargetNodeReference());
      final SReferenceLink role = ref.getLink();
      final String resolveInfo = SLinkOperations.getResolveInfo(ref);
      final SearchResults searchResults = new SearchResults(SetSequence.fromSetAndArray(new HashSet<SNode>(), ref.getTargetNode()), ListSequence.fromListAndArray(new ArrayList<SearchResult<SNode>>(), new SearchResult<SNode>(ref.getSourceNode(), "reference")));
      RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>> change = new MoveNodeRefactoringParticipant.ChangeBase<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>() {
        public MoveNodeRefactoringParticipant<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>> getParticipant() {
          return UpdateReferencesParticipantBase.this;
        }
        public SearchResults getSearchResults() {
          return searchResults;
        }
        public void confirm(final UpdateReferencesParticipantBase.NodeData<T> finalState, final SRepository repository, final RefactoringSession refactoringSession) {
          refactoringSession.registerChange(new Runnable() {
            public void run() {
              if (shouldUpdateReference(selectedOptions, repository, containingNode.resolve(repository), role, movingNode, refactoringSession)) {
                doUpdateReference(selectedOptions, repository, containingNode.resolve(repository), role, initialState, finalState, resolveInfo);
                if (ListSequence.fromList(selectedOptions).contains(UpdateModelImports.OPTION)) {
                  doUpdateModelImport(selectedOptions, repository, containingNode.resolve(repository), role, finalState);
                }
              }
            }
          });
        }
      };
      if (MapSequence.fromMap(result).get(ref.getTargetNodeReference()) == null) {
        MapSequence.fromMap(result).put(ref.getTargetNodeReference(), ListSequence.fromList(new ArrayList<RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>>()));
      }
      ListSequence.fromList(MapSequence.fromMap(result).get(ref.getTargetNodeReference())).addElement(change);
    }
    return ListSequence.fromList(initialStates).select(new ISelector<UpdateReferencesParticipantBase.NodeData<T>, List<RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>>>() {
      public List<RefactoringParticipant.Change<UpdateReferencesParticipantBase.NodeData<T>, UpdateReferencesParticipantBase.NodeData<T>>> select(UpdateReferencesParticipantBase.NodeData<T> initialState) {
        return MapSequence.fromMap(result).get(initialState.baseData().reference());
      }
    }).toListSequence();
  }
  protected boolean shouldUpdateReference(final List<RefactoringParticipant.Option> selectedOptions, SRepository repository, final SNode containingNode, final SReferenceLink role, SNode movingNode, RefactoringSession refactoringSession) {
    NodeCopyTracker copyMap = NodeCopyTracker.get(refactoringSession);
    if (containingNode == null) {
      return false;
    }
    // do not update reference from old node to other old node 
    if (MapSequence.fromMap(copyMap.getCopyMap()).containsKey(containingNode) && movingNode != null && movingNode.getModel() != null) {
      return false;
    }
    return true;
  }
  protected void doUpdateReference(final List<RefactoringParticipant.Option> selectedOptions, SRepository repository, final SNode containingNode, final SReferenceLink role, UpdateReferencesParticipantBase.NodeData<T> oldTarget, UpdateReferencesParticipantBase.NodeData<T> newTarget, final String resolveInfo) {
    doUpdateReference(repository, containingNode, role, newTarget, resolveInfo);
  }
  @Deprecated
  @ToRemove(version = 3.5)
  protected void doUpdateReference(SRepository repository, final SNode containingNode, final SReferenceLink role, UpdateReferencesParticipantBase.NodeData<T> newTarget, final String resolveInfo) {
    containingNode.setReference(role, jetbrains.mps.smodel.SReference.create(role, containingNode, newTarget.baseData().reference().getModelReference(), newTarget.baseData().reference().getNodeId(), resolveInfo));
  }
  protected void doUpdateModelImport(List<RefactoringParticipant.Option> selectedOptions, SRepository repository, final SNode containingNode, final SReferenceLink role, UpdateReferencesParticipantBase.NodeData<T> newTarget) {
    UpdateModelImports.addModelImport(containingNode.getModel(), newTarget.baseData().reference().getModelReference().resolve(repository));
  }
}
